<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>UI System Prototype</title>
    <style>
        :root {
            --border-size: 24px;
            /* Must match border-image-width */
            --corner-radius: 12px;
            /* Approximate inner curve if needed */
        }

        body {
            background-color: #222;
            background-image: url('Assets/Image/Tile/grass.png');
            background-repeat: repeat;
            background-size: 64px 64px;
            /* Adjust scale as needed */
            margin: 0;
            overflow: hidden;
        }

        /* JS Noise generator removed in favor of texture */

        /*
           The Container controls the size and holds the border-image.
           It does NOT have the blur itself, to avoid blurring outside the border.
        */
        /* 
           The Container controls the size and holds the border-image.
           It does NOT have the blur itself, to avoid blurring outside the border.
        */
        .ui-frame {
            position: absolute;
            /* Changed to absolute for dragging */
            /* Start at a fixed position to avoid translate jumping */
            top: 100px;
            left: 100px;

            width: 400px;
            height: 300px;

            /* The 9-Slice Border */
            border: var(--border-size) solid transparent;
            /* Default to the USER'S image (even with red pixels) so they know it loaded */
            border-image-source: url('Assets/Image/frame.png');
            border-image-slice: 16 fill;
            border-image-width: var(--border-size);
            border-image-repeat: stretch;

            padding: 20px;
            box-sizing: border-box;
            color: white;
            cursor: move;
            /* Indicate draggable */
            user-select: none;
            /* Prevent text selection while dragging */

            /* Stacking Context Fix */
            z-index: 100;
            isolation: isolate;
        }

        /* 
           The Blur Zone
           Now uses CSS MASKS to restrict the blur to exactly the shape of the "Red Area".
           We use 'mask-border' (or -webkit-mask-box-image) to 9-slice the mask 
           just like the frame border-image.
        */
        .ui-blur-zone {
            position: absolute;
            /* Fill the entire element to extend into the border area */
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            z-index: -1;
            pointer-events: auto;
            /* Capture clicks for dragging (bubbles to parent) */

            /* The Blur Effect */
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            /* background-color: rgba(0, 0, 0, 0.3); REMOVED TINT */

            /* The Mask Logic (9-Slice Mask) */
            /* We start with placeholder, JS upgrades it to the generated mask */
            -webkit-mask-box-image-source: url('Assets/Image/frame.png');
            -webkit-mask-box-image-slice: 16 fill;
            -webkit-mask-box-image-width: var(--border-size);
            -webkit-mask-box-image-repeat: stretch;

            /* Standard property */
            mask-border-source: url('Assets/Image/frame.png');
            mask-border-slice: 16 fill;
            mask-border-width: var(--border-size);
            mask-border-repeat: stretch;

            /* Expand to cover the border area */
            margin: calc(var(--border-size) * -1);
        }

        .ui-inner {
            position: relative;
            z-index: 1;
            /* Above blur */
            height: 100%;
            display: flex;
            flex-direction: column;
            pointer-events: auto;
            /* Capture clicks for dragging */
        }

        /* Re-enable pointer events for interactive children */
        .btn,
        h2,
        p {
            pointer-events: auto;
        }

        /* Text Styles */
        h2 {
            border-bottom: 2px solid rgba(255, 255, 255, 0.2);
            padding-bottom: 10px;
            margin-top: 0;
            text-align: center;
        }

        .btn {
            margin-top: auto;
            padding: 10px;
            background: #555;
            border: 2px solid #fff;
            cursor: pointer;
            color: white;
            transition: 0.2s;
        }

        .btn:hover {
            background: #777;
        }

        .ui-frame.placeholder-mode {
            border: 4px solid #888;
            border-image: none;
        }
    </style>
</head>

<body>

    <div id="warnBanner" style="display:none; background:red; color:white; padding:10px; text-align:center;"></div>

    <!-- UI Component Example -->
    <div class="ui-frame" id="testFrame">
        <!-- Masked Blur Layer -->
        <div class="ui-blur-zone" id="blurLayer"></div>

        <!-- Actual UI Elements -->
        <div class="ui-inner">
            <h2>Inventory</h2>
            <p>Item: <strong>Lazor Pickaxe</strong></p>
            <p>Durability: 9000/9001</p>
            <p><i>"A shiny tool for a shiny person."</i></p>
            <button class="btn">Close</button>
        </div>
    </div>

    <script>
        // --- Dragging Logic ---
        const uiFrame = document.getElementById('testFrame');
        let isDragging = false;
        let dragOffsetX = 0;
        let dragOffsetY = 0;

        uiFrame.addEventListener('mousedown', (e) => {
            if (e.target.tagName === 'BUTTON') return;
            e.preventDefault();
            isDragging = true;

            const rect = uiFrame.getBoundingClientRect();
            dragOffsetX = e.clientX - rect.left;
            dragOffsetY = e.clientY - rect.top;

            uiFrame.style.transform = 'none';
            uiFrame.style.left = rect.left + 'px';
            uiFrame.style.top = rect.top + 'px';
            uiFrame.style.bottom = 'auto';
            uiFrame.style.right = 'auto';
        });

        window.addEventListener('mousemove', (e) => {
            if (!isDragging) return;
            uiFrame.style.left = (e.clientX - dragOffsetX) + 'px';
            uiFrame.style.top = (e.clientY - dragOffsetY) + 'px';
        });

        window.addEventListener('mouseup', () => {
            isDragging = false;
        });

        // --- Red Key Processor ---
        const frameUrl = 'Assets/Image/frame.png';

        const img = new Image();
        img.crossOrigin = "Anonymous"; // Try this, though file:// might ignore it

        img.onload = function () {
            try {
                const w = img.width;
                const h = img.height;
                const warnBanner = document.getElementById('warnBanner');
                if (warnBanner) warnBanner.style.display = 'none';

                let sliceSize = Math.floor(Math.min(w, h) / 3);
                if (sliceSize < 1) sliceSize = 1;

                const frameEl = document.getElementById('testFrame');
                const blurEl = document.getElementById('blurLayer');

                console.log(`Processing Red Key... ${w}x${h}`);

                // Canvas 1: Visual Frame (Red -> Transparent)
                const cFrame = document.createElement('canvas');
                cFrame.width = w; cFrame.height = h;
                const ctxFrame = cFrame.getContext('2d');
                ctxFrame.drawImage(img, 0, 0);

                // Canvas 2: Blur Mask (Red -> Opaque White, Else -> Transparent)
                const cMask = document.createElement('canvas');
                cMask.width = w; cMask.height = h;
                const ctxMask = cMask.getContext('2d');
                const maskData = ctxMask.createImageData(w, h);
                const mData = maskData.data;

                const frameData = ctxFrame.getImageData(0, 0, w, h);
                const fData = frameData.data;

                for (let i = 0; i < fData.length; i += 4) {
                    const r = fData[i], g = fData[i + 1], b = fData[i + 2], a = fData[i + 3];

                    // Check for RED (Red > 200, others low)
                    if (r > 200 && g < 50 && b < 50 && a > 0) {
                        // IT IS RED:
                        // 1. Remove from Visual Frame (make transparent hole)
                        fData[i + 3] = 0;

                        // 2. Add to Blur Mask (make visible)
                        mData[i] = mData[i + 1] = mData[i + 2] = 255;
                        mData[i + 3] = 255;
                    } else {
                        // NOT RED (Border):
                        // 1. Keep in Visual Frame
                        // 2. Hide from Blur Mask
                        mData[i + 3] = 0;
                    }
                }

                // Apply changes
                ctxFrame.putImageData(frameData, 0, 0);
                ctxMask.putImageData(maskData, 0, 0);

                const finalFrameUrl = cFrame.toDataURL();
                const finalMaskUrl = cMask.toDataURL();

                // Apply to DOM
                frameEl.style.borderImage = `url(${finalFrameUrl}) ${sliceSize} fill / var(--border-size) stretch`;

                // Enable Blur with Mask
                blurEl.style.display = 'block';
                // Pure Blur (Transparent fill)
                blurEl.style.backgroundColor = 'transparent';
                blurEl.style.backdropFilter = 'blur(10px)';
                blurEl.style.webkitBackdropFilter = 'blur(10px)';

                const maskVal = `url(${finalMaskUrl}) ${sliceSize} fill / var(--border-size) stretch`;
                blurEl.style.webkitMaskBoxImage = maskVal;
                blurEl.style.maskBorder = maskVal;

            } catch (err) {
                console.warn("Security/Script Error (likely file:// access):", err);
                const warnBanner = document.getElementById('warnBanner');
                if (warnBanner) {
                    warnBanner.style.display = 'block';
                    warnBanner.style.background = 'orange';
                    warnBanner.innerText = "Local File Security Blocked Red Key. Using Fallback (Raw Image).";
                }
                // Fallback: Just show raw image, no blur
                const frameEl = document.getElementById('testFrame');
                // Default 1/3 slice (re-calc locally if scope issue, but safe here)
                let sliceSize = Math.floor(Math.min(img.width, img.height) / 3);
                frameEl.style.borderImage = `url(${frameUrl}) ${sliceSize} fill / var(--border-size) stretch`;
            }
        };
    </script>

</body>

</html>