<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>UI System Prototype</title>
    <style>
        :root {
            --border-size: 24px;
            /* Must match border-image-width */
            --corner-radius: 12px;
            /* Approximate inner curve if needed */
        }

        body {
            background-color: #222;
            /* Pixel Noise Background to test Blur */
            background-image:
                linear-gradient(45deg, #333 25%, transparent 25%),
                linear-gradient(-45deg, #333 25%, transparent 25%),
                linear-gradient(45deg, transparent 75%, #333 75%),
                linear-gradient(-45deg, transparent 75%, #333 75%);
            background-size: 20px 20px;
            /* Add some colored noise dots */
            position: relative;
        }

        /* Pseudo-element for extra colorful noise - Denser/Full Screen */
        body::before {
            content: "";
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-image: radial-gradient(#ff0000 15%, transparent 16%),
                radial-gradient(#00ff00 15%, transparent 16%),
                radial-gradient(#0000ff 15%, transparent 16%);
            background-size: 30px 30px;
            /* Smaller size = more pixels */
            background-position: 0 0, 10px 10px, 20px 20px;
            pointer-events: none;
            z-index: -1;
            opacity: 0.8;
        }

        /*
           The Container controls the size and holds the border-image.
           It does NOT have the blur itself, to avoid blurring outside the border.
        */
        .ui-frame {
            position: absolute;
            /* Changed to absolute for dragging */
            /* Center initially */
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);

            width: 400px;
            height: 300px;

            /* The 9-Slice Border */
            border: var(--border-size) solid transparent;
            border-image-source: url('Assets/Image/ui_frame_placeholder.png');
            /* JS replaces this */
            border-image-slice: 16 fill;
            /* 'fill' is crucial to draw the center */
            border-image-width: var(--border-size);
            border-image-repeat: stretch;

            padding: 20px;
            box-sizing: border-box;
            color: white;
            cursor: move;
            /* Indicate draggable */
            user-select: none;
            /* Prevent text selection while dragging */
        }

        /*
           The Blur Zone
           Now uses CSS MASKS to restrict the blur to exactly the shape of the "Red Area".
           We use 'mask-border' (or -webkit-mask-box-image) to 9-slice the mask
           just like the frame border-image.
        */
        .ui-blur-zone {
            position: absolute;
            /* Fill the entire element to extend into the border area */
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            z-index: -1;
            pointer-events: none;
            /* Let clicks pass through to parent for dragging if needed */

            /* The Blur Effect */
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            background-color: rgba(0, 0, 0, 0.3);

            /* The Mask Logic (9-Slice Mask) */
            /* We start with placeholder, JS upgrades it to the generated mask */
            -webkit-mask-box-image-source: url('Assets/Image/ui_frame_placeholder.png');
            -webkit-mask-box-image-slice: 16 fill;
            -webkit-mask-box-image-width: var(--border-size);
            -webkit-mask-box-image-repeat: stretch;

            /* Standard property */
            mask-border-source: url('Assets/Image/ui_frame_placeholder.png');
            mask-border-slice: 16 fill;
            mask-border-width: var(--border-size);
            mask-border-repeat: stretch;

            /* Expand to cover the border area */
            margin: calc(var(--border-size) * -1);
        }

        .ui-inner {
            position: relative;
            z-index: 1;
            /* Above blur */
            height: 100%;
            display: flex;
            flex-direction: column;
            pointer-events: none;
            /* Let drags pass through container logic */
        }

        /* Re-enable pointer events for interactive children */
        .btn,
        h2,
        p {
            pointer-events: auto;
        }

        /* Text Styles */
        h2 {
            border-bottom: 2px solid rgba(255, 255, 255, 0.2);
            padding-bottom: 10px;
            margin-top: 0;
            text-align: center;
        }

        .btn {
            margin-top: auto;
            padding: 10px;
            background: #555;
            border: 2px solid #fff;
            cursor: pointer;
            color: white;
            transition: 0.2s;
        }

        .btn:hover {
            background: #777;
        }

        .ui-frame.placeholder-mode {
            border: 4px solid #888;
            border-image: none;
        }
    </style>
</head>

<body>

    <!-- UI Component Example -->
    <div class="ui-frame" id="testFrame">
        <!-- Masked Blur Layer -->
        <div class="ui-blur-zone" id="blurLayer"></div>

        <!-- Actual UI Elements -->
        <div class="ui-inner">
            <h2>Inventory</h2>
            <p>Item: <strong>Lazor Pickaxe</strong></p>
            <p>Durability: 9000/9001</p>
            <p><i>"A shiny tool for a shiny person."</i></p>
            <button class="btn">Close</button>
        </div>
    </div>

    <script>
        // --- Dragging Logic ---
        const uiFrame = document.getElementById('testFrame');
        let isDragging = false;
        let dragOffsetX = 0;
        let dragOffsetY = 0;

        uiFrame.addEventListener('mousedown', (e) => {
            // Don't drag if clicking buttons
            if (e.target.tagName === 'BUTTON') return;

            isDragging = true;
            // Calculate offset from the element's top-left
            const rect = uiFrame.getBoundingClientRect();
            dragOffsetX = e.clientX - rect.left;
            dragOffsetY = e.clientY - rect.top;

            // Remove transform centering once we start moving manually
            uiFrame.style.transform = 'none';
            uiFrame.style.left = rect.left + 'px';
            uiFrame.style.top = rect.top + 'px';
            uiFrame.style.bottom = 'auto';
            uiFrame.style.right = 'auto';
        });

        window.addEventListener('mousemove', (e) => {
            if (!isDragging) return;
            uiFrame.style.left = (e.clientX - dragOffsetX) + 'px';
            uiFrame.style.top = (e.clientY - dragOffsetY) + 'px';
        });

        window.addEventListener('mouseup', () => {
            isDragging = false;
        });

        // --- Red Key Processor ---
        // "Red Key" Processor + Mask Generator
        const frameUrl = 'Assets/Image/frame.png';

        const img = new Image();
        img.crossOrigin = "Anonymous";

        img.onload = function () {
            const w = img.width;
            const h = img.height;

            // Canvas 1: The Visual Frame (Red Removed)
            const canvasFrame = document.createElement('canvas');
            canvasFrame.width = w; canvasFrame.height = h;
            const ctxFrame = canvasFrame.getContext('2d');
            ctxFrame.drawImage(img, 0, 0);

            // Canvas 2: The Blur Mask (Only Red Exists)
            const canvasMask = document.createElement('canvas');
            canvasMask.width = w; canvasMask.height = h;
            const ctxMask = canvasMask.getContext('2d');
            // Init with transparent
            const maskData = ctxMask.createImageData(w, h);
            const mData = maskData.data;

            try {
                // Get pixel data from the drawn image
                const frameData = ctxFrame.getImageData(0, 0, w, h);
                const fData = frameData.data;

                let hasRed = false;

                for (let i = 0; i < fData.length; i += 4) {
                    const r = fData[i];
                    const g = fData[i + 1];
                    const b = fData[i + 2];
                    const a = fData[i + 3];

                    if (r > 240 && g < 10 && b < 10 && a > 0) {
                        // FOUND RED PIXEL
                        hasRed = true;

                        // Frame: Make Transparent
                        fData[i + 3] = 0;

                        // Mask: Make Opaque (Black is fine, alpha matters)
                        mData[i] = 0; mData[i + 1] = 0; mData[i + 2] = 0; // Black
                        mData[i + 3] = 255; // Opaque
                    } else {
                        // NORMAL FRAME PIXEL (or transparent)

                        // Frame: Keep as is

                        // Mask: Make Transparent
                        mData[i + 3] = 0;
                    }
                }

                if (hasRed) {
                    console.log("Applying Red Key Shader...");

                    // 1. Apply modified frame pixels
                    ctxFrame.putImageData(frameData, 0, 0);
                    const finalFrameUrl = canvasFrame.toDataURL();

                    // 2. Apply generated mask pixels
                    ctxMask.putImageData(maskData, 0, 0);
                    const finalMaskUrl = canvasMask.toDataURL();

                    // Apply CSS
                    const frameEl = document.getElementById('testFrame');
                    const blurEl = document.getElementById('blurLayer');

                    // Visual Frame
                    frameEl.style.borderImageSource = `url('${finalFrameUrl}')`;
                    frameEl.style.borderImageSlice = '16 fill'; // 16px Slices
                    frameEl.classList.remove('placeholder-mode');

                    // Blur Mask
                    blurEl.style.webkitMaskBoxImageSource = `url('${finalMaskUrl}')`;
                    blurEl.style.webkitMaskBoxImageSlice = '16 fill';

                    blurEl.style.maskBorderSource = `url('${finalMaskUrl}')`;
                    blurEl.style.maskBorderSlice = '16 fill';

                } else {
                    console.warn("No red mask found in image.");
                    document.getElementById('testFrame').style.borderImageSource = `url('${frameUrl}')`;
                }
            } catch (e) {
                console.error("CORS Error / Canvas Taint:", e);
                // Fallback: Just show the raw image
                const frameEl = document.getElementById('testFrame');
                frameEl.style.borderImageSource = `url('${frameUrl}')`;
                frameEl.classList.remove('placeholder-mode');

                // Add a warning message on screen
                const warn = document.createElement('div');
                warn.style.position = 'fixed'; warn.style.top = '0'; warn.style.left = '0';
                warn.style.background = 'red'; warn.style.color = 'white'; warn.style.padding = '5px';
                warn.innerText = "Security Error: Run via Live Server to enable Red Key Shader!";
                document.body.appendChild(warn);
            }
        };

        img.onerror = function () {
            console.warn("frame.png not found.");
            document.getElementById('testFrame').classList.add('placeholder-mode');
        };

        img.src = frameUrl;
    </script>

</body>

</html>