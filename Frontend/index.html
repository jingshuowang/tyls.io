<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8">
    <title>tyls.io</title>
    <link rel="icon" href="data:,">
    <style>
        @font-face {
            font-family: 'Minecraft';
            src: url('../Assets/Font/pixel.ttf') format('truetype');
        }

        body {
            margin: 0;
            overflow: hidden;
            /* Hide default/CSS cursor for Software Cursor */
            background: #000;
        }

        canvas {
            display: block;
            image-rendering: pixelated;
            image-rendering: crisp-edges;
            image-rendering: pixelated;
            image-rendering: crisp-edges;
            /* Use hardware accelerated CSS cursor */
            cursor: url('../Assets/Image/cursor.png') 16 16, auto;
        }

        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            color: #ffffff;
            font-family: 'Minecraft', monospace;
            font-size: 16px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
            pointer-events: none;
            z-index: 100;
        }

        #activity {
            position: absolute;
            top: 10px;
            right: 10px;
            color: #ffffff;
            font-family: 'Minecraft', monospace;
            font-size: 20px;
            font-weight: bold;
            text-shadow: 0 0 5px rgba(255, 255, 255, 0.5);
            opacity: 0;
            transition: opacity 0.2s;
            pointer-events: none;
        }

        #activity.flash {
            opacity: 1;
        }

        /* Custom HTML Cursor */
        /* Custom HTML Cursor */
        /* Custom HTML Cursor REMOVED for Performance */
        /*
        #follower-element {
            width: 32px;
            height: 32px;
            background-image: url('../Assets/Image/cursor.png');
            background-size: contain;
            background-repeat: no-repeat;
            position: fixed;
            transform: translate(-50%, -50%);
            pointer-events: none;
            z-index: 10000;
            image-rendering: pixelated;
        }
        */

        /* Force Hide System Cursor Globally */
        * {
            /* Let elements inherit the custom cursor defined on canvas/body */
            /* cursor: none !important; */
            cursor: inherit;
        }
    </style>
</head>

<body>
    <div id="info"></div>
    <div id="activity"></div>
    <div id="activity"></div>
    <!-- <div id="follower-element"></div> -->

    <!-- Loading Overlay -->
    <div id="loading-overlay"
        style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: #000; z-index: 99999; display: flex; align-items: center; justify-content: center; color: white; font-family: 'Minecraft', monospace; font-size: 24px; transition: opacity 1s;">
        Loading World...
    </div>

    <!-- ===== INVENTORY SYSTEM (Inline, No External UI) ===== -->
    <style>
        #inv-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.6);
            z-index: 9000;
            pointer-events: auto;
        }

        #inv-panel {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: #2a2a2a;
            border: 4px solid #555;
            padding: 12px;
            image-rendering: pixelated;
            font-family: monospace;
            color: #ccc;
        }

        #inv-panel h3 {
            margin: 0 0 6px 0;
            font-size: 14px;
            color: #aaa;
            text-align: center;
        }

        .inv-grid {
            display: grid;
            gap: 2px;
        }

        .inv-backpack {
            grid-template-columns: repeat(10, 40px);
        }

        .inv-hotbar-grid {
            grid-template-columns: repeat(4, 40px);
            justify-content: center;
        }

        .inv-slot {
            width: 40px;
            height: 40px;
            background: #1a1a1a;
            border: 2px solid #444;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            cursor: none;
            user-select: none;
        }

        .inv-slot:hover {
            border-color: #888;
        }

        .inv-slot.active {
            border-color: #ffd700;
            box-shadow: 0 0 6px #ffd700;
        }

        .inv-slot .block-icon {
            width: 28px;
            height: 28px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .inv-slot .count {
            position: absolute;
            bottom: 1px;
            right: 3px;
            font-size: 10px;
            color: #fff;
            text-shadow: 1px 1px 0 #000;
        }

        .inv-separator {
            height: 2px;
            background: #555;
            margin: 8px 0;
        }

        /* Floating held item */
        #inv-held {
            position: fixed;
            width: 28px;
            height: 28px;
            pointer-events: none;
            z-index: 9999;
            display: none;
            border: 1px solid rgba(255, 255, 255, 0.3);
            transform: translate(-50%, -50%);
        }

        /* Bottom hotbar (always visible) */
        #hotbar-bar {
            position: fixed;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 2px;
            z-index: 8000;
            pointer-events: none;
        }

        #hotbar-bar .hb-slot {
            width: 44px;
            height: 44px;
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid #555;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
        }

        #hotbar-bar .hb-slot.active {
            border-color: #ffd700;
        }

        #hotbar-bar .hb-slot .block-icon {
            width: 32px;
            height: 32px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        #hotbar-bar .hb-slot .count {
            position: absolute;
            bottom: 1px;
            right: 3px;
            font-size: 10px;
            color: #fff;
            text-shadow: 1px 1px 0 #000;
        }

        #hotbar-bar .hb-slot .slot-num {
            position: absolute;
            top: 1px;
            left: 3px;
            font-size: 9px;
            color: #888;
            font-family: monospace;
        }
    </style>

    <!-- Inventory Overlay (hidden, toggle with E) -->
    <div id="inv-overlay">
        <div id="inv-panel">
            <h3>Backpack</h3>
            <div class="inv-grid inv-backpack" id="inv-backpack"></div>
            <div class="inv-separator"></div>
            <h3>Hotbar</h3>
            <div class="inv-grid inv-hotbar-grid" id="inv-hotbar"></div>
        </div>
    </div>
    <!-- Floating held item -->
    <div id="inv-held"></div>
    <!-- Always-visible hotbar at bottom -->
    <div id="hotbar-bar" id="hotbar-display"></div>

    <script>
        // ===== INVENTORY LOGIC =====
        (function () {
            const BLOCK_COLORS = {
                0: '#1E90FF', // Water
                1: '#8B4513', // Dirt
                2: '#228B22', // Grass
                3: '#F4A460', // Sand
            };
            const BLOCK_NAMES = { 0: 'Water', 1: 'Dirt', 2: 'Grass', 3: 'Sand' };

            // Inventory data
            const hotbar = [
                { id: 0, count: 99 }, // Water
                { id: 1, count: 99 }, // Dirt
                { id: 2, count: 99 }, // Grass
                { id: 3, count: 99 }, // Sand
            ];
            const backpack = new Array(30).fill(null);

            let activeSlot = 1; // Which hotbar slot is selected (0-3), default Dirt
            let heldItem = null; // Item being moved with cursor
            let invOpen = false;

            // Expose globally
            window.INV = {
                hotbar, backpack,
                getActiveSlot: () => activeSlot,
                getActiveBlock: () => hotbar[activeSlot] ? hotbar[activeSlot].id : 1,
                isOpen: () => invOpen,
            };

            // --- Rendering ---
            function makeBlockDiv(item) {
                if (!item) return '';
                const color = BLOCK_COLORS[item.id] || '#666';
                let html = `<div class="block-icon" style="background:${color};" title="${BLOCK_NAMES[item.id] || '?'}"></div>`;
                if (item.count > 1) html += `<span class="count">${item.count}</span>`;
                return html;
            }

            function renderInvPanel() {
                // Backpack
                const bp = document.getElementById('inv-backpack');
                if (!bp) return;
                bp.innerHTML = '';
                for (let i = 0; i < 30; i++) {
                    const slot = document.createElement('div');
                    slot.className = 'inv-slot';
                    slot.dataset.container = 'backpack';
                    slot.dataset.index = i;
                    slot.innerHTML = makeBlockDiv(backpack[i]);
                    bp.appendChild(slot);
                }
                // Hotbar (in panel)
                const hb = document.getElementById('inv-hotbar');
                if (!hb) return;
                hb.innerHTML = '';
                for (let i = 0; i < 4; i++) {
                    const slot = document.createElement('div');
                    slot.className = 'inv-slot' + (i === activeSlot ? ' active' : '');
                    slot.dataset.container = 'hotbar';
                    slot.dataset.index = i;
                    slot.innerHTML = makeBlockDiv(hotbar[i]);
                    hb.appendChild(slot);
                }
            }

            function renderHotbarBar() {
                const bar = document.getElementById('hotbar-bar');
                if (!bar) return;
                bar.innerHTML = '';
                for (let i = 0; i < 4; i++) {
                    const slot = document.createElement('div');
                    slot.className = 'hb-slot' + (i === activeSlot ? ' active' : '');
                    slot.innerHTML = `<span class="slot-num">${i + 1}</span>` + makeBlockDiv(hotbar[i]);
                    bar.appendChild(slot);
                }
            }

            function renderHeld() {
                const el = document.getElementById('inv-held');
                if (!el) return;
                if (heldItem) {
                    el.style.display = 'block';
                    el.style.background = BLOCK_COLORS[heldItem.id] || '#666';
                } else {
                    el.style.display = 'none';
                }
            }

            function renderAll() {
                renderInvPanel();
                renderHotbarBar();
                renderHeld();
                // Sync active block for placement
                window.selectedBlock = window.INV.getActiveBlock();
            }

            // --- Interaction ---
            function getSlotAt(e) {
                const el = e.target.closest('.inv-slot');
                if (!el) return null;
                return { container: el.dataset.container, index: parseInt(el.dataset.index) };
            }

            function getArr(container) {
                return container === 'hotbar' ? hotbar : backpack;
            }

            function otherContainer(container) {
                return container === 'hotbar' ? 'backpack' : 'hotbar';
            }

            function firstEmptyIdx(arr) {
                for (let i = 0; i < arr.length; i++) {
                    if (!arr[i]) return i;
                }
                return -1;
            }

            // Left click: pick up / put down
            document.addEventListener('mousedown', (e) => {
                if (!invOpen) return;
                const overlay = document.getElementById('inv-overlay');
                if (!overlay || !overlay.contains(e.target)) return;

                const slotInfo = getSlotAt(e);
                if (!slotInfo) return;

                e.preventDefault();
                e.stopPropagation();

                const arr = getArr(slotInfo.container);
                const idx = slotInfo.index;

                if (e.button === 0) {
                    // Left click
                    if (heldItem) {
                        // Place held item
                        if (arr[idx]) {
                            // Swap
                            const tmp = arr[idx];
                            arr[idx] = { ...heldItem };
                            heldItem = tmp;
                        } else {
                            arr[idx] = { ...heldItem };
                            heldItem = null;
                        }
                    } else {
                        // Pick up
                        if (arr[idx]) {
                            heldItem = { ...arr[idx] };
                            arr[idx] = null;
                        }
                    }
                    renderAll();
                } else if (e.button === 2) {
                    // Right click: quick transfer to opposite container
                    if (arr[idx]) {
                        const otherArr = getArr(otherContainer(slotInfo.container));
                        const emptyIdx = firstEmptyIdx(otherArr);
                        if (emptyIdx !== -1) {
                            otherArr[emptyIdx] = { ...arr[idx] };
                            arr[idx] = null;
                            renderAll();
                        }
                    }
                }
            }, true);

            // Track held item with cursor
            document.addEventListener('mousemove', (e) => {
                if (!heldItem) return;
                const el = document.getElementById('inv-held');
                if (el) {
                    el.style.left = e.clientX + 'px';
                    el.style.top = e.clientY + 'px';
                }
            });

            // Prevent context menu on inventory
            document.addEventListener('contextmenu', (e) => {
                if (invOpen) {
                    const overlay = document.getElementById('inv-overlay');
                    if (overlay && overlay.contains(e.target)) {
                        e.preventDefault();
                    }
                }
            });

            // Toggle inventory with E
            window.addEventListener('keydown', (e) => {
                if (e.key.toLowerCase() === 'e') {
                    invOpen = !invOpen;
                    const overlay = document.getElementById('inv-overlay');
                    if (overlay) overlay.style.display = invOpen ? 'block' : 'none';
                    // Drop held item back if closing
                    if (!invOpen && heldItem) {
                        // Try to put back in backpack
                        const idx = firstEmptyIdx(backpack);
                        if (idx !== -1) backpack[idx] = heldItem;
                        heldItem = null;
                    }
                    renderAll();
                }

                // Hotbar selection: 1-4
                if (e.key >= '1' && e.key <= '4') {
                    activeSlot = parseInt(e.key) - 1;
                    window.selectedBlock = window.INV.getActiveBlock();
                    // renderAll(); // Removed as render is continuous
                }
            });

            // Initial render
            renderAll();
        })();
    </script>

    <!-- Save Button -->




    <!-- Loading Screen Removed per User Request -->

    <script>
        window.onerror = function (msg, url, line, col, error) {
            const div = document.createElement('div');
            div.style.position = 'fixed';
            div.style.top = '50%';
            div.style.left = '50%';
            div.style.transform = 'translate(-50%, -50%)';
            div.style.background = 'rgba(255,0,0,0.8)';
            div.style.color = 'white';
            div.style.padding = '20px';
            div.style.border = '2px solid white';
            div.style.zIndex = '99999';
            div.style.fontFamily = 'monospace';
            div.innerText = `CRITICAL ERROR:\n${msg}\nLine: ${line}`;
            document.body.appendChild(div);
            return false;
        };
    </script>

    <script src="https://cdn.jsdelivr.net/npm/pixi.js@8.5.2/dist/pixi.min.js"></script>

    <!-- UI System Removed -->
    <script>
        // Initialize empty data structures to prevent errors
        window.inventoryData = [];
        window.hotbarData = [];
    </script>

    <!-- UI System Removed (Per User Request) -->
    <!-- Variables.js is now inlined in the next script block -->
    <script>
        // --- INLINED VARIABLES (Formerly variables.js) ---
        // Game Constants
        const TILE_SIZE = 16;
        const CHUNK_SIZE = 16;
        // SERVER_URL Removed (WebSockets Only)

        // Configuration (Overridden by config.json)
        let config = {
            playerSpeed: 60, // Lowered from 200 -> 60 (Slower, more controlled)
            defaultZoom: 3.0,
            minZoom: 0.25,
            maxZoom: 10,
            chunkSize: 16,
            renderDistance: 5,
            lodThreshold: 0.8,
            maxChunksPerFrame: 10
        };

        // Game State
        const chunks = new Map();
        const chunkContainers = new Map();
        const dirtyChunks = new Set();
        const pendingChunks = new Set();
        const modifiedChunks = new Set(); // Track chunks modified by player for saving
        let chunksRendered = 0;

        // Entitiessd
        const camera = { x: 0, y: 0, zoom: 3.0, freelook: false };
        const player = { x: 128, y: 128, width: 16, height: 16, speed: 60 }; // Synced with config
        const mouse = { x: 0, y: 0, left: false, right: false, lastX: undefined, lastY: undefined };

        // Interaction
        let isAltPressed = false;
        let showGrid = true;
        let hoveredTileX = null;
        let hoveredTileY = null;
        let selectSprite = null;
        window.selectedBlock = 1; // Default: Dirt (1=Water, 2=Dirt, 3=Grass, 4=Sand mapped to IDs 0-3)

        // Input
        const keys = {};
        let pressedKeys = new Set();
        const globalTextureCache = new Map();

        // Globals
        let app, world, dirtLayer, grassLayer, renderChunk = null, fetchChunkViaWorker = null;
        let db = null; // Database instance

        // Input Handler (Renamed from handleInput)
        function hi(delta) {
            const speed = player.speed * delta / 60;
            let vx = 0;
            let vy = 0;

            if (keys['w'] || keys['W'] || keys['ArrowUp']) vy -= 1;
            if (keys['s'] || keys['S'] || keys['ArrowDown']) vy += 1;
            if (keys['a'] || keys['A'] || keys['ArrowLeft']) vx -= 1;
            if (keys['d'] || keys['D'] || keys['ArrowRight']) vx += 1;

            // Normalize diagonal
            if (vx !== 0 && vy !== 0) {
                const len = Math.sqrt(vx * vx + vy * vy);
                vx /= len;
                vy /= len;
            }

            // Apply movement
            if (vx !== 0 || vy !== 0) {
                player.x += vx * speed;
                player.y += vy * speed;
                // Center camera on player
                // camera.x = player.x - (app.screen.width / 2) / camera.zoom;
                // camera.y = player.y - (app.screen.height / 2) / camera.zoom;
            }
        }

        // Activity Indicator Logic
        function updateActivity() {
            const activity = document.getElementById('activity');
            if (pressedKeys.size === 0) {
                activity.classList.remove('flash');
            } else {
                const keyList = Array.from(pressedKeys).join(' + ');
                activity.textContent = keyList;
                // if (isAltPressed) activity.textContent += " (FREELOOK)"; // Removed user request
                activity.classList.add('flash');
            }
        }

        // Key Listeners
        window.addEventListener('keydown', (e) => {
            // ALWAYS prevent default for game keys
            if (["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight", " ", "Alt"].indexOf(e.key) > -1) {
                e.preventDefault();
            }

            if (e.key === 'Alt') {
                if (!e.repeat) { // Toggle on single press
                    isAltPressed = !isAltPressed;
                    if (typeof camera !== 'undefined') camera.freelook = isAltPressed;

                    // Update UI immediately
                    updateActivity();
                }
            }

            if (e.key.toLowerCase() === 'g') {
                window.showGrid = !window.showGrid;
            }

            // Block Selection: 1-4 handled by inventory system (see INV script above)

            if (keys[e.key]) return; // distinct press check
            keys[e.key] = true;

            // Track pressed keys for UI
            let keyName = e.key;
            if (keyName === ' ') keyName = 'Space';
            if (keyName.length === 1) keyName = keyName.toUpperCase();
            pressedKeys.add(keyName);
            updateActivity();
        });

        window.addEventListener('keyup', (e) => {
            keys[e.key] = false;

            // Alt Key Toggle Logic moved to keydown (removed hold behavior)
            if (e.key === 'Alt') {
                e.preventDefault();
                // do nothing on keyup
            }

            // Remove from UI
            let keyName = e.key;
            if (keyName === ' ') keyName = 'Space';
            if (keyName.length === 1) keyName = keyName.toUpperCase();
            pressedKeys.delete(keyName);
            updateActivity();
        });
    </script>
    <script>
        // Wait for PixiJS to load
        window.addEventListener('load', async () => {
            // --- DB REMOVED (User Request) ---
            // Settings
            // Settings (Loaded from variables.js)



            // Settings
            // Settings (Loaded from variables.js)



            // Global PixiJS Settings for Pixel Art
            PIXI.TextureSource.defaultOptions.scaleMode = 'nearest';

            // PixiJS App (v8 requires await)
            // PixiJS App (using global 'app' from variables.js)
            // Dual Grid Mapping from articles.md
            // Key: 4-bit integer (TL, TR, BL, BR)
            // Value: Image Index (0-15)
            const DG_MAP = [
                12, // 0000 -> Image 12
                13, // 0001 -> Image 13
                0,  // 0010 -> Image 0
                3,  // 0011 -> Image 3
                8,  // 0100 -> Image 8
                1,  // 0101 -> Image 1
                14, // 0110 -> Image 14
                5,  // 0111 -> Image 5
                15, // 1000 -> Image 15
                4,  // 1001 -> Image 4
                11, // 1010 -> Image 11
                2,  // 1011 -> Image 2
                9,  // 1100 -> Image 9
                10, // 1101 -> Image 10
                7,  // 1110 -> Image 7
                6   // 1111 -> Image 11
            ];

            function getDgIdx(wx, wy, typeId) {
                // Check 4 corners: TL, TR, BL, BR
                // wx, wy is the top-left coordinate of the dual grid tile
                // which corresponds to the generic world grid coordinates.

                const tl = getTileSafe(wx, wy) === typeId ? 1 : 0;
                const tr = getTileSafe(wx + 1, wy) === typeId ? 1 : 0;
                const bl = getTileSafe(wx, wy + 1) === typeId ? 1 : 0;
                const br = getTileSafe(wx + 1, wy + 1) === typeId ? 1 : 0;

                const key = (tl << 3) | (tr << 2) | (bl << 1) | br;
                return DG_MAP[key];
            }

            app = new PIXI.Application();
            await app.init({
                width: window.innerWidth,
                height: window.innerHeight,
                backgroundColor: 0xFFFFFF, // User Request: White Background
                backgroundAlpha: 1, // Opaque
                antialias: false,
                roundPixels: true,  // Pixel-perfect rendering
                preference: 'maximum-performance', // Hint to browser
                powerPreference: 'high-performance'
            });
            // Cap FPS to 60 to prevent coil whine and "infinite" FPS lag
            // User request: "fps is getting limited its capping at like 50" -> Uncap it
            app.ticker.maxFPS = 0;
            document.body.appendChild(app.canvas);

            // Resize canvas to fill screen (fixes black bar at top)
            function resizeCanvas() {
                app.renderer.resize(window.innerWidth, window.innerHeight);
            }
            window.addEventListener('resize', resizeCanvas);
            resizeCanvas(); // Call once to ensure proper size

            // Pixel-perfect (v8 compatible)
            // FPS Uncapped (User requested)



            // World container
            // World container (global 'world')
            world = new PIXI.Container();
            world.sortableChildren = true; // Enable z-index sorting for world (tiles/players)
            app.stage.addChild(world);

            // UI Container (for crosshair, etc.)
            const uiContainer = new PIXI.Container();
            uiContainer.zIndex = 1000;
            app.stage.addChild(uiContainer);

            app.stage.sortableChildren = true; // Enable z-index sorting for stage

            // Layers for Z-sorting (global 'dirtLayer', 'grassLayer')
            dirtLayer = new PIXI.Container();
            grassLayer = new PIXI.Container();
            window.playerGraphics = new PIXI.Graphics(); // Player character

            // Explicit Rendering Order (Z-Index)
            dirtLayer.zIndex = 0;   // Bottom
            grassLayer.zIndex = 1;  // Mid
            window.playerGraphics.zIndex = 10; // Top

            world.addChild(dirtLayer);
            world.addChild(grassLayer);
            world.addChild(window.playerGraphics);
            world.addChild(grassLayer);


            // Track hovered tile position (Global from variables.js)
            // let hoveredTileX = null;
            // let hoveredTileY = null;

            // Mouse tracking


            // NOTE: selectSprite and event handlers moved inside Promise.all().then() to ensure texture is loaded


            // Chunk-based world data
            // RENDER_DISTANCE now comes from config.renderDistance
            // Chunk-based world data (Global from variables.js)
            // const chunks = new Map(); 
            // const chunkContainers = new Map();
            // const dirtyChunks = new Set();
            // let chunksRendered = 0;

            // renderChunk function reference (defined below, declared in variables.js)
            // let renderChunk = null; (Global)

            // Simple Perlin-like noise REMOVED (Legacy, Server handles generation now)

            // Chunk Management (Client Cache)
            // Data is fetched from Server, stored here
            // chunks map is global.


            // Track pending requests (Global from variables.js)
            // const pendingChunks = new Set();

            // Request Chunk via WebSocket
            function requestChunk(cx, cy) {
                const key = `${cx},${cy}`;
                if (chunks.has(key) || pendingChunks.has(key)) return;

                pendingChunks.add(key);
                if (window.socket && window.socket.readyState === WebSocket.OPEN) {
                    window.socket.send(JSON.stringify({ type: 'getChunk', key: key }));
                }
            }

            // Legacy fetchChunk removed
            async function fetchChunk(cx, cy) {
                requestChunk(cx, cy);
            }

            function getChunk(cx, cy) {
                const key = `${cx},${cy}`;
                if (chunks.has(key)) {
                    return chunks.get(key);
                }

                // WASM DB Lookups REMOVED
                // if (db) { ... }

                // Fallback / Loading placeholder
                const empty = [];
                for (let i = 0; i < CHUNK_SIZE; i++) empty[i] = new Array(CHUNK_SIZE).fill(0);
                return empty;
            }

            function getTile(x, y) {
                const cx = Math.floor(x / CHUNK_SIZE);
                const cy = Math.floor(y / CHUNK_SIZE);
                const tx = ((x % CHUNK_SIZE) + CHUNK_SIZE) % CHUNK_SIZE;
                const ty = ((y % CHUNK_SIZE) + CHUNK_SIZE) % CHUNK_SIZE;
                const chunk = getChunk(cx, cy);
                return chunk[ty][tx];
            }

            // Helper: Get Tile without forcing chunk generation (prevents render lag)
            // Helper: Get Tile safe (Synchronous WASM Access)
            function getTileSafe(x, y) {
                const cx = Math.floor(x / CHUNK_SIZE);
                const cy = Math.floor(y / CHUNK_SIZE);

                // WASM: getChunk is instant (checks Cache -> DB -> Empty)
                // This ensures neighbors are loaded for correct edge connections (fixing diagonal gaps)
                const chunk = getChunk(cx, cy);

                const tx = ((x % CHUNK_SIZE) + CHUNK_SIZE) % CHUNK_SIZE;
                const ty = ((y % CHUNK_SIZE) + CHUNK_SIZE) % CHUNK_SIZE;
                return chunk[ty][tx];
            }

            function setTile(x, y, value) {
                const cx = Math.floor(x / CHUNK_SIZE);
                const cy = Math.floor(y / CHUNK_SIZE);
                const tx = ((x % CHUNK_SIZE) + CHUNK_SIZE) % CHUNK_SIZE;
                const ty = ((y % CHUNK_SIZE) + CHUNK_SIZE) % CHUNK_SIZE;
                const chunk = getChunk(cx, cy);
                if (chunk[ty][tx] === value) return;
                // WEBSOCKET UPDATE: Send change to server immediately
                if (window.socket && window.socket.readyState === WebSocket.OPEN) {
                    window.socket.send(JSON.stringify({
                        type: 'setBlock',
                        id: myId, // Send ID to ignore self-echo
                        x: x,
                        y: y,
                        val: value
                    }));
                } else {
                    // Fallback if offline? Just update local for now.
                    // But user said "websocket is for data", so we assume online.
                }

                chunk[ty][tx] = value;

                // Mark chunk for re-render
                const key = `${cx},${cy}`;
                dirtyChunks.add(key);

                // AUTO-TILING: Dirty neighbors if on edge
                if (tx === 0) dirtyChunks.add(`${cx - 1},${cy}`);
                if (tx === CHUNK_SIZE - 1) dirtyChunks.add(`${cx + 1},${cy}`);
                if (ty === 0) dirtyChunks.add(`${cx},${cy - 1}`);
                if (ty === CHUNK_SIZE - 1) dirtyChunks.add(`${cx},${cy + 1}`);
            }

            // Global Texture Cache (from variables.js)
            // Functions moved to initGame scope or replaced by Dual Grid logic


            // Load config from tweaker (config.json) and initialize game
            // config defined in variables.js

            // Try to load config.json, then initialize game
            fetch('../config.json')
                .then(res => res.json())
                .then(data => {
                    config = { ...config, ...data };
                    // Config loaded silently
                })
                .catch(() => {
                    // Using default config silently
                })
                .finally(() => {
                    initGame();
                });

            function initGame() {
                // UI Removed per user request
                // Camera, Player, Mouse defined in variables.js

                // DEFAULT SPAWN (0,0) - Overridden by Persistence in simpleStart()
                player.x = 0;
                player.y = 0;

                // Snap camera to player immediately
                camera.x = player.x;
                camera.y = player.y;

                // Resetting critical values if needed
                camera.zoom = config.defaultZoom;
                player.speed = config.playerSpeed;

                // Track hovered tile (Global)
                hoveredTileX = null;
                hoveredTileY = null;

                // Game loop - runs every frame
                app.ticker.add((delta) => {
                    // Update select sprite position every frame
                    if (selectSprite && hoveredTileX !== null && hoveredTileY !== null) {
                        selectSprite.x = hoveredTileX * TILE_SIZE;
                        selectSprite.y = hoveredTileY * TILE_SIZE;
                    }
                });

                // Consolidated mousemove listener - mouse tracking moved to global event
                // and logic moved to main game loop to ensure updates when camera moves

                // Mouse tracking handled globally below
                // Context menu prevention
                app.canvas.addEventListener('contextmenu', (e) => e.preventDefault());



                // Mouse tracking handled globally via specific listeners for logic/visuals

                // SCROLL WHEEL (Hotbar Cycle)
                window.addEventListener('wheel', (e) => {
                    if (!window.UI || !window.UI.setActiveHotbar) return;
                    // Cycle hotbar slots
                    const current = window.UI.activeHotbarSlot || 0;
                    const next = (e.deltaY > 0) ? (current === 0 ? 1 : 0) : (current === 1 ? 0 : 1);
                    window.UI.setActiveHotbar(next);
                });

                // VISUAL INDICATORS (LMB/RMB)
                window.addEventListener('mousedown', (e) => {
                    if (e.button === 0) { // LMB
                        mouse.left = true;
                        const el = document.getElementById('lmb-indicator');
                        if (el) el.style.opacity = '1.0';
                        if (el) el.style.boxShadow = '0 0 10px #00f';
                    }
                    if (e.button === 2) { // RMB
                        mouse.right = true;
                        const el = document.getElementById('rmb-indicator');
                        if (el) el.style.opacity = '1.0';
                        if (el) el.style.boxShadow = '0 0 10px #f00';
                    }
                });

                window.addEventListener('mouseup', (e) => {
                    if (e.button === 0) { // LMB
                        mouse.left = false;
                        const el = document.getElementById('lmb-indicator');
                        if (el) el.style.opacity = '0.2';
                        if (el) el.style.boxShadow = 'none';
                    }
                    if (e.button === 2) { // RMB
                        mouse.right = false;
                        const el = document.getElementById('rmb-indicator');
                        if (el) el.style.opacity = '0.2';
                        if (el) el.style.boxShadow = 'none';
                    }
                });
                let isDragging = false;
                let dragStartX = 0;
                let dragStartY = 0;
                let cameraStartX = 0;
                let cameraStartY = 0;

                // Prevent browser context menu so RMB reaches game code
                app.canvas.addEventListener('contextmenu', (e) => e.preventDefault());

                app.canvas.addEventListener('mousedown', (e) => {
                    if (isAltPressed && e.button === 0) {
                        isDragging = true;
                        dragStartX = e.clientX;
                        dragStartY = e.clientY;
                        cameraStartX = camera.x;
                        cameraStartY = camera.y;
                        // app.canvas.style.cursor = 'grabbing'; // Removed
                    }
                }, true); // Use capture to run before other handlers

                app.canvas.addEventListener('mousemove', (e) => {
                    if (isDragging && isAltPressed) {
                        const dx = (e.clientX - dragStartX) / camera.zoom;
                        const dy = (e.clientY - dragStartY) / camera.zoom;
                        camera.x = cameraStartX - dx;
                        camera.y = cameraStartY - dy;
                    }
                });

                app.canvas.addEventListener('mouseup', () => {
                    if (isDragging) {
                        isDragging = false;
                        // app.canvas.style.cursor = isAltPressed ? 'grab' : "url('Assets/Image/cursor.png'), auto"; // Removed
                    }
                });

                // Exponential zoom - ONLY in freelook mode
                // Exponential zoom - ONLY in freelook mode (Mouse-Centered)
                app.canvas.addEventListener('wheel', (e) => {
                    // Zoom works in all modes (User request)
                    // if (!isAltPressed) return; 
                    e.preventDefault();

                    const oldZoom = camera.zoom;
                    const zoomFactor = e.deltaY < 0 ? 1.25 : 0.8;
                    const newZoom = Math.max(config.minZoom, Math.min(config.maxZoom, oldZoom * zoomFactor));

                    // Mouse-centered zoom logic REMOVED -> Screen Center Zoom
                    if (newZoom !== oldZoom) {
                        camera.zoom = newZoom;
                    }
                });

                // Zoom Lock in Normal Mode (tick check)
                app.ticker.add(() => {
                    if (!isAltPressed) {
                        if (Math.abs(camera.zoom - 2.0) > 0.01) {
                            camera.zoom = 2.0;
                        }
                    }
                });

                // Garbage Collection: INCREMENTAL (No Lag Spikes)
                // Logic moved to Ticker inside startGameLoop for smoother execution
                /*
                setInterval(() => {
                    // ... old code ...
                }, 5000);
                */

                // Generalized Dual Grid Mapping (Works for Grass, Sand, Water)
                const DUAL_GRID_MAP = {
                    '0000': 12, // The Void
                    '1000': 15, // Inner Corner - Top Left
                    '0100': 1,  // Inner Corner - Top Right (User Fixed: 8->1)
                    '0010': 0,  // Inner Corner - Bottom Left
                    '0001': 15, // Inner Corner - Bottom Right (User Fixed: 13->15)

                    '1100': 9,  // Horizontal Edge - Ceiling
                    '0011': 10, // Horizontal Edge - Floor (User Fixed: 3->10)
                    '1010': 11, // Vertical Edge - Right Face
                    '0101': 1,  // Vertical Edge - Left Face
                    '0110': 14, // Diagonal - Forward Slash
                    '1001': 4,  // Diagonal - Back Slash
                    '1110': 7,  // Outer Corner - Bottom Right
                    '1101': 11, // Outer Corner - Bottom Left (User Fixed: 2->11 - Wait user said 2->11)
                    // Wait, user said "by 2 i ment 11". In my map 11 is '1010' (Vert Right).
                    // If user means the SHAPE at index 2 should use sprite 11:
                    // '1011' -> 2. So '1011' -> 11.
                    // But '1101' was 10. Let's assume user refers to the KEY 2 (Outer TR)?
                    // "image 2 (TL:1, TR:0, BL:1, BR:1) same as 8 ... by 2 i ment 11"
                    // My previous map: '1011': 2.
                    // New map: '1011': 11.

                    '1011': 11,  // Outer Corner - Top Right (User Fixed: 2->11)
                    '0111': 5,  // Outer Corner - Top Left
                    '1111': 6   // Full Solid
                };

                function getDualGridIdx(x, y, targetId) {
                    // Check 4 corners: TL, TR, BL, BR relative to the dual grid intersection
                    // "If block isn't itself then act as it is air (0), if it is then its 1"
                    const tl = getTileSafe(x, y) === targetId ? '1' : '0';
                    const tr = getTileSafe(x + 1, y) === targetId ? '1' : '0';
                    const bl = getTileSafe(x, y + 1) === targetId ? '1' : '0';
                    const br = getTileSafe(x + 1, y + 1) === targetId ? '1' : '0';

                    const key = tl + tr + bl + br;
                    return DUAL_GRID_MAP[key] !== undefined ? DUAL_GRID_MAP[key] : 6;
                }

                // Create placeholder texture when image files are missing
                function createPlaceholderTexture(color) {
                    const canvas = document.createElement('canvas');
                    canvas.width = 64; // 4x4 grid of 16x16 tiles = 16 frames
                    canvas.height = 64;
                    const ctx = canvas.getContext('2d');

                    // Fill with color
                    ctx.fillStyle = `#${color.toString(16).padStart(6, '0')}`;
                    ctx.fillRect(0, 0, 64, 64);

                    // Add debug border/checkerboard to see it's a placeholder
                    ctx.strokeStyle = 'rgba(255,255,255,0.2)';
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    for (let i = 0; i <= 4; i++) {
                        ctx.moveTo(i * 16, 0); ctx.lineTo(i * 16, 64);
                        ctx.moveTo(0, i * 16); ctx.lineTo(64, i * 16);
                    }
                    ctx.stroke();

                    return PIXI.Texture.from(canvas);
                }


                // Load function with explicit logging and Slicing
                async function loadAssets() {
                    const loadTexture = async (path, placeholderColor) => {
                        let tex;
                        try {
                            tex = await PIXI.Assets.load(path);
                            tex.source.scaleMode = 'nearest';
                            console.log(`[Assets] Loaded: ${path}`);
                        } catch (e) {
                            console.warn(`[Assets] Failed: ${path}`, e);
                            tex = createPlaceholderTexture(placeholderColor);
                        }

                        // SLICE into 16x16 frames
                        const frames = [];
                        // Check for 4x4 Grid (Dual Grid)
                        // Heuristic: Square aspect ratio AND width >= 64 (4 * TILE_SIZE)
                        const isSquare = tex.width === tex.height;
                        const isGridCompatible = tex.width >= 64;

                        let frameW = TILE_SIZE;
                        let frameH = TILE_SIZE;
                        let cols = Math.floor(tex.width / TILE_SIZE);
                        let rows = Math.floor(tex.height / TILE_SIZE);

                        if (isSquare && isGridCompatible) {
                            // Force 4x4 grid slicing for HD textures
                            cols = 4;
                            rows = 4;
                            frameW = tex.width / 4;
                            frameH = tex.height / 4;
                        }

                        if (cols === 0 || rows === 0) {
                            // Fallback
                            frames.push(new PIXI.Texture({
                                source: tex.source,
                                frame: new PIXI.Rectangle(0, 0, tex.width, tex.height)
                            }));
                        } else {
                            for (let y = 0; y < rows; y++) {
                                for (let x = 0; x < cols; x++) {
                                    frames.push(new PIXI.Texture({
                                        source: tex.source,
                                        frame: new PIXI.Rectangle(x * frameW, y * frameH, frameW, frameH)
                                    }));
                                }
                            }
                        }

                        // Dual Grid fallback: If we don't have enough frames (need 16 for indices 0-15),
                        // fill the rest with the first frame (or last) to prevent crashing/invisible tiles.
                        while (frames.length < 16) {
                            frames.push(frames[0]);
                        }

                        tex.textures = frames; // Attach for Dual Grid use in rchunks
                        return tex;
                    };

                    const [dirt, grass, water, sand, select, crosshair, tdirt, tsand] = await Promise.all([
                        loadTexture('/Assets/Image/Tile/dirt.png', 0x5d4037),
                        loadTexture('/Assets/Image/Tile/grass.png', 0x2e8b57),
                        loadTexture('/TempImage/twater.png', 0x1e90ff),
                        loadTexture('/Assets/Image/sand.png', 0xf4a460),
                        loadTexture('/Assets/Image/select.png', 0xffffff),
                        loadTexture('/Assets/Image/crosshair.png', 0xff0000),
                        loadTexture('/TempImage/tdirt.png', 0x8b4513), // Dirt Dual Grid Texture
                        loadTexture('/TempImage/tsand.png', 0xf4a460)  // Sand Dual Grid Texture
                    ]);

                    // Expose textures globally so rchunks can access them (Correct Location)
                    window.textures = {
                        dirt, grass, water, sand, select, crosshair, tdirt, tsand
                    };

                    // Assign to global texture variables
                    dirtTex = tdirt; // Use tdirt.png for Dirt (ID 1)
                    grassTex = grass;
                    waterTex = water;
                    sandTex = tsand; // Use tsand.png for Sand Dual Grid (ID 3)
                    selectTex = select;
                    crosshairTex = crosshair;


                    if (select) select.source.scaleMode = 'nearest';
                    if (crosshair) crosshair.source.scaleMode = 'nearest';

                    return { dirt, grass, water, sand, select, crosshair };
                }

                // Initialize Game
                loadAssets().then((assets) => {
                    const dirtTex = assets.dirt;
                    const grassTex = assets.grass;
                    const waterTex = assets.water;
                    const sandTex = assets.sand;
                    const selectTex = assets.select;
                    const crosshairTex = assets.crosshair;

                    // Setup Block Highlight (using loaded texture)
                    // "Select Theorem" Correction: 2-Slice Vertical Strip (Top=Normal, Bottom=Pressed)

                    const selectTexNormal = new PIXI.Texture({
                        source: selectTex.source,
                        frame: new PIXI.Rectangle(0, 0, TILE_SIZE, TILE_SIZE)
                    });

                    // Frame 2 is at x=0, y=16 (Vertical Strip)
                    const selectTexPressed = new PIXI.Texture({
                        source: selectTex.source,
                        frame: new PIXI.Rectangle(0, TILE_SIZE, TILE_SIZE, TILE_SIZE)
                    });

                    selectSprite = new PIXI.Sprite(selectTexNormal);
                    selectSprite.width = TILE_SIZE;
                    selectSprite.height = TILE_SIZE;

                    selectSprite.visible = false;
                    selectSprite.zIndex = 1000;
                    world.addChild(selectSprite);

                    // Re-attach check
                    if (!app.stage.children.includes(world)) {
                        app.stage.addChild(world);
                        console.log("World container re-attached to stage.");
                    }

                    // Setup Crosshair Sprite (REMOVED: Using HTML Follower)
                    /*
                    const crosshairSprite = new PIXI.Sprite(crosshairTex);
                    crosshairSprite.anchor.set(0.5);
                    crosshairSprite.zIndex = 9999; 
                    world.addChild(crosshairSprite);
                    */
                    // Crosshair sprite removed in favor of HTML cursor


                    // Setup Cursor: Using HTML Follower only (Performance)
                    // System cursor hidden via CSS
                    app.canvas.style.cursor = 'none';

                    let cursorSprite = null; // Removed Sprite Logic

                    // Mouse move handler - just track position
                    // Mouse move handler - Extremely Lightweight (Just updates data)
                    window.addEventListener('mousemove', (e) => {
                        mouse.x = e.clientX;
                        mouse.y = e.clientY;
                    });

                    // Synced Cursor: Merged into PixiJS Ticker (The "Engine Heartbeat")
                    // This ensures the cursor updates exactly when the game renders, removing jitter.
                    app.ticker.add(() => {
                        // 1. Cursor handling moved to CSS/HTML


                        // 2. Update World Highlight
                        if (world.scale.x !== 0) {
                            const worldX = (mouse.x - world.x) / world.scale.x;
                            const worldY = (mouse.y - world.y) / world.scale.y;

                            hoveredTileX = Math.floor(worldX / TILE_SIZE);
                            hoveredTileY = Math.floor(worldY / TILE_SIZE);

                            if (selectSprite) {
                                selectSprite.x = hoveredTileX * TILE_SIZE;
                                selectSprite.y = hoveredTileY * TILE_SIZE;
                            }
                        }
                    }, PIXI.UPDATE_PRIORITY.INTERACTION); // High priority update

                    // Mouse down - change to pressed texture & visual indicator
                    window.addEventListener('mousedown', (e) => {
                        if (e.button === 0) {
                            mouse.left = true;
                            // Visual Indicator
                            const el = document.getElementById('lmb-indicator');
                            if (el) el.style.opacity = '1.0';

                            // Change texture if selectSprite is ready
                            if (selectSprite) selectSprite.texture = selectTexPressed;
                        } else if (e.button === 2) {
                            mouse.right = true;
                            const el = document.getElementById('rmb-indicator');
                            if (el) el.style.opacity = '1.0';
                        }
                    });

                    // Mouse up - change back to normal texture & visual indicator
                    window.addEventListener('mouseup', (e) => {
                        if (e.button === 0) {
                            mouse.left = false;
                            const el = document.getElementById('lmb-indicator');
                            if (el) el.style.opacity = '0.2';

                            if (selectSprite) selectSprite.texture = selectTexNormal;
                        } else if (e.button === 2) {
                            mouse.right = false;
                            const el = document.getElementById('rmb-indicator');
                            if (el) el.style.opacity = '0.2';
                        }
                    });


                    // Calculate average colors for LOD rendering
                    function getAverageColor(texture) {
                        const canvas = document.createElement('canvas');
                        const ctx = canvas.getContext('2d');
                        canvas.width = texture.width;
                        canvas.height = texture.height;

                        // Draw texture to canvas
                        const img = texture.source.resource;
                        ctx.drawImage(img, 0, 0);

                        try {
                            // Get pixel data
                            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                            const data = imageData.data;

                            let r = 0, g = 0, b = 0, count = 0;
                            for (let i = 0; i < data.length; i += 4) {
                                // Skip transparent pixels (alpha < 128)
                                if (data[i + 3] >= 128) {
                                    r += data[i];
                                    g += data[i + 1];
                                    b += data[i + 2];
                                    count++;
                                }
                            }

                            if (count > 0) {
                                r = Math.floor(r / count);
                                g = Math.floor(g / count);
                                b = Math.floor(b / count);
                                return (r << 16) | (g << 8) | b; // Return as hex color
                            }
                        } catch (e) {
                            console.warn("LOD Tainting Error (file:// protocol): defaulting color. " + e.message);
                            return 0x888888; // Default Grey
                        }

                        return 0x888888; // Fallback
                    }

                    const avgDirtColor = getAverageColor(dirtTex);
                    const avgGrassColor = getAverageColor(grassTex);


                    // ASYNC Pre-generation (Networked)
                    // Connect to Java Server (We use WebSocket now)

                    // Hide Canvas initially

                    // Hide Canvas initially
                    app.canvas.style.opacity = '0';
                    app.canvas.style.transition = 'opacity 1s';

                    // SIMPLE LOAD STRATEGY (User Request)
                    // 1. Connect to Server
                    // 2. Spawn Randomly
                    // 3. Load Circle Radius (Render Distance)
                    // 4. Start Game Loop

                    app.canvas.style.opacity = '0'; // Fade in effect
                    app.canvas.style.transition = 'opacity 1s';

                    // NEW Loading Screen Logic
                    // simpleStart removed. Logic is now in socket.onopen

                    // Incremental GC State
                    let gcIterator = null;
                    const GC_RADIUS = config.renderDistance + 5; // Reduced from +20 to clear cache faster

                    let lastTime = performance.now();

                    // Handle Input (Restored)
                    function hi(delta) {
                        if (!player) return;
                        // Use a fixed speed multiplier or delta
                        // loop passes 1, so speed is per-tick
                        const speed = player.speed * delta;
                        let dx = 0, dy = 0;

                        if (keys['w'] || keys['arrowup']) dy -= 1;
                        if (keys['s'] || keys['arrowdown']) dy += 1;
                        if (keys['a'] || keys['arrowleft']) dx -= 1;
                        if (keys['d'] || keys['arrowright']) dx += 1;

                        if (dx !== 0 && dy !== 0) {
                            dx *= 0.7071;
                            dy *= 0.7071;
                        }

                        player.x += dx * speed;
                        player.y += dy * speed;
                    }

                    // WRAPPED Game Loop (Started after loading)
                    window.startGameLoop = function startGameLoop() {
                        let lastTime = performance.now();
                        let lastLODState = false; // Track LOD state for threshold crossing

                        app.ticker.add((ticker) => {
                            // Incremental Garbage Collection (Process 20 chunks per frame)
                            if (!gcIterator) gcIterator = chunks.keys();

                            const playerChunkX = Math.round(player.x / TILE_SIZE / CHUNK_SIZE);
                            const playerChunkY = Math.round(player.y / TILE_SIZE / CHUNK_SIZE);

                            let gcCount = 0;
                            while (gcCount < 20) {
                                const next = gcIterator.next();
                                if (next.done) {
                                    gcIterator = chunks.keys(); // Restart
                                    break;
                                }
                                const key = next.value;
                                const [cx, cy] = key.split(',').map(Number);
                                const dist = Math.max(Math.abs(cx - playerChunkX), Math.abs(cy - playerChunkY));

                                // Only delete if REALLY far (GC Radius)
                                if (dist > GC_RADIUS) {
                                    chunks.delete(key);
                                }
                                gcCount++;
                            }

                            // Time Delta
                            const time = performance.now();
                            const dt = Math.min((time - lastTime) / 1000, 0.1);
                            lastTime = time;

                            // Camera movement (WASD)
                            let moveX = 0, moveY = 0;
                            if (keys['a'] || keys['arrowleft']) moveX = -1;
                            if (keys['d'] || keys['arrowright']) moveX = 1;
                            if (keys['w'] || keys['arrowup']) moveY = -1;
                            if (keys['s'] || keys['arrowdown']) moveY = 1;

                            // Normalize diagonal movement
                            if (moveX !== 0 && moveY !== 0) {
                                moveX *= 0.707;
                                moveY *= 0.707;
                            }

                            // Move Player Sprite
                            if (player.sprite) {
                                player.sprite.x = player.x;
                                player.sprite.y = player.y;
                            }

                            // Movement logic - Uses hi(delta)
                            function hi(delta) {
                                if (!player) return;
                                // Convert Pixels Per Second to Pixels Per Frame
                                const speed = player.speed * (delta / 60);
                                let dx = 0, dy = 0;

                                if (keys['w'] || keys['arrowup']) dy -= 1;
                                if (keys['s'] || keys['arrowdown']) dy += 1;
                                if (keys['a'] || keys['arrowleft']) dx -= 1;
                                if (keys['d'] || keys['arrowright']) dx += 1;

                                if (dx !== 0 && dy !== 0) {
                                    dx *= 0.7071;
                                    dy *= 0.7071;
                                }

                                player.x += dx * speed;
                                player.y += dy * speed;
                            }

                            if (!isAltPressed) {
                                hi(1);
                            }

                            // Sync Camera to Player Position
                            // ONLY if not in Freelook Mode (Alt Pressed)
                            if (player && !isAltPressed) {
                                camera.x = player.x;
                                camera.y = player.y;
                            }
                            // World transform applied ONCE at end of frame (line ~1155)

                            // Update stats (FPS, location, zoom) with null checks
                            const fps = Math.round(app.ticker.FPS || 0);
                            const locX = player ? Math.floor(player.x) : 0;
                            const locY = player ? Math.floor(player.y) : 0;
                            const zoom = camera ? camera.zoom.toFixed(2) : '0.00';

                            // Info update moved to updateInfoDisplay() (Refactored)

                            // Update world-mouse interaction
                            if (world.scale.x !== 0) {
                                const worldX = (mouse.x - world.x) / world.scale.x;
                                const worldY = (mouse.y - world.y) / world.scale.y;

                                hoveredTileX = Math.floor(worldX / TILE_SIZE);
                                hoveredTileY = Math.floor(worldY / TILE_SIZE);
                            }

                            // Update select sprite position to hovered tile
                            if (hoveredTileX !== null && hoveredTileY !== null) {
                                selectSprite.x = hoveredTileX * TILE_SIZE;
                                selectSprite.y = hoveredTileY * TILE_SIZE;
                                selectSprite.visible = !isAltPressed; // Hide in freelook
                                // Switch texture: pressed (frame 1) when clicking, normal (frame 0) otherwise
                                selectSprite.texture = (mouse.left || mouse.right) ? selectTexPressed : selectTexNormal;
                            }

                            // Define setTile if missing (Wrapper for WS)
                            if (typeof window.setTile !== 'function') {
                                window.setTile = function (x, y, val) {
                                    if (socket && socket.readyState === WebSocket.OPEN) {
                                        socket.send(JSON.stringify({
                                            type: 'setBlock',
                                            x: x,
                                            y: y,
                                            val: val
                                        }));
                                    }
                                };
                            }

                            // Handle input (left=break, right=place)
                            const isInteractable = !isAltPressed && !camera.freelook;

                            // Only allow building in normal mode, not in freelook
                            if ((mouse.left || mouse.right) && isInteractable) {
                                const worldX = Math.floor((mouse.x - world.x) / camera.zoom / TILE_SIZE);
                                const worldY = Math.floor((mouse.y - world.y) / camera.zoom / TILE_SIZE);

                                let actionVal = null; // null = Do Nothing

                                // --- Block Interaction ---
                                // LMB -> Break (set to -1 = white/empty)
                                // RMB -> Place selected block
                                if (mouse.left) actionVal = -1; // Break (white/empty)
                                if (mouse.right) actionVal = window.selectedBlock; // Place

                                if (actionVal !== null) {
                                    if (mouse.lastX !== undefined && mouse.lastY !== undefined) {
                                        // Bresenham's Line
                                        let x0 = mouse.lastX;
                                        let y0 = mouse.lastY;
                                        const x1 = worldX;
                                        const y1 = worldY;
                                        const dx = Math.abs(x1 - x0);
                                        const dy = Math.abs(y1 - y0);
                                        const sx = (x0 < x1) ? 1 : -1;
                                        const sy = (y0 < y1) ? 1 : -1;
                                        let err = dx - dy;

                                        while (true) {
                                            setTile(x0, y0, actionVal);
                                            if (x0 === x1 && y0 === y1) break;
                                            const e2 = 2 * err;
                                            if (e2 > -dy) { err -= dy; x0 += sx; }
                                            if (e2 < dx) { err += dx; y0 += sy; }
                                        }
                                    } else {
                                        setTile(worldX, worldY, actionVal);
                                    }

                                    mouse.lastX = worldX;
                                    mouse.lastY = worldY;
                                    triggerSave();
                                }
                            } else {
                                // Reset last position if not clicking
                                mouse.lastX = undefined;
                                mouse.lastY = undefined;
                            }

                            // Hide selection sprite in freelook mode
                            if (selectSprite) {
                                selectSprite.visible = isInteractable && hoveredTileX !== null && hoveredTileY !== null;
                            }

                            render();
                            renderOverlays();


                            // Transform world (camera system - center camera position on screen)
                            // Reverted rounding to fix diagonal movement feel
                            world.scale.set(camera.zoom);
                            world.x = Math.round(-camera.x * camera.zoom + app.screen.width / 2);
                            world.y = Math.round(-camera.y * camera.zoom + app.screen.height / 2);

                            // Crosshair Position Update Removed


                            // Cursor is now updated in 'mousemove' listener for zero latency.
                            // Removed game loop update to prevent fighting/jitter.

                            // Process Dirty Chunks (Batch Rendering)
                            // Process Dirty Chunks (Batch Rendering) - With Distance Culling to prevent autogen loop
                            if (dirtyChunks.size > 0 && renderChunk) {
                                // SNAPSHOT: Create array copy and clear Set immediately.
                                // This prevents infinite loops where rendering adds new dirty chunks during the same frame.
                                const batch = Array.from(dirtyChunks);
                                dirtyChunks.clear();

                                // Calculate center chunk for culling
                                const centerCX = Math.floor(camera.x / TILE_SIZE / CHUNK_SIZE);
                                const centerCY = Math.floor(camera.y / TILE_SIZE / CHUNK_SIZE);
                                const renderCap = config.renderDistance + 4; // Allow small buffer

                                for (const key of batch) {
                                    const [cx, cy] = key.split(',').map(Number);

                                    // SAFETY: Skip rendering if too far (Prevents infinite generation loop)
                                    if (Math.abs(cx - centerCX) > renderCap || Math.abs(cy - centerCY) > renderCap) {
                                        continue;
                                    }

                                    // Remove old container FIRST
                                    if (chunkContainers.has(key)) {
                                        const containers = chunkContainers.get(key);
                                        if (containers.dirt) {
                                            dirtLayer.removeChild(containers.dirt);
                                            containers.dirt.destroy({ children: true });
                                        }
                                        if (containers.grass) {
                                            grassLayer.removeChild(containers.grass);
                                            containers.grass.destroy({ children: true });
                                        }
                                        chunkContainers.delete(key);
                                    }
                                    // Re-render
                                    renderChunk(cx, cy);
                                }
                            }


                            // Render function - chunk-based with caching

                            // Chunk Rendering Function - assign to outer scope variable
                            // Chunk Rendering Function - assign to outer scope variable
                            // Renamed to rchunks per user request

                            function getTileTexture(baseTex, idx) {
                                if (baseTex && baseTex.textures && baseTex.textures[idx]) {
                                    return baseTex.textures[idx];
                                }
                                return baseTex;
                            }

                            function rchunks(cx, cy) {
                                window.rchunks = rchunks; // Global alias
                                renderChunk = rchunks; // Fix: Assign to renderChunk so dirty chunk handler works
                                const key = `${cx},${cy}`;

                                // Check if chunk data exists. If not, request it and skip this frame
                                if (!chunks.has(key)) {
                                    // Request from Server (Via Socket)
                                    requestChunk(cx, cy);
                                    return; // Will render next frame when data arrives
                                }

                                // CLEANUP: Remove old container if it exists
                                if (chunkContainers.has(key)) {
                                    const containers = chunkContainers.get(key);
                                    if (containers.dirt) {
                                        dirtLayer.removeChild(containers.dirt);
                                        containers.dirt.destroy({ children: true });
                                    }
                                    if (containers.grass) {
                                        grassLayer.removeChild(containers.grass);
                                        containers.grass.destroy({ children: true });
                                    }
                                    chunkContainers.delete(key);
                                }

                                const chunk = getChunk(cx, cy);
                                if (!chunk) return; // Safety check

                                const chunkDirt = new PIXI.Container();
                                const chunkGrass = new PIXI.Container();

                                // try { (Removed to allow bubbling)
                                // === PASS 1: Solid color background for all tiles ===
                                const graphics = new PIXI.Graphics();

                                for (let y = 0; y < CHUNK_SIZE; y++) {
                                    for (let x = 0; x < CHUNK_SIZE; x++) {
                                        const tileVal = chunk[y][x];
                                        let color = 0x000000; // Black = Bedrock (unbreakable look)

                                        if (tileVal === 0) color = 0x1E90FF; // Ocean Blue (0)
                                        else if (tileVal === 1) color = 0x8B4513; // Dirt Brown (1)
                                        else if (tileVal === 2) color = 0x228B22; // Grass Green (2)
                                        else if (tileVal === 3) color = 0xF4A460; // Sand (3)

                                        graphics.beginFill(color);
                                        graphics.drawRect(
                                            x * TILE_SIZE,
                                            y * TILE_SIZE,
                                            TILE_SIZE, TILE_SIZE
                                        );
                                        graphics.endFill();
                                    }
                                }

                                chunkDirt.addChild(graphics);

                                chunkDirt.addChild(graphics);

                                // === MULTI-PASS DUAL GRID (Water -> Dirt -> Grass -> Sand) ===
                                const worldStartX = cx * CHUNK_SIZE;
                                const worldStartY = cy * CHUNK_SIZE;

                                // Define layers using global textures
                                const layers = [
                                    { id: 0, tex: window.textures.water },
                                    { id: 1, tex: window.textures.tdirt },
                                    { id: 2, tex: window.textures.grass },
                                    { id: 3, tex: window.textures.tsand }
                                ];

                                for (const layer of layers) {
                                    if (layer.tex && layer.tex.textures) {
                                        for (let y = -1; y < CHUNK_SIZE; y++) {
                                            for (let x = -1; x < CHUNK_SIZE; x++) {
                                                const wx = worldStartX + x;
                                                const wy = worldStartY + y;

                                                const idx = getDgIdx(wx, wy, layer.id);

                                                // Image 12 is fully empty (0000) - skip rendering
                                                if (idx === 12) continue;

                                                const tex = layer.tex.textures[idx];
                                                if (!tex) continue;

                                                const sprite = new PIXI.Sprite(tex);
                                                sprite.x = x * TILE_SIZE + TILE_SIZE / 2;
                                                sprite.y = y * TILE_SIZE + TILE_SIZE / 2;
                                                sprite.width = TILE_SIZE;
                                                sprite.height = TILE_SIZE;
                                                chunkGrass.addChild(sprite);
                                            }
                                        }
                                    }
                                }

                                // Position chunk container
                                chunkDirt.x = cx * CHUNK_SIZE * TILE_SIZE;
                                chunkDirt.y = cy * CHUNK_SIZE * TILE_SIZE;
                                chunkGrass.x = cx * CHUNK_SIZE * TILE_SIZE;
                                chunkGrass.y = cy * CHUNK_SIZE * TILE_SIZE;

                                chunkContainers.set(key, { dirt: chunkDirt, grass: chunkGrass });
                                dirtLayer.addChild(chunkDirt);
                                grassLayer.addChild(chunkGrass);

                                chunkContainers.set(key, { dirt: chunkDirt, grass: chunkGrass });
                                dirtLayer.addChild(chunkDirt);
                                grassLayer.addChild(chunkGrass);

                                // } catch (e) { ... } (Removed)
                            }

                            function render() {
                                window.render = render; // Global alias
                                try {
                                    // Skip if rchunks not ready yet
                                    if (!rchunks) return;

                                    // Reset chunk count each frame
                                    chunksRendered = 0;

                                    // Check if we crossed LOD threshold
                                    const currentLODState = camera.zoom < config.lodThreshold;
                                    if (lastLODState !== currentLODState) {
                                        // Clear all chunks when crossing LOD threshold
                                        for (const [key, containers] of chunkContainers.entries()) {
                                            if (containers.dirt) {
                                                dirtLayer.removeChild(containers.dirt);
                                                containers.dirt.destroy();
                                            }
                                            if (containers.grass) {
                                                grassLayer.removeChild(containers.grass);
                                                containers.grass.destroy();
                                            }
                                        }
                                        chunkContainers.clear();
                                        lastLODState = currentLODState;
                                    }

                                    // AGGRESSIVE GC: Prevent memory leaks
                                    if (chunks.size > 1000) {
                                        // Calculate player chunk position for GC
                                        const playerChunkX = Math.floor(player.x / TILE_SIZE / CHUNK_SIZE);
                                        const playerChunkY = Math.floor(player.y / TILE_SIZE / CHUNK_SIZE);
                                        const renderDistance = config.renderDistance;

                                        // Force cleanup of ANY chunk outside view + buffer
                                        for (const key of chunks.keys()) {
                                            const [cx, cy] = key.split(',').map(Number);
                                            if (Math.abs(cx - playerChunkX) > renderDistance + 2 ||
                                                Math.abs(cy - playerChunkY) > renderDistance + 2) {
                                                chunks.delete(key);
                                            }
                                        }
                                    }

                                    // Calculate visible bounds based on viewport
                                    const viewHalfW = (app.screen.width / camera.zoom) / 2;
                                    const viewHalfH = (app.screen.height / camera.zoom) / 2;

                                    // Convert to chunk coordinates - limit to render distance from config
                                    const maxRenderDist = Math.min(config.renderDistance, 32); // Increased cap for Infinite World feel

                                    // Calculate viewport-based chunk range
                                    // Increased pad (2 chunks) to prevent clipping of edge sprites (Dual Grid)
                                    let startChunkX = Math.floor((camera.x - viewHalfW) / (TILE_SIZE * CHUNK_SIZE)) - 2;
                                    let endChunkX = Math.ceil((camera.x + viewHalfW) / (TILE_SIZE * CHUNK_SIZE)) + 2;
                                    let startChunkY = Math.floor((camera.y - viewHalfH) / (TILE_SIZE * CHUNK_SIZE)) - 2;
                                    let endChunkY = Math.ceil((camera.y + viewHalfH) / (TILE_SIZE * CHUNK_SIZE)) + 2;

                                    // Also limit by render distance from player chunk
                                    const playerChunkXCenter = Math.floor(player.x / TILE_SIZE / CHUNK_SIZE);
                                    const playerChunkYCenter = Math.floor(player.y / TILE_SIZE / CHUNK_SIZE);
                                    startChunkX = Math.max(startChunkX, playerChunkXCenter - maxRenderDist);
                                    endChunkX = Math.min(endChunkX, playerChunkXCenter + maxRenderDist);
                                    startChunkY = Math.max(startChunkY, playerChunkYCenter - maxRenderDist);
                                    endChunkY = Math.min(endChunkY, playerChunkYCenter + maxRenderDist);

                                    // Determine which chunks should be visible
                                    const chunksToRender = new Set();
                                    for (let cy = startChunkY; cy <= endChunkY; cy++) {
                                        for (let cx = startChunkX; cx <= endChunkX; cx++) {
                                            chunksToRender.add(`${cx},${cy}`);
                                        }
                                    }

                                    // Remove chunks that are WAY out of range (Hysteresis for Caching)
                                    // Don't destroy immediately if just off-screen.
                                    const camChunkX = Math.floor(camera.x / (TILE_SIZE * CHUNK_SIZE));
                                    const camChunkY = Math.floor(camera.y / (TILE_SIZE * CHUNK_SIZE));

                                    // In Freelook, keep chunks loaded much longer ("Break limits")
                                    // Normal: renderDist + 4. Freelook: 50 (Huge cache).
                                    const unloadDist = isAltPressed ? 50 : (Math.ceil(config.renderDistance / camera.zoom) + 4);

                                    for (const [key, containers] of chunkContainers.entries()) {
                                        const [kcx, kcy] = key.split(',').map(Number);

                                        // Distance check from camera center
                                        // Distance check from camera center
                                        if (Math.abs(kcx - camChunkX) > unloadDist ||
                                            Math.abs(kcy - camChunkY) > unloadDist) {

                                            if (containers.dirt) {
                                                dirtLayer.removeChild(containers.dirt);
                                                containers.dirt.destroy({ children: true });
                                            }
                                            if (containers.grass) {
                                                grassLayer.removeChild(containers.grass);
                                                containers.grass.destroy({ children: true }); // Ensure children destroyed
                                            }
                                            chunkContainers.delete(key);
                                        }
                                    }

                                    // Render new chunks (only if not already rendered)
                                    // Turbo Mode in Freelook: "Break its maximum"
                                    let limit = config.maxChunksPerFrame || 10;
                                    if (isAltPressed) limit = 200; // Allow massive chunk loading in freelook

                                    let chunksCreated = 0;

                                    // Process Dirty Chunks First (Immediate Updates)
                                    if (window.dirtyChunks && window.dirtyChunks.size > 0) {
                                        for (const key of window.dirtyChunks) {
                                            // Force re-render if it's within render distance
                                            if (chunksToRender.has(key)) {
                                                const [cx, cy] = key.split(',').map(Number);
                                                // Cleaning old container
                                                if (chunkContainers.has(key)) {
                                                    const containers = chunkContainers.get(key);
                                                    if (containers.dirt) {
                                                        dirtLayer.removeChild(containers.dirt);
                                                        containers.dirt.destroy({ children: true });
                                                    }
                                                    if (containers.grass) {
                                                        grassLayer.removeChild(containers.grass);
                                                        containers.grass.destroy({ children: true });
                                                    }
                                                    chunkContainers.delete(key);
                                                }
                                                rchunks(cx, cy);
                                                chunksCreated++;
                                            }
                                        }
                                        window.dirtyChunks.clear();
                                    }

                                    // Loop through chunks (standard scanline order: top-to-bottom)
                                    for (const key of chunksToRender) {
                                        if (!chunkContainers.has(key)) {
                                            if (chunksCreated < limit) {
                                                const [cx, cy] = key.split(',').map(Number);
                                                rchunks(cx, cy);
                                                chunksCreated++;
                                            }
                                            // If we hit limit, we just stop creating for this frame. 
                                            // They will be picked up next frame.
                                        }
                                        chunksRendered++;
                                    }

                                    // Update stats - Cached and Rendered (no Loading indicator)
                                    const fps = Math.round(app.ticker.FPS);
                                    // Tick Timer (Simulated by server response or local delta?)
                                    // For now, just show FPS and Chunk Stats as requested
                                    const activeChunks = chunkContainers.size;
                                    const cachedChunks = chunks.size;

                                    // Frame Timer: app.ticker.elapsedMS
                                    const frameTime = app.ticker.elapsedMS.toFixed(2);

                                    // Update player graphics
                                    window.playerGraphics.clear();
                                    window.playerGraphics.beginFill(0xFF0000); // Red circle for ugliness
                                    window.playerGraphics.drawCircle(0, 0, 6); // 6px radius
                                    window.playerGraphics.endFill();
                                    window.playerGraphics.x = player.x;
                                    window.playerGraphics.y = player.y;

                                    // Update info text
                                    updateInfoDisplay();

                                } catch (err) {
                                    console.error("Render Error:", err);
                                    app.ticker.stop();
                                    const errDiv = document.createElement('div');
                                    errDiv.style.cssText = "position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.85);color:#ff5555;font-family:monospace;padding:20px;z-index:999999;white-space:pre-wrap;overflow:auto;pointer-events:all;";
                                    errDiv.innerHTML = "<h1>GAME CRASHED</h1><h2>" + err.toString() + "</h2><hr/>stack trace:<br/>" + (err.stack || "No stack trace");
                                    document.body.appendChild(errDiv);
                                }
                            } // End render

                            // Update Grid Positions
                            // Grid toggle via G key (no longer forced)
                            if (typeof renderOverlays === 'function') renderOverlays();
                        });
                    } // End startGameLoop

                    // Render overlays (grid, highlights, etc) - called after chunk rendering
                    let overlayGraphics = null;

                    function renderOverlays() {
                        // Debug log to confirm function entry and grid state
                        // console.log("renderOverlays called. showGrid:", window.showGrid); 

                        // Skip overlay rendering entirely if grid is disabled (massive performance boost)
                        if (!window.showGrid) {
                            if (overlayGraphics) {
                                world.removeChild(overlayGraphics);
                                overlayGraphics.destroy();
                                overlayGraphics = null;
                            }
                            if (window.gridRed) window.gridRed.visible = false;
                            if (window.gridWhite) window.gridWhite.visible = false;
                            return; // Exit function
                        }

                        // reuse graphics   
                        if (overlayGraphics) {
                            overlayGraphics.clear();
                        } else {
                            overlayGraphics = new PIXI.Graphics();
                        }

                        // Calculate visible area
                        const playerChunkX = Math.round(player.x / TILE_SIZE / CHUNK_SIZE);
                        const playerChunkY = Math.round(player.y / TILE_SIZE / CHUNK_SIZE);

                        // Scale render distance inversely with zoom to cover screen
                        // Base distance 6 chunks (covers 1080p width at 1.0x with margin)
                        // Allow distance to grow when zooming out (min zoom 0.1)
                        // Max distance clamped to 20 to prevent performance issues
                        const viewRadius = Math.ceil(8 / Math.max(camera.zoom, 0.1));
                        const renderDistance = Math.min(20, Math.max(6, viewRadius)); // Min 6, Max 20

                        const startX = (playerChunkX - renderDistance) * CHUNK_SIZE;
                        const endX = (playerChunkX + renderDistance + 1) * CHUNK_SIZE;
                        const startY = (playerChunkY - renderDistance) * CHUNK_SIZE;
                        const endY = (playerChunkY + renderDistance + 1) * CHUNK_SIZE;


                        /* BLOCK GRID RESTORED (User Request) */
                        // Grid toggle via G key (no longer forced on)

                        if (window.showGrid) {
                            // Hairline Grid: Width scales inversely with zoom to stay 1px on screen
                            // Increased alpha because thin lines are harder to see
                            // FIXED: Thicker line (2px base) and higher alpha (0.5) for visibility
                            const lineWidth = Math.max(1, 1 / Math.max(camera.zoom, 0.1));
                            overlayGraphics.lineStyle(lineWidth, 0xFF0000, 0.5); // Red Grid

                            // Vertical Lines (x)
                            // startX/endX are in Tile Units. Iterate through each tile column.
                            for (let x = startX; x <= endX; x++) {
                                const px = x * TILE_SIZE;
                                overlayGraphics.moveTo(px, startY * TILE_SIZE);
                                overlayGraphics.lineTo(px, endY * TILE_SIZE);
                            }

                            // Horizontal Lines (y) 
                            // Iterate through each tile row.
                            for (let y = startY; y <= endY; y++) {
                                const py = y * TILE_SIZE;
                                overlayGraphics.moveTo(startX * TILE_SIZE, py);
                                overlayGraphics.lineTo(endX * TILE_SIZE, py);
                            }
                        }


                        /* GREEN HIGHLIGHT LOOP REMOVED (Performance Optimization) */

                        // 2. Blue chunk boundaries (User Request: chunk=blue, block=red)
                        overlayGraphics.lineStyle(2, 0x0000ff, 0.5);
                        const chunkStartX = Math.floor(startX / CHUNK_SIZE) * CHUNK_SIZE;
                        const chunkEndX = Math.ceil(endX / CHUNK_SIZE) * CHUNK_SIZE;
                        const chunkStartY = Math.floor(startY / CHUNK_SIZE) * CHUNK_SIZE;
                        const chunkEndY = Math.ceil(endY / CHUNK_SIZE) * CHUNK_SIZE;

                        for (let x = chunkStartX; x <= chunkEndX; x += CHUNK_SIZE) {
                            overlayGraphics.moveTo(x * TILE_SIZE, chunkStartY * TILE_SIZE);
                            overlayGraphics.lineTo(x * TILE_SIZE, chunkEndY * TILE_SIZE);
                        }
                        for (let y = chunkStartY; y <= chunkEndY; y += CHUNK_SIZE) {
                            overlayGraphics.moveTo(chunkStartX * TILE_SIZE, y * TILE_SIZE);
                            overlayGraphics.lineTo(chunkEndX * TILE_SIZE, y * TILE_SIZE);
                        }
                        overlayGraphics.stroke();

                        overlayGraphics.zIndex = 2002;
                        world.addChild(overlayGraphics);
                    } // End renderOverlays


                    // HTML Cursor Logic (Simple Follower)
                    // HTML Cursor Logic (Simple Follower) - REMOVED for CSS Cursor
                    // const follower = document.getElementById("follower-element");
                    // window.addEventListener('mousemove', (event) => { ... });


                    // CHUNK FETCHER INTEGRATION (Background Network Thread)
                    // This background thread just DOWNLOADS data from Java. It does not generate it.
                    // New Request Logic: Uses persistent WebSocket Connection
                    // Replaces the old Worker/HTTP method to fix "stuck" loading (browser connection limits)
                    function requestChunk(cx, cy) {
                        const key = `${cx},${cy}`;
                        if (pendingChunks.has(key) || chunks.has(key)) return;

                        if (socket && socket.readyState === WebSocket.OPEN) {
                            pendingChunks.add(key);
                            socket.send(JSON.stringify({
                                type: 'getChunk',
                                key: key
                            }));
                        }
                    }

                    // Save World Function
                    // Save World Function (Auto-Save Optimized)
                    async function saveWorld() {
                        if (!socket || socket.readyState !== WebSocket.OPEN) {
                            console.warn("Cannot save: WS not connected");
                            alert("Cannot save: Server Disconnected");
                            return;
                        }

                        const saveData = {
                            type: "save",
                            player: {
                                x: player.x,
                                y: player.y
                            },
                            chunks: []
                        };

                        // Gather Modified Chunks
                        if (modifiedChunks.size > 0) {
                            for (const key of modifiedChunks) {
                                if (chunks.has(key)) {
                                    const chunk = chunks.get(key);
                                    // Flatten
                                    let dataStr = '';
                                    for (let y = 0; y < CHUNK_SIZE; y++) {
                                        for (let x = 0; x < CHUNK_SIZE; x++) {
                                            dataStr += chunk[y][x];
                                        }
                                    }
                                    saveData.chunks.push({
                                        key: key,
                                        data: dataStr
                                    });
                                }
                            }
                        }

                        // Needed for the specific manual parser on server which expects a flat list sometimes or specific keys?
                        // The server parser looks for "key":"..." then "data":"..." repeatedly.
                        // JSON.stringify will produce `... "chunks":[{"key":"...", "data":"..."}, ...] ...`
                        // My robust parser in Java (the loop) should handle this standard JSON array format fine 
                        // because it searches for "key": and "data": sequentially.

                        // console.log("Sending Save via WebSocket...");
                        sendJson(saveData);

                        // Clear modified set locally (optimistic)
                        modifiedChunks.clear();

                        const btn = document.getElementById('saveBtn');
                        if (btn) btn.innerText = "Saving...";
                    }

                    async function persistDB() {
                        // DB REMOVED
                    }



                    // Start Game Loop (Refactored)
                    // startgl removed to avoid duplicate tickers. Using startGameLoop.

                    // Expose globally for WS callback
                    window.startGameLoop = startGameLoop; // Start from initMP using this alias

                    // Event-Driven Auto-Save Logic
                    let saveTimeout = null;
                    const SAVE_DELAY = 2000; // 2 seconds of inactivity before saving player position

                    function triggerSave() {
                        // If already saving, ignore or debounce?
                        // Simple debounce: reset timer
                        if (saveTimeout) clearTimeout(saveTimeout);
                        saveTimeout = setTimeout(() => {
                            saveWorld();
                            saveTimeout = null;
                        }, SAVE_DELAY);
                    }


                    // Start the game logic now that workers and textures are ready
                    // Start the networking first, game start happens on WS Open
                    initMP();

                }); // End Promise.all().then()
            } // End initGame

            // --- WebSocket Multiplayer Logic ---
            let socket;
            const otherPlayers = new Map(); // id -> {x, y, sprite}

            function lerp(start, end, amt) {
                return (1 - amt) * start + amt * end;
            }

            // reqChunk removed (duplicate)

            function initMP() {
                if (socket && (socket.readyState === WebSocket.OPEN || socket.readyState === WebSocket.CONNECTING)) {
                    console.log("[WS] Socket already active");
                    return;
                }

                // Initialize Dirty Chunks Set (Real-time Updates)
                window.dirtyChunks = new Set();

                try {
                    const wsPort = parseInt(location.port) + 1;
                    socket = new WebSocket(`ws://${location.hostname}:${wsPort}`);
                    window.socket = socket; // Make socket globally accessible for getChunk

                    socket.onopen = () => {
                        console.log("[WS] Connected to Multiplayer Server");

                        // INLINED Loading Screen Logic (No simpleStart function)
                        const overlay = document.getElementById('loading-overlay');
                        if (overlay) {
                            overlay.style.opacity = '0';
                            setTimeout(() => overlay.style.display = 'none', 1000);
                        }

                        app.canvas.style.opacity = '1';
                        // Start Loop Immediately - No Preloading
                        if (window.startGameLoop) window.startGameLoop();
                        else console.error("startGameLoop not defined!");
                    };

                    socket.onerror = (err) => {
                        console.error("[WS] Connection Error", err);
                        const overlay = document.getElementById('loading-overlay');
                        if (overlay) {
                            overlay.style.color = "#ff5555"; // Red
                            overlay.innerHTML = "Connection Failed!<br>Is the Server Running?";
                        }
                    };

                    socket.onclose = (event) => {
                        console.log("[WS] Connection Closed", event);
                        if (!event.wasClean) {
                            const overlay = document.getElementById('loading-overlay');
                            if (overlay) {
                                overlay.style.color = "#ff5555";
                                overlay.innerHTML = "Disconnected from Server.<br>Please Refresh.";
                                overlay.style.opacity = '1';
                                overlay.style.display = 'flex';
                            }
                        }
                    };

                    socket.onmessage = (event) => {
                        // console.log("WS Data:", event.data);
                        let msg = null;
                        try {
                            msg = JSON.parse(event.data);
                        } catch (e) { return; }

                        if (msg.type === 'chunk') {
                            // Store chunk data
                            // Server sends {type:'chunk', key:'cx,cy', data:'[[...],[...]]'}
                            const key = msg.key; // Use key directly (server sends key, not x/y)
                            let chunkData = msg.data;

                            // Server sends data as a string - parse it to a 2D array
                            if (typeof chunkData === 'string') {
                                try {
                                    chunkData = JSON.parse(chunkData);
                                } catch (e) {
                                    console.error('Failed to parse chunk data for', key, e);
                                    return;
                                }
                            }

                            if (Array.isArray(chunkData)) {
                                // Server sends flat 1D array [v0,v1,...v255]
                                // Renderer needs 2D array chunk[y][x]
                                if (chunkData.length > 0 && !Array.isArray(chunkData[0])) {
                                    // Reshape flat array to 2D (CHUNK_SIZE x CHUNK_SIZE)
                                    const rows = [];
                                    for (let r = 0; r < CHUNK_SIZE; r++) {
                                        rows.push(chunkData.slice(r * CHUNK_SIZE, (r + 1) * CHUNK_SIZE));
                                    }
                                    chunkData = rows;
                                }
                                chunks.set(key, chunkData);
                                pendingChunks.delete(key);
                            }
                            // Mark as dirty to re-render immediately
                            if (window.dirtyChunks) window.dirtyChunks.add(key);

                        } else if (msg.type === 'block') {
                            // {"type":"block", "x":..., "y":..., "val":...}
                            const cx = Math.floor(msg.x / CHUNK_SIZE);
                            const cy = Math.floor(msg.y / CHUNK_SIZE);
                            const key = cx + "," + cy;

                            // Update local cache if exists
                            let cData = chunks.get(key);
                            if (cData) {
                                const lx = (msg.x % CHUNK_SIZE + CHUNK_SIZE) % CHUNK_SIZE;
                                const ly = (msg.y % CHUNK_SIZE + CHUNK_SIZE) % CHUNK_SIZE;
                                cData[ly][lx] = msg.val;

                                // Dirty THIS chunk
                                if (window.dirtyChunks) {
                                    window.dirtyChunks.add(key);

                                    // Dirty NEIGHBORS if on border (for Dual Grid)
                                    if (lx === 0) window.dirtyChunks.add((cx - 1) + "," + cy);
                                    if (lx === CHUNK_SIZE - 1) window.dirtyChunks.add((cx + 1) + "," + cy);
                                    if (ly === 0) window.dirtyChunks.add(cx + "," + (cy - 1));
                                    if (ly === CHUNK_SIZE - 1) window.dirtyChunks.add(cx + "," + (cy + 1));
                                }
                            }
                        } else if (msg.type === 'tps') {
                            // Server Tick Rate Broadcast
                            window.currentTPS = msg.val;
                        }
                    };

                    window.updateInfoDisplay = function () {
                        const fps = Math.round(app.ticker.FPS);
                        const tps = window.currentTPS || 20;
                        const x = Math.floor(player.x);
                        const y = Math.floor(player.y);
                        const z = camera.zoom.toFixed(2);
                        const info = document.getElementById('info');
                        if (info) {
                            // Shortened Labels (User Request)
                            info.innerHTML = `FPS:${fps} TPS:${tps} XY:${x},${y} Z:${z}`;
                        }
                    };









                } catch (e) {
                    console.error("[WS] Connection Failed", e);
                }
            }

            function sendJson(data) {
                if (socket && socket.readyState === WebSocket.OPEN) {
                    socket.send(JSON.stringify(data));
                }
            }

            // Generate a simple ID for this session
            const myId = Date.now().toString();

            function updRemote(id, x, y) {
                if (!world) return;

                let p = otherPlayers.get(id);
                if (!p) {
                    // Create new sprite for other player
                    const graphics = new PIXI.Graphics();
                    // RED SQUARE REMOVED (User Request)
                    /*
                    graphics.beginFill(0xFF0000); // Red for other players
                    graphics.drawRect(0, 0, 16, 16);
                    graphics.endFill();
                    */

                    p = { sprite: graphics, targetX: x, targetY: y };
                    p.sprite.x = x;
                    p.sprite.y = y;
                    p.sprite.zIndex = 100;

                    world.addChild(p.sprite);
                    otherPlayers.set(id, p);
                }

                // Update target for interpolation
                p.targetX = x;
                p.targetY = y;
                // Instant snap for now, or lerp in ticker?
                p.sprite.x = x;
                p.sprite.y = y;
            }

            // Start Multiplayer
            // setTimeout(initMultiplayer, 1000); // REMOVED: Called explicitly in Promise chain

            // Broadcast loop
            setInterval(() => {
                if (socket && socket.readyState === WebSocket.OPEN && player) {
                    const payload = JSON.stringify({
                        type: 'pos',
                        id: myId,
                        x: player.x,
                        y: player.y
                    });
                    socket.send(payload);
                }
            }, 50); // 20 times per second

        }); // End window.addEventListener

        // Initialize (One-time save on close?)
        window.addEventListener('beforeunload', () => {
            // Try to fire a beacon or sync save? HARD to do reliably.
            // Rely on the frequent triggers.
        });

        // UI INITIALIZATION REMOVED
        // Only essential logic remains in index.html, UI is now in ui.html
    </script>
</body>

</html>