<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8">
    <title>tyls.io</title>
    <link rel="icon" href="data:,">
    <style>
        @font-face {
            font-family: 'Minecraft';
            src: url('../Assets/Font/pixel.ttf') format('truetype');
        }

        body {
            margin: 0;
            overflow: hidden;
            /* Hide default/CSS cursor for Software Cursor */
            background: #000;
        }

        canvas {
            display: block;
            image-rendering: pixelated;
            image-rendering: crisp-edges;
            cursor: none;
        }

        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            color: #ffffff;
            font-family: 'Minecraft', monospace;
            font-size: 16px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
            pointer-events: none;
            z-index: 100;
        }

        #activity {
            position: absolute;
            top: 10px;
            right: 10px;
            color: #ffffff;
            font-family: 'Minecraft', monospace;
            font-size: 20px;
            font-weight: bold;
            text-shadow: 0 0 5px rgba(255, 255, 255, 0.5);
            opacity: 0;
            transition: opacity 0.2s;
            pointer-events: none;
        }

        #activity.flash {
            opacity: 1;
        }

        /* Custom HTML Cursor */
        /* Custom HTML Cursor */
        #follower-element {
            width: 32px;
            height: 32px;
            background-image: url('../Assets/Image/cursor.png');
            background-size: contain;
            background-repeat: no-repeat;
            position: fixed;
            transform: translate(-50%, -50%);
            /* Center? Usually cursors are top-left... let's keep top-left */
            /* transform: translate(0, 0); */
            pointer-events: none;
            z-index: 10000;
            image-rendering: pixelated;
        }

        /* Force Hide System Cursor Globally */
        * {
            cursor: none !important;
        }
    </style>
</head>

<body>
    <div id="info"></div>
    <div id="activity"></div>
    <div id="follower-element"></div>

    <!-- Loading Overlay -->
    <div id="loading-overlay"
        style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: #000; z-index: 99999; display: flex; align-items: center; justify-content: center; color: white; font-family: 'Minecraft', monospace; font-size: 24px; transition: opacity 1s;">
        Loading World...
    </div>

    <!-- Save Button -->




    <!-- Loading Screen Removed per User Request -->

    <script>
        window.onerror = function (msg, url, line, col, error) {
            const div = document.createElement('div');
            div.style.position = 'fixed';
            div.style.top = '50%';
            div.style.left = '50%';
            div.style.transform = 'translate(-50%, -50%)';
            div.style.background = 'rgba(255,0,0,0.8)';
            div.style.color = 'white';
            div.style.padding = '20px';
            div.style.border = '2px solid white';
            div.style.zIndex = '99999';
            div.style.fontFamily = 'monospace';
            div.innerText = `CRITICAL ERROR:\n${msg}\nLine: ${line}`;
            document.body.appendChild(div);
            return false;
        };
    </script>

    <script src="https://cdn.jsdelivr.net/npm/pixi.js@8.5.2/dist/pixi.min.js"></script>

    <!-- UI System Removed -->
    <script>
        // Initialize empty data structures to prevent errors
        window.inventoryData = [];
        window.hotbarData = [];
    </script>

    <!-- UI System Removed (Per User Request) -->
    <!-- Variables.js is now inlined in the next script block -->
    <script>
        // --- INLINED VARIABLES (Formerly variables.js) ---
        // Game Constants
        const TILE_SIZE = 16;
        const CHUNK_SIZE = 16;
        // SERVER_URL Removed (WebSockets Only)

        // Configuration (Overridden by config.json)
        let config = {
            playerSpeed: 200,
            defaultZoom: 3.0,
            minZoom: 0.25,
            maxZoom: 10,
            chunkSize: 16,
            renderDistance: 5,
            lodThreshold: 0.8,
            maxChunksPerFrame: 10
        };

        // Game State
        const chunks = new Map();
        const chunkContainers = new Map();
        const dirtyChunks = new Set();
        const pendingChunks = new Set();
        const modifiedChunks = new Set(); // Track chunks modified by player for saving
        let chunksRendered = 0;

        // Entitiessd
        const camera = { x: 0, y: 0, zoom: 3.0, freelook: false };
        const player = { x: 128, y: 128, width: 16, height: 16, speed: 200 };
        const mouse = { x: 0, y: 0, left: false, right: false, lastX: undefined, lastY: undefined };

        // Interaction
        let isAltPressed = false;
        let showGrid = false;
        let hoveredTileX = null;
        let hoveredTileY = null;
        let selectSprite = null;

        // Input
        const keys = {};
        let pressedKeys = new Set();
        const globalTextureCache = new Map();

        // Globals
        let app, world, dirtLayer, grassLayer, renderChunk = null, fetchChunkViaWorker = null;
        let db = null; // Database instance

        // Input Handler (Renamed from handleInput)
        function hi(delta) {
            const speed = player.speed * delta / 60;
            let vx = 0;
            let vy = 0;

            if (keys['w'] || keys['W'] || keys['ArrowUp']) vy -= 1;
            if (keys['s'] || keys['S'] || keys['ArrowDown']) vy += 1;
            if (keys['a'] || keys['A'] || keys['ArrowLeft']) vx -= 1;
            if (keys['d'] || keys['D'] || keys['ArrowRight']) vx += 1;

            // Normalize diagonal
            if (vx !== 0 && vy !== 0) {
                const len = Math.sqrt(vx * vx + vy * vy);
                vx /= len;
                vy /= len;
            }

            // Apply movement
            if (vx !== 0 || vy !== 0) {
                player.x += vx * speed;
                player.y += vy * speed;
                // Center camera on player
                // camera.x = player.x - (app.screen.width / 2) / camera.zoom;
                // camera.y = player.y - (app.screen.height / 2) / camera.zoom;
            }
        }

        // Key Listeners
        window.addEventListener('keydown', (e) => {
            if (keys[e.key]) return; // distinct press check
            keys[e.key] = true;
            if (e.key === 'Alt') isAltPressed = true;

            // HOTBAR / OFFHAND LOGIC
            // Hotbar keys disabled per user request to keep UI logic in prototype
            // if (e.key === '1') ...
            // if (e.key === '2') ...
            // Key 3 (Offhand) Removed
            // if (e.key === '3') { ... }
        });
        window.addEventListener('keyup', (e) => {
            keys[e.key] = false;
            if (e.key === 'Alt') isAltPressed = false;
        });
    </script>
    <script>
        // Wait for PixiJS to load
        window.addEventListener('load', async () => {
            // --- DB REMOVED (User Request) ---
            // Settings
            // Settings (Loaded from variables.js)



            // Settings
            // Settings (Loaded from variables.js)



            // Global PixiJS Settings for Pixel Art
            PIXI.TextureSource.defaultOptions.scaleMode = 'nearest';

            // PixiJS App (v8 requires await)
            // PixiJS App (using global 'app' from variables.js)
            app = new PIXI.Application();
            await app.init({
                width: window.innerWidth,
                height: window.innerHeight,
                backgroundColor: 0x1a1a1a,
                antialias: false,
                roundPixels: true,  // Pixel-perfect rendering
                preference: 'maximum-performance', // Hint to browser
                powerPreference: 'high-performance'
            });
            // Cap FPS to 60 to prevent coil whine and "infinite" FPS lag
            app.ticker.maxFPS = 60;
            document.body.appendChild(app.canvas);

            // Resize canvas to fill screen (fixes black bar at top)
            function resizeCanvas() {
                app.renderer.resize(window.innerWidth, window.innerHeight);
            }
            window.addEventListener('resize', resizeCanvas);
            resizeCanvas(); // Call once to ensure proper size

            // Pixel-perfect (v8 compatible)
            // FPS Uncapped (User requested)



            // World container
            // World container (global 'world')
            world = new PIXI.Container();
            world.sortableChildren = true; // Enable z-index sorting for world (tiles/players)
            app.stage.sortableChildren = true; // Enable z-index sorting for stage (UI/Crosshair)
            app.stage.addChild(world);

            // Layers for Z-sorting (Fixes "cutoff" grass/half tiles)
            // Layers for Z-sorting (global 'dirtLayer', 'grassLayer')
            dirtLayer = new PIXI.Container();
            grassLayer = new PIXI.Container();
            world.addChild(dirtLayer);
            world.addChild(grassLayer);

            // Track hovered tile position (Global from variables.js)
            // let hoveredTileX = null;
            // let hoveredTileY = null;

            // Mouse tracking


            // NOTE: selectSprite and event handlers moved inside Promise.all().then() to ensure texture is loaded


            // Chunk-based world data
            // RENDER_DISTANCE now comes from config.renderDistance
            // Chunk-based world data (Global from variables.js)
            // const chunks = new Map(); 
            // const chunkContainers = new Map();
            // const dirtyChunks = new Set();
            // let chunksRendered = 0;

            // renderChunk function reference (defined below, declared in variables.js)
            // let renderChunk = null; (Global)

            // Simple Perlin-like noise REMOVED (Legacy, Server handles generation now)

            // Chunk Management (Client Cache)
            // Data is fetched from Server, stored here
            // chunks map is global.


            // Track pending requests (Global from variables.js)
            // const pendingChunks = new Set();

            // Request Chunk via WebSocket
            function requestChunk(cx, cy) {
                const key = `${cx},${cy}`;
                if (chunks.has(key) || pendingChunks.has(key)) return;

                pendingChunks.add(key);
                if (window.socket && window.socket.readyState === WebSocket.OPEN) {
                    window.socket.send(JSON.stringify({ type: 'getChunk', key: key }));
                }
            }

            // Legacy fetchChunk removed
            async function fetchChunk(cx, cy) {
                requestChunk(cx, cy);
            }

            function getChunk(cx, cy) {
                const key = `${cx},${cy}`;
                if (chunks.has(key)) {
                    return chunks.get(key);
                }

                // WASM DB Lookups REMOVED
                // if (db) { ... }

                // Fallback / Loading placeholder
                const empty = [];
                for (let i = 0; i < CHUNK_SIZE; i++) empty[i] = new Array(CHUNK_SIZE).fill(0);
                return empty;
            }

            function getTile(x, y) {
                const cx = Math.floor(x / CHUNK_SIZE);
                const cy = Math.floor(y / CHUNK_SIZE);
                const tx = ((x % CHUNK_SIZE) + CHUNK_SIZE) % CHUNK_SIZE;
                const ty = ((y % CHUNK_SIZE) + CHUNK_SIZE) % CHUNK_SIZE;
                const chunk = getChunk(cx, cy);
                return chunk[ty][tx];
            }

            // Helper: Get Tile without forcing chunk generation (prevents render lag)
            // Helper: Get Tile safe (Synchronous WASM Access)
            function getTileSafe(x, y) {
                const cx = Math.floor(x / CHUNK_SIZE);
                const cy = Math.floor(y / CHUNK_SIZE);

                // WASM: getChunk is instant (checks Cache -> DB -> Empty)
                // This ensures neighbors are loaded for correct edge connections (fixing diagonal gaps)
                const chunk = getChunk(cx, cy);

                const tx = ((x % CHUNK_SIZE) + CHUNK_SIZE) % CHUNK_SIZE;
                const ty = ((y % CHUNK_SIZE) + CHUNK_SIZE) % CHUNK_SIZE;
                return chunk[ty][tx];
            }

            function setTile(x, y, value) {
                const cx = Math.floor(x / CHUNK_SIZE);
                const cy = Math.floor(y / CHUNK_SIZE);
                const tx = ((x % CHUNK_SIZE) + CHUNK_SIZE) % CHUNK_SIZE;
                const ty = ((y % CHUNK_SIZE) + CHUNK_SIZE) % CHUNK_SIZE;
                const chunk = getChunk(cx, cy);
                if (chunk[ty][tx] === value) return;
                // WEBSOCKET UPDATE: Send change to server immediately
                if (window.socket && window.socket.readyState === WebSocket.OPEN) {
                    window.socket.send(JSON.stringify({
                        type: 'setBlock',
                        id: myId, // Send ID to ignore self-echo
                        x: x,
                        y: y,
                        val: value
                    }));
                } else {
                    // Fallback if offline? Just update local for now.
                    // But user said "websocket is for data", so we assume online.
                }

                chunk[ty][tx] = value;

                // Mark chunk for re-render
                const key = `${cx},${cy}`;
                dirtyChunks.add(key);

                // AUTO-TILING: Dirty neighbors if on edge
                if (tx === 0) dirtyChunks.add(`${cx - 1},${cy}`);
                if (tx === CHUNK_SIZE - 1) dirtyChunks.add(`${cx + 1},${cy}`);
                if (ty === 0) dirtyChunks.add(`${cx},${cy - 1}`);
                if (ty === CHUNK_SIZE - 1) dirtyChunks.add(`${cx},${cy + 1}`);
            }

            // Get dirt variant (4x4 grid = 16 variations)
            function getDirtIdx(x, y) {
                // Use position-based pseudo-random for consistent dirt pattern
                const hash = (x * 374761393 + y * 668265263) & 0xffffffff;
                return Math.abs(hash) % 16; // Random dirt tile 0-15
            }

            // Global Texture Cache (from variables.js)

            function getTileTexture(sourceTexture, idx) {
                if (!globalTextureCache.has(sourceTexture)) {
                    globalTextureCache.set(sourceTexture, {});
                }
                const cache = globalTextureCache.get(sourceTexture);

                if (cache[idx]) {
                    return cache[idx];
                }

                const w = sourceTexture.width || 64;
                const h = sourceTexture.height || 64;

                let tileW, tileH, col, row;

                // Smart Layout Detection based on Aspect Ratio
                if (Math.abs(w - h) < 4) { // Tolerance for square
                    // 4x4 Grid (Standard)
                    tileW = w / 4;
                    tileH = h / 4;
                    col = idx % 4;
                    row = Math.floor(idx / 4);
                } else if (w > h) {
                    // Horizontal Strip (16x1)
                    tileW = w / 16;
                    tileH = h;
                    col = idx;
                    row = 0;
                } else {
                    // Vertical Strip (1x16)
                    tileW = w;
                    tileH = h / 16;
                    col = 0;
                    row = idx;
                }

                // In PixiJS v8, create texture from source with frame rectangle
                const tex = new PIXI.Texture({
                    source: sourceTexture.source,
                    frame: new PIXI.Rectangle(col * tileW, row * tileH, tileW, tileH)
                });

                cache[idx] = tex;
                return tex;
            }

            // Load config from tweaker (config.json) and initialize game
            // config defined in variables.js

            // Try to load config.json, then initialize game
            fetch('../config.json')
                .then(res => res.json())
                .then(data => {
                    config = { ...config, ...data };
                    // Config loaded silently
                })
                .catch(() => {
                    // Using default config silently
                })
                .finally(() => {
                    initGame();
                });

            function initGame() {
                // UI Removed per user request
                // Camera, Player, Mouse defined in variables.js

                // DEFAULT SPAWN (0,0) - Overridden by Persistence in simpleStart()
                player.x = 0;
                player.y = 0;

                // Snap camera to player immediately
                camera.x = player.x;
                camera.y = player.y;

                // Resetting critical values if needed
                camera.zoom = config.defaultZoom;
                player.speed = config.playerSpeed;

                // Track hovered tile (Global)
                hoveredTileX = null;
                hoveredTileY = null;

                // Game loop - runs every frame
                app.ticker.add((delta) => {
                    // Update select sprite position every frame
                    if (selectSprite && hoveredTileX !== null && hoveredTileY !== null) {
                        selectSprite.x = hoveredTileX * TILE_SIZE;
                        selectSprite.y = hoveredTileY * TILE_SIZE;
                    }
                });

                // Consolidated mousemove listener - mouse tracking moved to global event
                // and logic moved to main game loop to ensure updates when camera moves

                // Mouse tracking handled globally below
                // Context menu prevention
                app.canvas.addEventListener('contextmenu', (e) => e.preventDefault());



                // Mouse tracking handled globally via specific listeners for logic/visuals

                // SCROLL WHEEL (Hotbar Cycle)
                window.addEventListener('wheel', (e) => {
                    if (!window.UI || !window.UI.setActiveHotbar) return;
                    // Cycle hotbar slots
                    const current = window.UI.activeHotbarSlot || 0;
                    const next = (e.deltaY > 0) ? (current === 0 ? 1 : 0) : (current === 1 ? 0 : 1);
                    window.UI.setActiveHotbar(next);
                });

                // VISUAL INDICATORS (LMB/RMB)
                window.addEventListener('mousedown', (e) => {
                    if (e.button === 0) { // LMB
                        mouse.left = true;
                        const el = document.getElementById('lmb-indicator');
                        if (el) el.style.opacity = '1.0';
                        if (el) el.style.boxShadow = '0 0 10px #00f';
                    }
                    if (e.button === 2) { // RMB
                        mouse.right = true;
                        const el = document.getElementById('rmb-indicator');
                        if (el) el.style.opacity = '1.0';
                        if (el) el.style.boxShadow = '0 0 10px #f00';
                    }
                });

                window.addEventListener('mouseup', (e) => {
                    if (e.button === 0) { // LMB
                        mouse.left = false;
                        const el = document.getElementById('lmb-indicator');
                        if (el) el.style.opacity = '0.2';
                        if (el) el.style.boxShadow = 'none';
                    }
                    if (e.button === 2) { // RMB
                        mouse.right = false;
                        const el = document.getElementById('rmb-indicator');
                        if (el) el.style.opacity = '0.2';
                        if (el) el.style.boxShadow = 'none';
                    }
                });
                let isDragging = false;
                let dragStartX = 0;
                let dragStartY = 0;
                let cameraStartX = 0;
                let cameraStartY = 0;

                app.canvas.addEventListener('mousedown', (e) => {
                    if (isAltPressed && e.button === 0) {
                        isDragging = true;
                        dragStartX = e.clientX;
                        dragStartY = e.clientY;
                        cameraStartX = camera.x;
                        cameraStartY = camera.y;
                        // app.canvas.style.cursor = 'grabbing'; // Removed
                    }
                }, true); // Use capture to run before other handlers

                app.canvas.addEventListener('mousemove', (e) => {
                    if (isDragging && isAltPressed) {
                        const dx = (e.clientX - dragStartX) / camera.zoom;
                        const dy = (e.clientY - dragStartY) / camera.zoom;
                        camera.x = cameraStartX - dx;
                        camera.y = cameraStartY - dy;
                    }
                });

                app.canvas.addEventListener('mouseup', () => {
                    if (isDragging) {
                        isDragging = false;
                        // app.canvas.style.cursor = isAltPressed ? 'grab' : "url('Assets/Image/cursor.png'), auto"; // Removed
                    }
                });

                // Exponential zoom - ONLY in freelook mode
                // Exponential zoom - ONLY in freelook mode (Mouse-Centered)
                app.canvas.addEventListener('wheel', (e) => {
                    if (!isAltPressed) return; // Only zoom when Alt is pressed
                    e.preventDefault();

                    const oldZoom = camera.zoom;
                    const zoomFactor = e.deltaY < 0 ? 1.25 : 0.8;
                    const newZoom = Math.max(config.minZoom, Math.min(config.maxZoom, oldZoom * zoomFactor));

                    // Mouse-centered zoom logic
                    if (newZoom !== oldZoom) {
                        const halfW = app.screen.width / 2;
                        const halfH = app.screen.height / 2;
                        // e.clientX/Y are mostly correct for canvas if full screen
                        const mouseX = e.clientX;
                        const mouseY = e.clientY;

                        // Adjust camera position to keep the point under mouse stationary
                        // Formula: newCam = oldCam + (mousePos - center) * (1/oldZoom - 1/newZoom)
                        camera.x += (mouseX - halfW) * (1 / oldZoom - 1 / newZoom);
                        camera.y += (mouseY - halfH) * (1 / oldZoom - 1 / newZoom);

                        camera.zoom = newZoom;
                    }
                });

                // Garbage Collection: INCREMENTAL (No Lag Spikes)
                // Logic moved to Ticker inside startGameLoop for smoother execution
                /*
                setInterval(() => {
                    // ... old code ...
                }, 5000);
                */

                // Keyboard
                // Keyboard (Global in variables.js)
                // const keys = {};
                // let showGrid = false;
                // let isAltPressed = false; 

                // Activity indicator - track currently pressed keys
                // let pressedKeys = new Set();
                let fadeTimeout = null;

                function updateActivity() {
                    const activity = document.getElementById('activity');
                    if (pressedKeys.size === 0) {
                        // Fade out when no keys pressed
                        activity.classList.remove('flash');
                    } else {
                        // Show all pressed keys with + between them
                        const keyList = Array.from(pressedKeys).join(' + ');
                        activity.textContent = keyList;
                        activity.classList.add('flash');
                    }
                }

                window.addEventListener('keydown', (e) => {
                    keys[e.key.toLowerCase()] = true;

                    // Toggle Alt mode (press Alt to toggle on/off)
                    if (e.key === 'Alt' && !e.repeat) {
                        isAltPressed = !isAltPressed;
                        camera.freelook = isAltPressed;

                        if (isAltPressed) {
                            // Entering freelook
                            app.canvas.style.cursor = 'default'; // Visible cursor for freelook
                            document.getElementById('info').textContent = 'FREELOOK MODE - Drag to pan, Scroll to zoom, Alt to exit';
                        } else {
                            // Exiting freelook - snap camera back to player and reset zoom
                            camera.x = player.x + player.width / 2;
                            camera.y = player.y + player.height / 2;
                            camera.zoom = config.defaultZoom; // Reset to default zoom (2.0)
                            app.canvas.style.cursor = 'none'; // Hide cursor for gameplay
                        }
                        e.preventDefault();
                    }

                    // Add key to pressed set
                    let keyName = e.key;
                    if (keyName === ' ') keyName = 'Space';
                    if (keyName.length === 1) keyName = keyName.toUpperCase();
                    pressedKeys.add(keyName);
                    updateActivity();

                    if (e.key.toLowerCase() === 'g') {
                        showGrid = !showGrid;
                    }
                });

                window.addEventListener('keyup', (e) => {
                    keys[e.key.toLowerCase()] = false;

                    // Remove key from pressed set
                    let keyName = e.key;
                    if (keyName === ' ') keyName = 'Space';
                    if (keyName.length === 1) keyName = keyName.toUpperCase();
                    pressedKeys.delete(keyName);
                    updateActivity();
                });

                // Grass tile mapping (from README)
                const GRASS_MAP = {
                    '0000': 12, // The Void
                    '1000': 15, // Inner Corner - Top Left
                    '0100': 8,  // Inner Corner - Top Right
                    '0010': 0,  // Inner Corner - Bottom Left
                    '0001': 13, // Inner Corner - Bottom Right
                    '1100': 9,  // Horizontal Edge - Ceiling
                    '0011': 3,  // Horizontal Edge - Floor
                    '1010': 11, // Vertical Edge - Right Face
                    '0101': 1,  // Vertical Edge - Left Face
                    '0110': 14, // Diagonal - Forward Slash
                    '1001': 4,  // Diagonal - Back Slash
                    '1110': 7,  // Outer Corner - Bottom Right
                    '1101': 10, // Outer Corner - Bottom Left
                    '1011': 2,  // Outer Corner - Top Right
                    '0111': 5,  // Outer Corner - Top Left
                    '1111': 6   // Full Solid
                };

                function getGrassIdx(x, y) {
                    // Check 4 corners: TL, TR, BL, BR
                    // F (filled/grass) = 1, E (empty/dirt) = 0
                    // Use getTileSafe to avoid triggering chunk fetches
                    const tl = getTileSafe(x, y) === 1 ? '1' : '0';
                    const tr = getTileSafe(x + 1, y) === 1 ? '1' : '0';
                    const bl = getTileSafe(x, y + 1) === 1 ? '1' : '0';
                    const br = getTileSafe(x + 1, y + 1) === 1 ? '1' : '0';
                    const key = tl + tr + bl + br;
                    return GRASS_MAP[key] !== undefined ? GRASS_MAP[key] : 6;
                }

                // Create placeholder texture when image files are missing
                function createPlaceholderTexture(color) {
                    const canvas = document.createElement('canvas');
                    canvas.width = 64; // 4x4 grid of 16x16 tiles
                    canvas.height = 64;
                    const ctx = canvas.getContext('2d');
                    ctx.fillStyle = `#${color.toString(16).padStart(6, '0')}`;
                    ctx.fillRect(0, 0, 64, 64);
                    return PIXI.Texture.from(canvas);
                }



                // Load function with explicit logging
                async function loadAssets() {
                    const loadTexture = async (path, placeholderColor) => {
                        try {
                            const tex = await PIXI.Assets.load(path);
                            tex.source.scaleMode = 'nearest';
                            console.log(`[Assets] Loaded: ${path}`);
                            return tex;
                        } catch (e) {
                            console.warn(`[Assets] Failed: ${path}`, e);
                            return createPlaceholderTexture(placeholderColor);
                        }
                    };

                    const [dirt, grass, water, sand, select, crosshair] = await Promise.all([
                        loadTexture('../Assets/Image/Tile/dirt.png', 0x8B4513),
                        loadTexture('../Assets/Image/Tile/grass.png', 0x228B22),
                        loadTexture('../Assets/Image/Tile/water.png', 0x1E90FF),
                        loadTexture('../Assets/Image/Tile/sand.png', 0xF4A460),
                        PIXI.Assets.load('../Assets/Image/select.png').catch((e) => {
                            console.warn('select.png missing', e);
                            const c = document.createElement('canvas');
                            c.width = 32; c.height = 16;
                            const ctx = c.getContext('2d');
                            ctx.strokeStyle = '#FFF'; ctx.lineWidth = 2; ctx.strokeRect(16, 0, 16, 16);
                            return PIXI.Texture.from(c);
                        }),
                        PIXI.Assets.load('../Assets/Image/crosshair.png').catch(() => {
                            const c = document.createElement('canvas'); c.width = 16; c.height = 16;
                            const ctx = c.getContext('2d'); ctx.fillStyle = '#FFF'; ctx.fillRect(7, 0, 2, 16); ctx.fillRect(0, 7, 16, 2);
                            return PIXI.Texture.from(c);
                        })
                    ]);

                    if (select) select.source.scaleMode = 'nearest';
                    if (crosshair) crosshair.source.scaleMode = 'nearest';

                    return { dirt, grass, water, sand, select, crosshair };
                }

                // Initialize Game
                loadAssets().then((assets) => {
                    const dirtTex = assets.dirt;
                    const grassTex = assets.grass;
                    const waterTex = assets.water;
                    const sandTex = assets.sand;
                    const selectTex = assets.select;
                    const crosshairTex = assets.crosshair;

                    // Setup Block Highlight (using loaded texture)
                    // Assumes horizontal sprite sheet (32x16)
                    const selectTexNormal = new PIXI.Texture({
                        source: selectTex.source,
                        frame: new PIXI.Rectangle(0, 0, TILE_SIZE, TILE_SIZE)
                    });
                    const selectTexPressed = new PIXI.Texture({
                        source: selectTex.source,
                        frame: new PIXI.Rectangle(0, TILE_SIZE, TILE_SIZE, TILE_SIZE)
                    });

                    selectSprite = new PIXI.Sprite(selectTexNormal);
                    selectSprite.width = TILE_SIZE;
                    selectSprite.height = TILE_SIZE;
                    selectSprite.visible = false;
                    selectSprite.zIndex = 1000; // Ensure it's always on top
                    world.addChild(selectSprite);

                    // Setup Crosshair Sprite (REMOVED: Using HTML Follower)
                    /*
                    const crosshairSprite = new PIXI.Sprite(crosshairTex);
                    crosshairSprite.anchor.set(0.5);
                    crosshairSprite.zIndex = 9999; 
                    world.addChild(crosshairSprite);
                    */
                    // Crosshair sprite removed in favor of HTML cursor


                    // Setup Cursor: Using HTML Follower only (Performance)
                    // System cursor hidden via CSS
                    app.canvas.style.cursor = 'none';

                    let cursorSprite = null; // Removed Sprite Logic

                    // Mouse move handler - just track position
                    // Mouse move handler - Extremely Lightweight (Just updates data)
                    window.addEventListener('mousemove', (e) => {
                        mouse.x = e.clientX;
                        mouse.y = e.clientY;
                    });

                    // Synced Cursor: Merged into PixiJS Ticker (The "Engine Heartbeat")
                    // This ensures the cursor updates exactly when the game renders, removing jitter.
                    app.ticker.add(() => {
                        // 1. Cursor handling moved to CSS/HTML


                        // 2. Update World Highlight
                        if (world.scale.x !== 0) {
                            const worldX = (mouse.x - world.x) / world.scale.x;
                            const worldY = (mouse.y - world.y) / world.scale.y;

                            hoveredTileX = Math.floor(worldX / TILE_SIZE);
                            hoveredTileY = Math.floor(worldY / TILE_SIZE);

                            if (selectSprite) {
                                selectSprite.x = hoveredTileX * TILE_SIZE;
                                selectSprite.y = hoveredTileY * TILE_SIZE;
                            }
                        }
                    }, PIXI.UPDATE_PRIORITY.INTERACTION); // High priority update

                    // Mouse down - change to pressed texture & visual indicator
                    window.addEventListener('mousedown', (e) => {
                        if (e.button === 0) {
                            mouse.left = true;
                            // Visual Indicator
                            const el = document.getElementById('lmb-indicator');
                            if (el) el.style.opacity = '1.0';

                            // Change texture if selectSprite is ready
                            if (selectSprite) selectSprite.texture = selectTexPressed;
                        } else if (e.button === 2) {
                            mouse.right = true;
                            const el = document.getElementById('rmb-indicator');
                            if (el) el.style.opacity = '1.0';
                        }
                    });

                    // Mouse up - change back to normal texture & visual indicator
                    window.addEventListener('mouseup', (e) => {
                        if (e.button === 0) {
                            mouse.left = false;
                            const el = document.getElementById('lmb-indicator');
                            if (el) el.style.opacity = '0.2';

                            if (selectSprite) selectSprite.texture = selectTexNormal;
                        } else if (e.button === 2) {
                            mouse.right = false;
                            const el = document.getElementById('rmb-indicator');
                            if (el) el.style.opacity = '0.2';
                        }
                    });


                    // Calculate average colors for LOD rendering
                    function getAverageColor(texture) {
                        const canvas = document.createElement('canvas');
                        const ctx = canvas.getContext('2d');
                        canvas.width = texture.width;
                        canvas.height = texture.height;

                        // Draw texture to canvas
                        const img = texture.source.resource;
                        ctx.drawImage(img, 0, 0);

                        try {
                            // Get pixel data
                            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                            const data = imageData.data;

                            let r = 0, g = 0, b = 0, count = 0;
                            for (let i = 0; i < data.length; i += 4) {
                                // Skip transparent pixels (alpha < 128)
                                if (data[i + 3] >= 128) {
                                    r += data[i];
                                    g += data[i + 1];
                                    b += data[i + 2];
                                    count++;
                                }
                            }

                            if (count > 0) {
                                r = Math.floor(r / count);
                                g = Math.floor(g / count);
                                b = Math.floor(b / count);
                                return (r << 16) | (g << 8) | b; // Return as hex color
                            }
                        } catch (e) {
                            console.warn("LOD Tainting Error (file:// protocol): defaulting color. " + e.message);
                            return 0x888888; // Default Grey
                        }

                        return 0x888888; // Fallback
                    }

                    const avgDirtColor = getAverageColor(dirtTex);
                    const avgGrassColor = getAverageColor(grassTex);


                    // ASYNC Pre-generation (Networked)
                    // Connect to Java Server (We use WebSocket now)

                    // Hide Canvas initially

                    // Hide Canvas initially
                    app.canvas.style.opacity = '0';
                    app.canvas.style.transition = 'opacity 1s';

                    // SIMPLE LOAD STRATEGY (User Request)
                    // 1. Connect to Server
                    // 2. Spawn Randomly
                    // 3. Load Circle Radius (Render Distance)
                    // 4. Start Game Loop

                    app.canvas.style.opacity = '0'; // Fade in effect
                    app.canvas.style.transition = 'opacity 1s';

                    // NEW Loading Screen Logic
                    // simpleStart removed. Logic is now in socket.onopen

                    // Incremental GC State
                    let gcIterator = null;
                    const GC_RADIUS = config.renderDistance + 5; // Reduced from +20 to clear cache faster

                    let lastTime = performance.now();

                    // WRAPPED Game Loop (Started after loading)
                    function startGameLoop() {
                        let lastTime = performance.now();
                        let lastLODState = false; // Track LOD state for threshold crossing

                        app.ticker.add((ticker) => {
                            // Incremental Garbage Collection (Process 20 chunks per frame)
                            if (!gcIterator) gcIterator = chunks.keys();

                            const playerChunkX = Math.round(player.x / TILE_SIZE / CHUNK_SIZE);
                            const playerChunkY = Math.round(player.y / TILE_SIZE / CHUNK_SIZE);

                            let gcCount = 0;
                            while (gcCount < 20) {
                                const next = gcIterator.next();
                                if (next.done) {
                                    gcIterator = chunks.keys(); // Restart
                                    break;
                                }
                                const key = next.value;
                                const [cx, cy] = key.split(',').map(Number);
                                const dist = Math.max(Math.abs(cx - playerChunkX), Math.abs(cy - playerChunkY));

                                // Only delete if REALLY far (GC Radius)
                                if (dist > GC_RADIUS) {
                                    chunks.delete(key);
                                }
                                gcCount++;
                            }

                            // Time Delta
                            const time = performance.now();
                            const dt = Math.min((time - lastTime) / 1000, 0.1);
                            lastTime = time;

                            // Camera movement (WASD)
                            let moveX = 0, moveY = 0;
                            if (keys['a'] || keys['arrowleft']) moveX = -1;
                            if (keys['d'] || keys['arrowright']) moveX = 1;
                            if (keys['w'] || keys['arrowup']) moveY = -1;
                            if (keys['s'] || keys['arrowdown']) moveY = 1;

                            // Normalize diagonal movement
                            if (moveX !== 0 && moveY !== 0) {
                                moveX *= 0.707;
                                moveY *= 0.707;
                            }

                            // Movement logic - Uses hi(delta)
                            if (!isAltPressed) {
                                hi(1); // Delta handled inside or constant? hi() uses player.speed * delta / 60
                                // hi expects delta. Ticker gives it.
                            }
                            // Local Camera Update (Client prediction)
                            camera.x = player.x + player.width / 2;
                            camera.y = player.y + player.height / 2;

                            // Trigger Auto-Save on movement (Debounced)
                            if (keys['w'] || keys['s'] || keys['a'] || keys['d']) {
                                triggerSave();
                            }
                            // In freelook mode, camera is moved by mouse drag only (no WASD)

                            // Update stats (FPS, location, zoom) with null checks
                            const fps = Math.round(app.ticker.FPS || 0);
                            const locX = player ? Math.floor(player.x) : 0;
                            const locY = player ? Math.floor(player.y) : 0;
                            const zoom = camera ? camera.zoom.toFixed(2) : '0.00';
                            const infoElement = document.getElementById('info');
                            if (infoElement) {
                                infoElement.textContent = `FPS: ${fps} | x: ${locX} y: ${locY} | Zoom: ${zoom}x`;
                            }

                            // Update world-mouse interaction every frame (fixes "laggy" highlight on camera move)
                            // Calculate world coordinates from mouse screen position
                            // world.x/y are the screen center offsets? No, world transform is: 
                            // world.x = -camera.x * zoom + screenW/2
                            // mouseScreen = worldPos * zoom + world.x
                            // worldPos = (mouseScreen - world.x) / zoom

                            // Use world.scale.x which is set to camera.zoom in this loop
                            if (world.scale.x !== 0) {
                                const worldX = (mouse.x - world.x) / world.scale.x;
                                const worldY = (mouse.y - world.y) / world.scale.y;

                                hoveredTileX = Math.floor(worldX / TILE_SIZE);
                                hoveredTileY = Math.floor(worldY / TILE_SIZE);
                            }

                            // Update select sprite position to hovered tile
                            if (hoveredTileX !== null && hoveredTileY !== null) {
                                selectSprite.x = hoveredTileX * TILE_SIZE;
                                selectSprite.y = hoveredTileY * TILE_SIZE;
                            }

                            // Handle input (left=break/dirt, right=place/grass)
                            const isInteractable = !isAltPressed && !camera.freelook;

                            // Only allow building in normal mode, not in freelook
                            if ((mouse.left || mouse.right) && isInteractable) {
                                const worldX = Math.floor((mouse.x - world.x) / camera.zoom / TILE_SIZE);
                                const worldY = Math.floor((mouse.y - world.y) / camera.zoom / TILE_SIZE);

                                let actionVal = -1; // -1 = Do Nothing

                                // --- NORMAL MODE (Offhand Removed) ---
                                // LMB -> Active Slot Primary (0)
                                // RMB -> Active Slot Secondary (1)
                                if (mouse.left) actionVal = 0;
                                if (mouse.right) actionVal = 1;

                                if (actionVal !== -1) {
                                    if (mouse.lastX !== undefined && mouse.lastY !== undefined) {
                                        // Bresenham's Line
                                        let x0 = mouse.lastX;
                                        let y0 = mouse.lastY;
                                        const x1 = worldX;
                                        const y1 = worldY;
                                        const dx = Math.abs(x1 - x0);
                                        const dy = Math.abs(y1 - y0);
                                        const sx = (x0 < x1) ? 1 : -1;
                                        const sy = (y0 < y1) ? 1 : -1;
                                        let err = dx - dy;

                                        while (true) {
                                            setTile(x0, y0, actionVal);
                                            if (x0 === x1 && y0 === y1) break;
                                            const e2 = 2 * err;
                                            if (e2 > -dy) { err -= dy; x0 += sx; }
                                            if (e2 < dx) { err += dx; y0 += sy; }
                                        }
                                    } else {
                                        setTile(worldX, worldY, actionVal);
                                    }

                                    mouse.lastX = worldX;
                                    mouse.lastY = worldY;
                                    triggerSave();
                                }
                            } else {
                                // Reset last position if not clicking
                                mouse.lastX = undefined;
                                mouse.lastY = undefined;
                            }

                            // Hide selection sprite in freelook mode
                            if (selectSprite) {
                                selectSprite.visible = isInteractable && hoveredTileX !== null && hoveredTileY !== null;
                            }

                            render();
                            renderOverlays();


                            // Transform world (camera system - center camera position on screen)
                            // Reverted rounding to fix diagonal movement feel
                            world.scale.set(camera.zoom);
                            world.x = Math.round(-camera.x * camera.zoom + app.screen.width / 2);
                            world.y = Math.round(-camera.y * camera.zoom + app.screen.height / 2);

                            // Crosshair Position Update Removed


                            // Cursor is now updated in 'mousemove' listener for zero latency.
                            // Removed game loop update to prevent fighting/jitter.

                            // Process Dirty Chunks (Batch Rendering)
                            // Process Dirty Chunks (Batch Rendering) - With Distance Culling to prevent autogen loop
                            if (dirtyChunks.size > 0 && renderChunk) {
                                // SNAPSHOT: Create array copy and clear Set immediately.
                                // This prevents infinite loops where rendering adds new dirty chunks during the same frame.
                                const batch = Array.from(dirtyChunks);
                                dirtyChunks.clear();

                                // Calculate center chunk for culling
                                const centerCX = Math.floor(camera.x / TILE_SIZE / CHUNK_SIZE);
                                const centerCY = Math.floor(camera.y / TILE_SIZE / CHUNK_SIZE);
                                const renderCap = config.renderDistance + 4; // Allow small buffer

                                for (const key of batch) {
                                    const [cx, cy] = key.split(',').map(Number);

                                    // SAFETY: Skip rendering if too far (Prevents infinite generation loop)
                                    if (Math.abs(cx - centerCX) > renderCap || Math.abs(cy - centerCY) > renderCap) {
                                        continue;
                                    }

                                    // Remove old container FIRST
                                    if (chunkContainers.has(key)) {
                                        const containers = chunkContainers.get(key);
                                        if (containers.dirt) {
                                            dirtLayer.removeChild(containers.dirt);
                                            containers.dirt.destroy({ children: true });
                                        }
                                        if (containers.grass) {
                                            grassLayer.removeChild(containers.grass);
                                            containers.grass.destroy({ children: true });
                                        }
                                        chunkContainers.delete(key);
                                    }
                                    // Re-render
                                    renderChunk(cx, cy);
                                }
                            }


                            // Render function - chunk-based with caching

                            // Chunk Rendering Function - assign to outer scope variable
                            // Renamed to rchunks per user request
                            function rchunks(cx, cy) {
                                window.rchunks = rchunks; // Global alias
                                const key = `${cx},${cy}`;

                                // Check if chunk data exists. If not, request it and skip this frame
                                if (!chunks.has(key)) {
                                    // Request from Server (Via Socket)
                                    requestChunk(cx, cy);
                                    return; // Will render next frame when data arrives
                                }

                                // CLEANUP: Remove old container if it exists (Fixes duplicate rendering)
                                if (chunkContainers.has(key)) {
                                    const containers = chunkContainers.get(key);
                                    if (containers.dirt) {
                                        dirtLayer.removeChild(containers.dirt);
                                        containers.dirt.destroy({ children: true });
                                    }
                                    if (containers.grass) {
                                        grassLayer.removeChild(containers.grass);
                                        containers.grass.destroy({ children: true });
                                    }
                                    chunkContainers.delete(key);
                                }

                                const chunk = getChunk(cx, cy);
                                const chunkDirt = new PIXI.Container();
                                const chunkGrass = new PIXI.Container();

                                // LOD: If zoomed out below threshold, render simple colored tiles (Minimap style)
                                if (camera.zoom < config.lodThreshold) {
                                    const graphics = new PIXI.Graphics();

                                    // Draw each tile as a simple colored rectangle
                                    for (let ty = 0; ty < CHUNK_SIZE; ty++) {
                                        for (let tx = 0; tx < CHUNK_SIZE; tx++) {
                                            const tileVal = chunk[ty][tx];
                                            const color = tileVal === 1 ? avgGrassColor : avgDirtColor;

                                            graphics.beginFill(color);
                                            graphics.drawRect(
                                                (cx * CHUNK_SIZE + tx) * TILE_SIZE,
                                                (cy * CHUNK_SIZE + ty) * TILE_SIZE,
                                                TILE_SIZE,
                                                TILE_SIZE
                                            );
                                            graphics.endFill();
                                        }
                                    }

                                    chunkDirt.addChild(graphics);
                                    chunkContainers.set(key, { dirt: chunkDirt, grass: chunkGrass });

                                    dirtLayer.addChild(chunkDirt);

                                    return;
                                }

                                // Render all tiles in this chunk
                                for (let ty = 0; ty < CHUNK_SIZE; ty++) {
                                    for (let tx = 0; tx < CHUNK_SIZE; tx++) {
                                        const worldX = cx * CHUNK_SIZE + tx;
                                        const worldY = cy * CHUNK_SIZE + ty;
                                        const tileVal = getTileSafe(worldX, worldY);

                                        // Simple Biome Rendering (No dual-grid for now, just tiles)
                                        let tex = null;
                                        let layer = dirtLayer;

                                        // IDs: 0=Dirt, 1=Ocean/Water, 2=Grass, 3=Sand
                                        if (tileVal === 1) {
                                            tex = waterTex;
                                        } else if (tileVal === 3) {
                                            tex = sandTex;
                                        } else if (tileVal === 0) {
                                            tex = dirtTex;
                                        } else if (tileVal === 2) {
                                            tex = grassTex;
                                            layer = grassLayer;
                                        }

                                        if (tex) {
                                            const sprite = new PIXI.Sprite(tex);
                                            sprite.x = worldX * TILE_SIZE;
                                            sprite.y = worldY * TILE_SIZE;
                                            sprite.width = TILE_SIZE;
                                            sprite.height = TILE_SIZE;

                                            // For Grass (Dual Grid), we might need special logic, 
                                            // but for now, simple tile rendering to verify biomes.
                                            // Only use Dual Grid logic if user explicitly demands it for this verification step.
                                            // User said "all images except for dirt... is in dual gridding format".
                                            // This suggests standard tile rendering might fail visually for Grass/Sand/Water.
                                            // But we need to see *something* first.

                                            layer.addChild(sprite);
                                        }
                                    }
                                }

                                chunkContainers.set(key, { dirt: chunkDirt, grass: chunkGrass });
                                dirtLayer.addChild(chunkDirt);
                                grassLayer.addChild(chunkGrass);
                            }

                            function render() {
                                // Skip if rchunks not ready yet
                                if (!rchunks) return;

                                // Reset chunk count each frame
                                chunksRendered = 0;

                                // Check if we crossed LOD threshold
                                const currentLODState = camera.zoom < config.lodThreshold;
                                if (lastLODState !== currentLODState) {
                                    // Clear all chunks when crossing LOD threshold
                                    for (const [key, containers] of chunkContainers.entries()) {
                                        if (containers.dirt) {
                                            dirtLayer.removeChild(containers.dirt);
                                            containers.dirt.destroy();
                                        }
                                        if (containers.grass) {
                                            grassLayer.removeChild(containers.grass);
                                            containers.grass.destroy();
                                        }
                                    }
                                    chunkContainers.clear();
                                    lastLODState = currentLODState;
                                }

                                // AGGRESSIVE GC: Prevent memory leaks
                                if (chunks.size > 1000) {
                                    // Calculate player chunk position for GC
                                    const playerChunkX = Math.floor(player.x / TILE_SIZE / CHUNK_SIZE);
                                    const playerChunkY = Math.floor(player.y / TILE_SIZE / CHUNK_SIZE);
                                    const renderDistance = config.renderDistance;

                                    // Force cleanup of ANY chunk outside view + buffer
                                    for (const key of chunks.keys()) {
                                        const [cx, cy] = key.split(',').map(Number);
                                        if (Math.abs(cx - playerChunkX) > renderDistance + 2 ||
                                            Math.abs(cy - playerChunkY) > renderDistance + 2) {
                                            chunks.delete(key);
                                        }
                                    }
                                }

                                // Calculate visible bounds based on viewport
                                const viewHalfW = (app.screen.width / camera.zoom) / 2;
                                const viewHalfH = (app.screen.height / camera.zoom) / 2;

                                // Convert to chunk coordinates - limit to render distance from config
                                const maxRenderDist = Math.min(config.renderDistance, 32); // Increased cap for Infinite World feel

                                // Calculate viewport-based chunk range
                                // Increased pad (2 chunks) to prevent clipping of edge sprites (Dual Grid)
                                let startChunkX = Math.floor((camera.x - viewHalfW) / (TILE_SIZE * CHUNK_SIZE)) - 2;
                                let endChunkX = Math.ceil((camera.x + viewHalfW) / (TILE_SIZE * CHUNK_SIZE)) + 2;
                                let startChunkY = Math.floor((camera.y - viewHalfH) / (TILE_SIZE * CHUNK_SIZE)) - 2;
                                let endChunkY = Math.ceil((camera.y + viewHalfH) / (TILE_SIZE * CHUNK_SIZE)) + 2;

                                // Also limit by render distance from player chunk
                                const playerChunkXCenter = Math.floor(player.x / TILE_SIZE / CHUNK_SIZE);
                                const playerChunkYCenter = Math.floor(player.y / TILE_SIZE / CHUNK_SIZE);
                                startChunkX = Math.max(startChunkX, playerChunkXCenter - maxRenderDist);
                                endChunkX = Math.min(endChunkX, playerChunkXCenter + maxRenderDist);
                                startChunkY = Math.max(startChunkY, playerChunkYCenter - maxRenderDist);
                                endChunkY = Math.min(endChunkY, playerChunkYCenter + maxRenderDist);

                                // Determine which chunks should be visible
                                const chunksToRender = new Set();
                                for (let cy = startChunkY; cy <= endChunkY; cy++) {
                                    for (let cx = startChunkX; cx <= endChunkX; cx++) {
                                        chunksToRender.add(`${cx},${cy}`);
                                    }
                                }

                                // Remove chunks that are out of range
                                for (const [key, containers] of chunkContainers.entries()) {
                                    if (!chunksToRender.has(key)) {
                                        if (containers.dirt) {
                                            dirtLayer.removeChild(containers.dirt);
                                            containers.dirt.destroy({ children: true });
                                        }
                                        if (containers.grass) {
                                            grassLayer.removeChild(containers.grass);
                                            containers.grass.destroy({ children: true });
                                        }
                                        chunkContainers.delete(key);
                                    }
                                }

                                // Render new chunks (only if not already rendered)
                                // Time Slicing Scale: More chunks if zoomed out
                                const MAX_CHUNKS_PER_FRAME = config.maxChunksPerFrame || 10;
                                let chunksCreated = 0;

                                // Loop through chunks (standard scanline order: top-to-bottom)
                                for (const key of chunksToRender) {
                                    if (!chunkContainers.has(key)) {
                                        if (chunksCreated < MAX_CHUNKS_PER_FRAME) {
                                            const [cx, cy] = key.split(',').map(Number);
                                            rchunks(cx, cy);
                                            chunksCreated++;
                                        }
                                        // If we hit limit, we just stop creating for this frame. 
                                        // They will be picked up next frame.
                                    }
                                    chunksRendered++;
                                }

                                // Update stats - Cached and Rendered (no Loading indicator)
                                const fps = Math.round(app.ticker.FPS);
                                const activeChunks = chunkContainers.size;
                                const cachedChunks = chunks.size;
                                document.getElementById('info').textContent = `FPS: ${fps} | x: ${Math.floor(player.x)} y: ${Math.floor(player.y)} | Zoom: ${camera.zoom.toFixed(2)}x | Rendered: ${activeChunks} | Cached: ${cachedChunks}`;


                            } // End render

                            // Update Grid Positions
                            if (typeof renderOverlays === 'function') renderOverlays();
                        });
                    } // End startGameLoop

                    // Render overlays (grid, highlights, etc) - called after chunk rendering
                    let overlayGraphics = null;

                    function renderOverlays() {
                        // Skip overlay rendering entirely if grid is disabled (massive performance boost)
                        if (!showGrid) {
                            if (overlayGraphics) {
                                world.removeChild(overlayGraphics);
                                overlayGraphics.destroy();
                                overlayGraphics = null;
                            }
                            if (window.gridRed) window.gridRed.visible = false;
                            if (window.gridWhite) window.gridWhite.visible = false;
                            return; // Exit function
                        }

                        // reuse graphics   
                        if (overlayGraphics) {
                            overlayGraphics.clear();
                        } else {
                            overlayGraphics = new PIXI.Graphics();
                        }

                        // Calculate visible area
                        const playerChunkX = Math.round(player.x / TILE_SIZE / CHUNK_SIZE);
                        const playerChunkY = Math.round(player.y / TILE_SIZE / CHUNK_SIZE);
                        const renderDistance = Math.min(5, Math.ceil(5 / Math.max(camera.zoom, 1.0)));
                        const startX = (playerChunkX - renderDistance) * CHUNK_SIZE;
                        const endX = (playerChunkX + renderDistance + 1) * CHUNK_SIZE;
                        const startY = (playerChunkY - renderDistance) * CHUNK_SIZE;
                        const endY = (playerChunkY + renderDistance + 1) * CHUNK_SIZE;


                        /* BLOCK GRID REMOVED (User Request) */
                        if (window.gridRed) window.gridRed.visible = false;
                        if (window.gridWhite) window.gridWhite.visible = false;


                        /* GREEN HIGHLIGHT LOOP REMOVED (Performance Optimization) */

                        // 2. Blue chunk boundaries
                        overlayGraphics.lineStyle(2, 0x0000ff, 0.5);
                        const chunkStartX = Math.floor(startX / CHUNK_SIZE) * CHUNK_SIZE;
                        const chunkEndX = Math.ceil(endX / CHUNK_SIZE) * CHUNK_SIZE;
                        const chunkStartY = Math.floor(startY / CHUNK_SIZE) * CHUNK_SIZE;
                        const chunkEndY = Math.ceil(endY / CHUNK_SIZE) * CHUNK_SIZE;

                        for (let x = chunkStartX; x <= chunkEndX; x += CHUNK_SIZE) {
                            overlayGraphics.moveTo(x * TILE_SIZE, chunkStartY * TILE_SIZE);
                            overlayGraphics.lineTo(x * TILE_SIZE, chunkEndY * TILE_SIZE);
                        }
                        for (let y = chunkStartY; y <= chunkEndY; y += CHUNK_SIZE) {
                            overlayGraphics.moveTo(chunkStartX * TILE_SIZE, y * TILE_SIZE);
                            overlayGraphics.lineTo(chunkEndX * TILE_SIZE, y * TILE_SIZE);
                        }
                        overlayGraphics.stroke();

                        overlayGraphics.zIndex = 2002;
                        world.addChild(overlayGraphics);
                    } // End renderOverlays


                    // HTML Cursor Logic (Simple Follower)
                    const follower = document.getElementById("follower-element");
                    window.addEventListener('mousemove', (event) => {
                        const clientX = event.clientX;
                        const clientY = event.clientY;
                        follower.style.left = `${clientX}px`;
                        follower.style.top = `${clientY}px`;
                    });


                    // CHUNK FETCHER INTEGRATION (Background Network Thread)
                    // This background thread just DOWNLOADS data from Java. It does not generate it.
                    // New Request Logic: Uses persistent WebSocket Connection
                    // Replaces the old Worker/HTTP method to fix "stuck" loading (browser connection limits)
                    function requestChunk(cx, cy) {
                        const key = `${cx},${cy}`;
                        if (pendingChunks.has(key) || chunks.has(key)) return;

                        if (socket && socket.readyState === WebSocket.OPEN) {
                            pendingChunks.add(key);
                            socket.send(JSON.stringify({
                                type: 'getChunk',
                                key: key
                            }));
                        }
                    }

                    // Save World Function
                    // Save World Function (Auto-Save Optimized)
                    async function saveWorld() {
                        if (!socket || socket.readyState !== WebSocket.OPEN) {
                            console.warn("Cannot save: WS not connected");
                            alert("Cannot save: Server Disconnected");
                            return;
                        }

                        const saveData = {
                            type: "save",
                            player: {
                                x: player.x,
                                y: player.y
                            },
                            chunks: []
                        };

                        // Gather Modified Chunks
                        if (modifiedChunks.size > 0) {
                            for (const key of modifiedChunks) {
                                if (chunks.has(key)) {
                                    const chunk = chunks.get(key);
                                    // Flatten
                                    let dataStr = '';
                                    for (let y = 0; y < CHUNK_SIZE; y++) {
                                        for (let x = 0; x < CHUNK_SIZE; x++) {
                                            dataStr += chunk[y][x];
                                        }
                                    }
                                    saveData.chunks.push({
                                        key: key,
                                        data: dataStr
                                    });
                                }
                            }
                        }

                        // Needed for the specific manual parser on server which expects a flat list sometimes or specific keys?
                        // The server parser looks for "key":"..." then "data":"..." repeatedly.
                        // JSON.stringify will produce `... "chunks":[{"key":"...", "data":"..."}, ...] ...`
                        // My robust parser in Java (the loop) should handle this standard JSON array format fine 
                        // because it searches for "key": and "data": sequentially.

                        // console.log("Sending Save via WebSocket...");
                        sendJson(saveData);

                        // Clear modified set locally (optimistic)
                        modifiedChunks.clear();

                        const btn = document.getElementById('saveBtn');
                        if (btn) btn.innerText = "Saving...";
                    }

                    async function persistDB() {
                        // DB REMOVED
                    }



                    // Start Game Loop (Refactored)
                    // startgl removed to avoid duplicate tickers. Using startGameLoop.

                    // Expose globally for WS callback
                    window.startGameLoop = startGameLoop; // Start from initMP using this alias

                    // Event-Driven Auto-Save Logic
                    let saveTimeout = null;
                    const SAVE_DELAY = 2000; // 2 seconds of inactivity before saving player position

                    function triggerSave() {
                        // If already saving, ignore or debounce?
                        // Simple debounce: reset timer
                        if (saveTimeout) clearTimeout(saveTimeout);
                        saveTimeout = setTimeout(() => {
                            saveWorld();
                            saveTimeout = null;
                        }, SAVE_DELAY);
                    }


                    // Start the game logic now that workers and textures are ready
                    // Start the networking first, game start happens on WS Open
                    initMP();

                }); // End Promise.all().then()
            } // End initGame

            // --- WebSocket Multiplayer Logic ---
            let socket;
            const otherPlayers = new Map(); // id -> {x, y, sprite}

            function lerp(start, end, amt) {
                return (1 - amt) * start + amt * end;
            }

            // reqChunk removed (duplicate)

            function initMP() {
                if (socket && (socket.readyState === WebSocket.OPEN || socket.readyState === WebSocket.CONNECTING)) {
                    console.log("[WS] Socket already active");
                    return;
                }
                try {
                    const wsPort = parseInt(location.port) + 1;
                    socket = new WebSocket(`ws://${location.hostname}:${wsPort}`);
                    window.socket = socket; // Make socket globally accessible for getChunk

                    socket.onopen = () => {
                        console.log("[WS] Connected to Multiplayer Server");

                        // INLINED Loading Screen Logic (No simpleStart function)
                        const overlay = document.getElementById('loading-overlay');
                        if (overlay) {
                            overlay.style.opacity = '0';
                            setTimeout(() => overlay.style.display = 'none', 1000);
                        }

                        app.canvas.style.opacity = '1';
                        // Start Loop Immediately - No Preloading
                        startGameLoop();
                    };

                    socket.onerror = (err) => {
                        console.error("[WS] Connection Error", err);
                        const overlay = document.getElementById('loading-overlay');
                        if (overlay) {
                            overlay.style.color = "#ff5555"; // Red
                            overlay.innerHTML = "Connection Failed!<br>Is the Server Running?";
                        }
                    };

                    socket.onclose = (event) => {
                        console.log("[WS] Connection Closed", event);
                        if (!event.wasClean) {
                            const overlay = document.getElementById('loading-overlay');
                            if (overlay) {
                                overlay.style.color = "#ff5555";
                                overlay.innerHTML = "Disconnected from Server.<br>Please Refresh.";
                                overlay.style.opacity = '1';
                                overlay.style.display = 'flex';
                            }
                        }
                    };

                    socket.onmessage = (event) => {
                        const msg = event.data;
                        try {
                            const data = JSON.parse(msg);

                            // 1. Position Update
                            if (data.type === 'pos') {
                                if (data.id === myId) return; // FIXED: Ignore own player
                                updRemote(data.id, data.x, data.y);
                            }
                            // 2. Chunk Data Received
                            else if (data.type === 'chunk') {
                                // console.log(`[WS] Loaded Chunk: ${data.key}`); // LOG REMOVED
                                const key = data.key;
                                const rawData = data.data; // Now "[1,0,2,...]" or legacy "102..."

                                // Parse Data
                                const chunk2D = [];
                                let flatData = [];

                                if (rawData.startsWith('[')) {
                                    // New JSON Array Format
                                    try {
                                        flatData = JSON.parse(rawData);
                                    } catch (e) {
                                        console.error("Failed to parse chunk data", e);
                                        return;
                                    }
                                } else {
                                    // Legacy String Format (Backup)
                                    flatData = rawData.split('').map(c => parseInt(c));
                                }

                                for (let y = 0; y < CHUNK_SIZE; y++) {
                                    chunk2D[y] = [];
                                    for (let x = 0; x < CHUNK_SIZE; x++) {
                                        chunk2D[y][x] = flatData[y * CHUNK_SIZE + x] || 0;
                                    }
                                }

                                chunks.set(key, chunk2D);
                                if (typeof pendingChunks !== 'undefined') pendingChunks.delete(key);

                                // Re-use logic for dirtying
                                const [cx, cy] = key.split(',').map(Number);
                                if (typeof dirtyChunks !== 'undefined') {
                                    dirtyChunks.add(key);
                                    dirtyChunks.add(`${cx - 1},${cy}`);
                                    dirtyChunks.add(`${cx + 1},${cy}`);
                                    dirtyChunks.add(`${cx},${cy - 1}`);
                                    dirtyChunks.add(`${cx},${cy + 1}`);
                                }

                                // Force Re-Render of this chunk if near
                                // (The main loop will pick it up on next frame automatically)
                            }
                            // 3. Save Acknowledgement
                            else if (data.type === 'saveAck') {
                                console.log("[WS] Save Successful! Chunks saved:", data.count);
                                // Update UI if needed
                                const btn = document.getElementById('saveBtn');
                                if (btn) {
                                    btn.innerText = "Saved!";
                                    setTimeout(() => btn.innerText = "Save Game", 2000);
                                }
                            }
                            // 4. Block Update (from self or others)
                            else if (data.type === 'setBlock') {
                                // Update local cache
                                // {x: 10, y: 20, val: 1}
                                if (data.id === myId) return; // Ignore own echo to prevent double-render/lag

                                const bx = parseInt(data.x);
                                const by = parseInt(data.y);
                                const bval = parseInt(data.val);

                                // Update directly to avoid recursive loop with setTile sending packet again
                                const bcx = Math.floor(bx / CHUNK_SIZE);
                                const bcy = Math.floor(by / CHUNK_SIZE);
                                const btx = ((bx % CHUNK_SIZE) + CHUNK_SIZE) % CHUNK_SIZE;
                                const bty = ((by % CHUNK_SIZE) + CHUNK_SIZE) % CHUNK_SIZE;

                                const chunk = chunks.get(`${bcx},${bcy}`);
                                if (chunk) {
                                    chunk[bty][btx] = bval;

                                    // Dirty Chunk for Render
                                    const bKey = `${bcx},${bcy}`;
                                    dirtyChunks.add(bKey);

                                    // Dirty Neighbors for Auto-tiling
                                    if (btx === 0) dirtyChunks.add(`${bcx - 1},${bcy}`);
                                    if (btx === CHUNK_SIZE - 1) dirtyChunks.add(`${bcx + 1},${bcy}`);
                                    if (bty === 0) dirtyChunks.add(`${bcx},${bcy - 1}`);
                                    if (bty === CHUNK_SIZE - 1) dirtyChunks.add(`${bcx},${bcy + 1}`);
                                }
                            }

                        } catch (e) {
                            console.warn("WS Parse Error", e);
                        }
                    };

                    socket.onclose = () => {
                        console.log("[WS] Disconnected. Retrying in 5s...");
                        setTimeout(initMP, 5000);
                    };

                } catch (e) {
                    console.error("[WS] Connection Failed", e);
                }
            }

            function sendJson(data) {
                if (socket && socket.readyState === WebSocket.OPEN) {
                    socket.send(JSON.stringify(data));
                }
            }

            // Generate a simple ID for this session
            const myId = Date.now().toString();

            function updRemote(id, x, y) {
                if (!world) return;

                let p = otherPlayers.get(id);
                if (!p) {
                    // Create new sprite for other player
                    const graphics = new PIXI.Graphics();
                    // RED SQUARE REMOVED (User Request)
                    /*
                    graphics.beginFill(0xFF0000); // Red for other players
                    graphics.drawRect(0, 0, 16, 16);
                    graphics.endFill();
                    */

                    p = { sprite: graphics, targetX: x, targetY: y };
                    p.sprite.x = x;
                    p.sprite.y = y;
                    p.sprite.zIndex = 100;

                    world.addChild(p.sprite);
                    otherPlayers.set(id, p);
                }

                // Update target for interpolation
                p.targetX = x;
                p.targetY = y;
                // Instant snap for now, or lerp in ticker?
                p.sprite.x = x;
                p.sprite.y = y;
            }

            // Start Multiplayer
            // setTimeout(initMultiplayer, 1000); // REMOVED: Called explicitly in Promise chain

            // Broadcast loop
            setInterval(() => {
                if (socket && socket.readyState === WebSocket.OPEN && player) {
                    const payload = JSON.stringify({
                        type: 'pos',
                        id: myId,
                        x: player.x,
                        y: player.y
                    });
                    socket.send(payload);
                }
            }, 50); // 20 times per second

        }); // End window.addEventListener

        // Initialize (One-time save on close?)
        window.addEventListener('beforeunload', () => {
            // Try to fire a beacon or sync save? HARD to do reliably.
            // Rely on the frequent triggers.
        });

        // UI INITIALIZATION REMOVED
        // Only essential logic remains in index.html, UI is now in ui.html
    </script>
</body>

</html>