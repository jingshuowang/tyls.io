<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8">
    <title>tyls.io</title>
    <link rel="icon" href="data:,">
    <style>
        @font-face {
            font-family: 'Minecraft';
            src: url('../Assets/Font/pixel.ttf') format('truetype');
        }

        body {
            margin: 0;
            overflow: hidden;
            background: #000;
        }

        canvas {
            display: block;
            image-rendering: pixelated;
            image-rendering: crisp-edges;
            cursor: none;
            /* Hide default/CSS cursor for Software Cursor */
        }

        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            color: #ffffff;
            font-family: 'Minecraft', monospace;
            font-size: 16px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
            pointer-events: none;
            z-index: 100;
        }

        #activity {
            position: absolute;
            top: 10px;
            right: 10px;
            color: #ffffff;
            font-family: 'Minecraft', monospace;
            font-size: 20px;
            font-weight: bold;
            text-shadow: 0 0 5px rgba(255, 255, 255, 0.5);
            opacity: 0;
            transition: opacity 0.2s;
            pointer-events: none;
        }

        #activity.flash {
            opacity: 1;
        }

        /* Custom HTML Cursor */
        /* Custom HTML Cursor */
        #follower-element {
            width: 32px;
            height: 32px;
            background-image: url('../Assets/Image/cursor.png');
            background-size: contain;
            background-repeat: no-repeat;
            position: fixed;
            transform: translate(-50%, -50%);
            /* Center? Usually cursors are top-left... let's keep top-left */
            /* transform: translate(0, 0); */
            pointer-events: none;
            z-index: 10000;
            image-rendering: pixelated;
        }

        /* Force Hide System Cursor Globally */
        * {
            cursor: none !important;
        }
    </style>
</head>

<body>
    <div id="info"></div>
    <div id="activity"></div>
    <div id="follower-element"></div>

    <!-- Save Button -->
    <button id="saveBtn" style="
        position: fixed;
        bottom: 20px;
        right: 20px;
        padding: 12px 24px;
        font-family: 'Minecraft', monospace;
        font-size: 16px;
        background: linear-gradient(180deg, #5a5 0%, #383 100%);
        border: 3px solid #2a2;
        color: white;
        cursor: pointer;
        z-index: 1000;
        text-shadow: 2px 2px 0 #000;
        box-shadow: 0 4px 0 #151;
        transition: all 0.1s;
    " onmousedown="this.style.transform='translateY(2px)';this.style.boxShadow='0 2px 0 #151'"
        onmouseup="this.style.transform='';this.style.boxShadow='0 4px 0 #151'"
        onmouseleave="this.style.transform='';this.style.boxShadow='0 4px 0 #151'">
        [SAVE]
    </button>

    <div id="saveStatus" style="
        position: fixed;
        bottom: 70px;
        right: 20px;
        padding: 8px 16px;
        font-family: 'Minecraft', monospace;
        font-size: 14px;
        background: rgba(0,0,0,0.7);
        color: #aaa;
        z-index: 1000;
        display: none;
        border-radius: 4px;
    "></div>

    <div id="loading"
        style="position:fixed;top:0;left:0;width:100%;height:100%;background:#000;z-index:9999;display:flex;justify-content:center;align-items:center;color:white;font-family:monospace;transition:opacity 0.5s;">
        <h1 style="font-size:32px;">Connecting...</h1>
    </div>

    <script>
        window.onerror = function (msg, url, line, col, error) {
            const div = document.createElement('div');
            div.style.position = 'fixed';
            div.style.top = '50%';
            div.style.left = '50%';
            div.style.transform = 'translate(-50%, -50%)';
            div.style.background = 'rgba(255,0,0,0.8)';
            div.style.color = 'white';
            div.style.padding = '20px';
            div.style.border = '2px solid white';
            div.style.zIndex = '99999';
            div.style.fontFamily = 'monospace';
            div.innerText = `CRITICAL ERROR:\n${msg}\nLine: ${line}`;
            document.body.appendChild(div);
            return false;
        };
    </script>
    <script src="https://cdn.jsdelivr.net/npm/pixi.js@8.5.2/dist/pixi.min.js"></script>
    <script>
        // --- INLINED VARIABLES (Formerly variables.js) ---
        // Game Constants
        const TILE_SIZE = 16;
        const CHUNK_SIZE = 16;
        const SERVER_URL = 'http://localhost:25565';

        // Configuration (Overridden by config.json)
        let config = {
            playerSpeed: 200,
            defaultZoom: 3.0,
            minZoom: 0.25,
            maxZoom: 10,
            chunkSize: 16,
            renderDistance: 5,
            lodThreshold: 0.8,
            maxChunksPerFrame: 10
        };

        // Game State
        const chunks = new Map();
        const chunkContainers = new Map();
        const dirtyChunks = new Set();
        const pendingChunks = new Set();
        const modifiedChunks = new Set(); // Track chunks modified by player for saving
        let chunksRendered = 0;

        // Entities
        const camera = { x: 0, y: 0, zoom: 3.0, freelook: false };
        const player = { x: 128, y: 128, width: 16, height: 16, speed: 200 };
        const mouse = { x: 0, y: 0, left: false, right: false, lastX: undefined, lastY: undefined };

        // Interaction
        let isAltPressed = false;
        let showGrid = false;
        let hoveredTileX = null;
        let hoveredTileY = null;
        let selectSprite = null;

        // Input
        const keys = {};
        let pressedKeys = new Set();
        const globalTextureCache = new Map();

        // Globals
        let app, world, dirtLayer, grassLayer, renderChunk = null;
    </script>
    <script>
        // Wait for PixiJS to load
        window.addEventListener('load', async () => {



            // Settings
            // Settings (Loaded from variables.js)



            // Global PixiJS Settings for Pixel Art
            PIXI.TextureSource.defaultOptions.scaleMode = 'nearest';

            // PixiJS App (v8 requires await)
            // PixiJS App (using global 'app' from variables.js)
            app = new PIXI.Application();
            await app.init({
                width: window.innerWidth,
                height: window.innerHeight,
                backgroundColor: 0x1a1a1a,
                antialias: false,
                roundPixels: true,  // Pixel-perfect rendering
                preference: 'maximum-performance', // Hint to browser
                powerPreference: 'high-performance'
            });
            // Attempt to uncap FPS (0 = uncapped / monitor limit)
            app.ticker.maxFPS = 0;
            document.body.appendChild(app.canvas);

            // Resize canvas to fill screen (fixes black bar at top)
            function resizeCanvas() {
                app.renderer.resize(window.innerWidth, window.innerHeight);
            }
            window.addEventListener('resize', resizeCanvas);
            resizeCanvas(); // Call once to ensure proper size

            // Pixel-perfect (v8 compatible)
            // FPS Uncapped (User requested)



            // World container
            // World container (global 'world')
            world = new PIXI.Container();
            world.sortableChildren = true; // Enable z-index sorting for world (tiles/players)
            app.stage.sortableChildren = true; // Enable z-index sorting for stage (UI/Crosshair)
            app.stage.addChild(world);

            // Layers for Z-sorting (Fixes "cutoff" grass/half tiles)
            // Layers for Z-sorting (global 'dirtLayer', 'grassLayer')
            dirtLayer = new PIXI.Container();
            grassLayer = new PIXI.Container();
            world.addChild(dirtLayer);
            world.addChild(grassLayer);

            // Track hovered tile position (Global from variables.js)
            // let hoveredTileX = null;
            // let hoveredTileY = null;

            // Mouse tracking


            // NOTE: selectSprite and event handlers moved inside Promise.all().then() to ensure texture is loaded


            // Chunk-based world data
            // RENDER_DISTANCE now comes from config.renderDistance
            // Chunk-based world data (Global from variables.js)
            // const chunks = new Map(); 
            // const chunkContainers = new Map();
            // const dirtyChunks = new Set();
            // let chunksRendered = 0;

            // renderChunk function reference (defined below, declared in variables.js)
            // let renderChunk = null; (Global)

            // Simple Perlin-like noise REMOVED (Legacy, Server handles generation now)

            // Chunk Management (Client Cache)
            // Data is fetched from Server, stored here
            // chunks map is global.


            // Track pending requests (Global from variables.js)
            // const pendingChunks = new Set();

            async function fetchChunk(cx, cy) {
                const key = `${cx},${cy}`;
                if (chunks.has(key) || pendingChunks.has(key)) return;

                pendingChunks.add(key);
                try {
                    const res = await fetch(`http://localhost:25565/chunk?x=${cx}&y=${cy}`);
                    if (res.ok) {
                        // JSON Response is a String: "1010\n0101..."
                        // We need to parse this back to 2D Array
                        const rawData = await res.json();
                        const rows = rawData.split('\n');
                        const chunk = [];

                        for (let y = 0; y < CHUNK_SIZE; y++) {
                            chunk[y] = [];
                            const rowStr = rows[y] ? rows[y].trim() : "";
                            for (let x = 0; x < CHUNK_SIZE; x++) {
                                chunk[y][x] = parseInt(rowStr[x] || '0');
                            }
                        }
                        chunks.set(key, chunk);

                        // Trigger Render for this chunk
                        if (typeof dirtyChunks !== 'undefined') {
                            dirtyChunks.add(key);
                            // Also update neighbors
                            dirtyChunks.add(`${cx - 1},${cy}`);
                            dirtyChunks.add(`${cx + 1},${cy}`);
                            dirtyChunks.add(`${cx},${cy - 1}`);
                            dirtyChunks.add(`${cx},${cy + 1}`);
                        }
                    }
                } catch (e) {
                    // console.error("Chunk Fetch Failed", cx, cy, e);
                } finally {
                    pendingChunks.delete(key);
                }
            }

            function getChunk(cx, cy) {
                const key = `${cx},${cy}`;
                if (chunks.has(key)) {
                    return chunks.get(key);
                }
                // Request from Server (Via Worker)
                fetchChunkViaWorker(cx, cy);

                // Return temporary empty chunk to avoid rendering crashes
                // Creating an empty 16x16 array
                const empty = [];
                for (let i = 0; i < CHUNK_SIZE; i++) empty[i] = new Array(CHUNK_SIZE).fill(0);
                return empty;
            }

            function getTile(x, y) {
                const cx = Math.floor(x / CHUNK_SIZE);
                const cy = Math.floor(y / CHUNK_SIZE);
                const tx = ((x % CHUNK_SIZE) + CHUNK_SIZE) % CHUNK_SIZE;
                const ty = ((y % CHUNK_SIZE) + CHUNK_SIZE) % CHUNK_SIZE;
                const chunk = getChunk(cx, cy);
                return chunk[ty][tx];
            }

            // Helper: Get Tile without forcing chunk generation (prevents render lag)
            function getTileSafe(x, y) {
                const cx = Math.floor(x / CHUNK_SIZE);
                const cy = Math.floor(y / CHUNK_SIZE);
                const key = `${cx},${cy}`;
                // If chunk doesn't exist, don't generate it. Just return 0 (dirt).
                if (!chunks.has(key)) return 0;

                const tx = ((x % CHUNK_SIZE) + CHUNK_SIZE) % CHUNK_SIZE;
                const ty = ((y % CHUNK_SIZE) + CHUNK_SIZE) % CHUNK_SIZE;
                return chunks.get(key)[ty][tx];
            }

            function setTile(x, y, value) {
                const cx = Math.floor(x / CHUNK_SIZE);
                const cy = Math.floor(y / CHUNK_SIZE);
                const tx = ((x % CHUNK_SIZE) + CHUNK_SIZE) % CHUNK_SIZE;
                const ty = ((y % CHUNK_SIZE) + CHUNK_SIZE) % CHUNK_SIZE;
                const chunk = getChunk(cx, cy);
                if (chunk[ty][tx] === value) return;
                chunk[ty][tx] = value;

                // Mark chunk for re-render and saving
                const key = `${cx},${cy}`;
                dirtyChunks.add(key);
                modifiedChunks.add(key); // Track for save
            }

            // Get dirt variant (4x4 grid = 16 variations)
            function getDirtIdx(x, y) {
                // Use position-based pseudo-random for consistent dirt pattern
                const hash = (x * 374761393 + y * 668265263) & 0xffffffff;
                return Math.abs(hash) % 16; // Random dirt tile 0-15
            }

            // Global Texture Cache (from variables.js)

            function getTileTexture(sourceTexture, idx) {
                if (!globalTextureCache.has(sourceTexture)) {
                    globalTextureCache.set(sourceTexture, {});
                }
                const cache = globalTextureCache.get(sourceTexture);

                if (cache[idx]) {
                    return cache[idx];
                }

                const w = sourceTexture.width || 64;
                const h = sourceTexture.height || 64;

                let tileW, tileH, col, row;

                // Smart Layout Detection based on Aspect Ratio
                if (Math.abs(w - h) < 4) { // Tolerance for square
                    // 4x4 Grid (Standard)
                    tileW = w / 4;
                    tileH = h / 4;
                    col = idx % 4;
                    row = Math.floor(idx / 4);
                } else if (w > h) {
                    // Horizontal Strip (16x1)
                    tileW = w / 16;
                    tileH = h;
                    col = idx;
                    row = 0;
                } else {
                    // Vertical Strip (1x16)
                    tileW = w;
                    tileH = h / 16;
                    col = 0;
                    row = idx;
                }

                // In PixiJS v8, create texture from source with frame rectangle
                const tex = new PIXI.Texture({
                    source: sourceTexture.source,
                    frame: new PIXI.Rectangle(col * tileW, row * tileH, tileW, tileH)
                });

                cache[idx] = tex;
                return tex;
            }

            // Load config from tweaker (config.json) and initialize game
            // config defined in variables.js

            // Try to load config.json, then initialize game
            fetch('config.json')
                .then(res => res.json())
                .then(data => {
                    config = { ...config, ...data };
                    // Config loaded silently
                })
                .catch(() => {
                    // Using default config silently
                })
                .finally(() => {
                    initGame();
                });

            function initGame() {
                // Camera, Player, Mouse defined in variables.js

                // DEFAULT SPAWN (0,0) - Overridden by Persistence in simpleStart()
                player.x = 0;
                player.y = 0;

                // Snap camera to player immediately
                camera.x = player.x;
                camera.y = player.y;

                // Resetting critical values if needed
                camera.zoom = config.defaultZoom;
                player.speed = config.playerSpeed;

                // Track hovered tile (Global)
                hoveredTileX = null;
                hoveredTileY = null;

                // Game loop - runs every frame
                app.ticker.add((delta) => {
                    // Update select sprite position every frame
                    if (selectSprite && hoveredTileX !== null && hoveredTileY !== null) {
                        selectSprite.x = hoveredTileX * TILE_SIZE;
                        selectSprite.y = hoveredTileY * TILE_SIZE;
                    }
                });

                // Consolidated mousemove listener - mouse tracking moved to global event
                // and logic moved to main game loop to ensure updates when camera moves

                // Mouse tracking handled globally below
                // Context menu prevention
                app.canvas.addEventListener('contextmenu', (e) => e.preventDefault());



                // Mouse drag for freelook panning
                let isDragging = false;
                let dragStartX = 0;
                let dragStartY = 0;
                let cameraStartX = 0;
                let cameraStartY = 0;

                app.canvas.addEventListener('mousedown', (e) => {
                    if (isAltPressed && e.button === 0) {
                        isDragging = true;
                        dragStartX = e.clientX;
                        dragStartY = e.clientY;
                        cameraStartX = camera.x;
                        cameraStartY = camera.y;
                        // app.canvas.style.cursor = 'grabbing'; // Removed
                    }
                }, true); // Use capture to run before other handlers

                app.canvas.addEventListener('mousemove', (e) => {
                    if (isDragging && isAltPressed) {
                        const dx = (e.clientX - dragStartX) / camera.zoom;
                        const dy = (e.clientY - dragStartY) / camera.zoom;
                        camera.x = cameraStartX - dx;
                        camera.y = cameraStartY - dy;
                    }
                });

                app.canvas.addEventListener('mouseup', () => {
                    if (isDragging) {
                        isDragging = false;
                        // app.canvas.style.cursor = isAltPressed ? 'grab' : "url('Assets/Image/cursor.png'), auto"; // Removed
                    }
                });

                // Exponential zoom - ONLY in freelook mode
                app.canvas.addEventListener('wheel', (e) => {
                    if (!isAltPressed) return; // Only zoom when Alt is pressed
                    e.preventDefault();
                    // Increased scroll sensitivity for faster zooming
                    const zoomFactor = e.deltaY < 0 ? 1.25 : 0.8;
                    camera.zoom = Math.max(config.minZoom, Math.min(config.maxZoom, camera.zoom * zoomFactor));
                });

                // Garbage Collection: INCREMENTAL (No Lag Spikes)
                // Logic moved to Ticker inside startGameLoop for smoother execution
                /*
                setInterval(() => {
                    // ... old code ...
                }, 5000);
                */

                // Keyboard
                // Keyboard (Global in variables.js)
                // const keys = {};
                // let showGrid = false;
                // let isAltPressed = false; 

                // Activity indicator - track currently pressed keys
                // let pressedKeys = new Set();
                let fadeTimeout = null;

                function updateActivity() {
                    const activity = document.getElementById('activity');
                    if (pressedKeys.size === 0) {
                        // Fade out when no keys pressed
                        activity.classList.remove('flash');
                    } else {
                        // Show all pressed keys with + between them
                        const keyList = Array.from(pressedKeys).join(' + ');
                        activity.textContent = keyList;
                        activity.classList.add('flash');
                    }
                }

                window.addEventListener('keydown', (e) => {
                    keys[e.key.toLowerCase()] = true;

                    // Toggle Alt mode (press Alt to toggle on/off)
                    if (e.key === 'Alt' && !e.repeat) {
                        isAltPressed = !isAltPressed;
                        camera.freelook = isAltPressed;

                        if (isAltPressed) {
                            // Entering freelook
                            // app.canvas.style.cursor = 'grab'; // Removed
                            document.getElementById('info').textContent = 'FREELOOK MODE - Drag to pan, Scroll to zoom, Alt to exit';
                        } else {
                            // Exiting freelook - snap camera back to player and reset zoom
                            camera.x = player.x + player.width / 2;
                            camera.y = player.y + player.height / 2;
                            camera.zoom = config.defaultZoom; // Reset to default zoom (2.0)
                            // app.canvas.style.cursor = "url('Assets/Image/cursor.png'), auto"; // Removed
                        }
                        e.preventDefault();
                    }

                    // Add key to pressed set
                    let keyName = e.key;
                    if (keyName === ' ') keyName = 'Space';
                    if (keyName.length === 1) keyName = keyName.toUpperCase();
                    pressedKeys.add(keyName);
                    updateActivity();

                    if (e.key.toLowerCase() === 'g') {
                        showGrid = !showGrid;
                    }
                });

                window.addEventListener('keyup', (e) => {
                    keys[e.key.toLowerCase()] = false;

                    // Remove key from pressed set
                    let keyName = e.key;
                    if (keyName === ' ') keyName = 'Space';
                    if (keyName.length === 1) keyName = keyName.toUpperCase();
                    pressedKeys.delete(keyName);
                    updateActivity();
                });

                // Grass tile mapping (from README)
                const GRASS_MAP = {
                    '0000': 12, // The Void
                    '1000': 15, // Inner Corner - Top Left
                    '0100': 8,  // Inner Corner - Top Right
                    '0010': 0,  // Inner Corner - Bottom Left
                    '0001': 13, // Inner Corner - Bottom Right
                    '1100': 9,  // Horizontal Edge - Ceiling
                    '0011': 3,  // Horizontal Edge - Floor
                    '1010': 11, // Vertical Edge - Right Face
                    '0101': 1,  // Vertical Edge - Left Face
                    '0110': 14, // Diagonal - Forward Slash
                    '1001': 4,  // Diagonal - Back Slash
                    '1110': 7,  // Outer Corner - Bottom Right
                    '1101': 10, // Outer Corner - Bottom Left
                    '1011': 2,  // Outer Corner - Top Right
                    '0111': 5,  // Outer Corner - Top Left
                    '1111': 6   // Full Solid
                };

                function getGrassIdx(x, y) {
                    // Check 4 corners: TL, TR, BL, BR
                    // F (filled/grass) = 1, E (empty/dirt) = 0
                    // Use getTileSafe to avoid triggering chunk fetches
                    const tl = getTileSafe(x, y) === 1 ? '1' : '0';
                    const tr = getTileSafe(x + 1, y) === 1 ? '1' : '0';
                    const bl = getTileSafe(x, y + 1) === 1 ? '1' : '0';
                    const br = getTileSafe(x + 1, y + 1) === 1 ? '1' : '0';
                    const key = tl + tr + bl + br;
                    return GRASS_MAP[key] !== undefined ? GRASS_MAP[key] : 6;
                }

                // Create placeholder texture when image files are missing
                function createPlaceholderTexture(color) {
                    const canvas = document.createElement('canvas');
                    canvas.width = 64; // 4x4 grid of 16x16 tiles
                    canvas.height = 64;
                    const ctx = canvas.getContext('2d');
                    ctx.fillStyle = `#${color.toString(16).padStart(6, '0')}`;
                    ctx.fillRect(0, 0, 64, 64);
                    return PIXI.Texture.from(canvas);
                }



                // Load textures using modern Assets API (v8+)
                Promise.all([
                    PIXI.Assets.load('../Assets/Image/Tile/dirt.png').catch(() => {
                        console.warn('dirt.png not found, using placeholder');
                        return createPlaceholderTexture(0x8B4513); // Brown
                    }),
                    PIXI.Assets.load('../Assets/Image/Tile/grass.png').catch(() => {
                        console.warn('grass.png not found, using placeholder');
                        return createPlaceholderTexture(0x228B22); // Green
                    }),
                    PIXI.Assets.load('../Assets/Image/select.png').catch(() => {
                        console.warn('select.png not found, using placeholder');
                        const canvas = document.createElement('canvas');
                        canvas.width = 32; canvas.height = 16;
                        const ctx = canvas.getContext('2d');
                        ctx.strokeStyle = '#FFFFFF'; ctx.lineWidth = 2; ctx.strokeRect(16, 0, 16, 16); // Pressed
                        return PIXI.Texture.from(canvas);
                    }),
                    PIXI.Assets.load('../Assets/Image/crosshair.png').catch(() => {
                        console.warn('crosshair.png not found, using placeholder');
                        const canvas = document.createElement('canvas');
                        canvas.width = 16; canvas.height = 16;
                        const ctx = canvas.getContext('2d');
                        ctx.fillStyle = '#FFFFFF'; ctx.fillRect(7, 0, 2, 16); ctx.fillRect(0, 7, 16, 2);
                        return PIXI.Texture.from(canvas);
                    })
                ]).then(([dirtTexLoaded, grassTexLoaded, selectTexLoaded, crosshairTexLoaded]) => {
                    // Update global references and set nearest neighbor scaling (Pixel Art)
                    dirtTexLoaded.source.scaleMode = 'nearest';
                    grassTexLoaded.source.scaleMode = 'nearest';
                    selectTexLoaded.source.scaleMode = 'nearest';
                    crosshairTexLoaded.source.scaleMode = 'nearest';

                    const dirtTex = dirtTexLoaded;
                    const grassTex = grassTexLoaded;
                    const selectTex = selectTexLoaded;
                    const crosshairTex = crosshairTexLoaded;

                    // Setup Block Highlight (using loaded texture)
                    // Assumes horizontal sprite sheet (32x16)
                    const selectTexNormal = new PIXI.Texture({
                        source: selectTex.source,
                        frame: new PIXI.Rectangle(0, 0, TILE_SIZE, TILE_SIZE)
                    });
                    const selectTexPressed = new PIXI.Texture({
                        source: selectTex.source,
                        frame: new PIXI.Rectangle(0, TILE_SIZE, TILE_SIZE, TILE_SIZE)
                    });

                    selectSprite = new PIXI.Sprite(selectTexNormal);
                    selectSprite.width = TILE_SIZE;
                    selectSprite.height = TILE_SIZE;
                    selectSprite.visible = false;
                    selectSprite.zIndex = 1000; // Ensure it's always on top
                    world.addChild(selectSprite);

                    // Setup Crosshair Sprite (REMOVED: Using HTML Follower)
                    /*
                    const crosshairSprite = new PIXI.Sprite(crosshairTex);
                    crosshairSprite.anchor.set(0.5);
                    crosshairSprite.zIndex = 9999; 
                    world.addChild(crosshairSprite);
                    */
                    // Crosshair sprite removed in favor of HTML cursor


                    // Setup Cursor: Using HTML Follower only (Performance)
                    // System cursor hidden via CSS
                    app.canvas.style.cursor = 'none';

                    let cursorSprite = null; // Removed Sprite Logic

                    // Mouse move handler - just track position
                    // Mouse move handler - Extremely Lightweight (Just updates data)
                    window.addEventListener('mousemove', (e) => {
                        mouse.x = e.clientX;
                        mouse.y = e.clientY;
                    });

                    // Synced Cursor: Merged into PixiJS Ticker (The "Engine Heartbeat")
                    // This ensures the cursor updates exactly when the game renders, removing jitter.
                    app.ticker.add(() => {
                        // 1. Cursor handling moved to CSS/HTML


                        // 2. Update World Highlight
                        if (world.scale.x !== 0) {
                            const worldX = (mouse.x - world.x) / world.scale.x;
                            const worldY = (mouse.y - world.y) / world.scale.y;

                            hoveredTileX = Math.floor(worldX / TILE_SIZE);
                            hoveredTileY = Math.floor(worldY / TILE_SIZE);

                            if (selectSprite) {
                                selectSprite.x = hoveredTileX * TILE_SIZE;
                                selectSprite.y = hoveredTileY * TILE_SIZE;
                            }
                        }
                    }, PIXI.UPDATE_PRIORITY.INTERACTION); // High priority update

                    // Mouse down - change to pressed texture
                    window.addEventListener('mousedown', (e) => {
                        if (e.button === 0) {
                            mouse.left = true;
                            // Change texture if selectSprite is ready
                            if (selectSprite) selectSprite.texture = selectTexPressed;
                        } else if (e.button === 2) {
                            mouse.right = true;
                        }
                    });

                    // Mouse up - change back to normal texture
                    window.addEventListener('mouseup', (e) => {
                        if (e.button === 0) {
                            mouse.left = false;
                            if (selectSprite) selectSprite.texture = selectTexNormal;
                        } else if (e.button === 2) {
                            mouse.right = false;
                        }
                    });


                    // Calculate average colors for LOD rendering
                    function getAverageColor(texture) {
                        const canvas = document.createElement('canvas');
                        const ctx = canvas.getContext('2d');
                        canvas.width = texture.width;
                        canvas.height = texture.height;

                        // Draw texture to canvas
                        const img = texture.source.resource;
                        ctx.drawImage(img, 0, 0);

                        // Get pixel data
                        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                        const data = imageData.data;

                        let r = 0, g = 0, b = 0, count = 0;
                        for (let i = 0; i < data.length; i += 4) {
                            // Skip transparent pixels (alpha < 128)
                            if (data[i + 3] >= 128) {
                                r += data[i];
                                g += data[i + 1];
                                b += data[i + 2];
                                count++;
                            }
                        }

                        r = Math.floor(r / count);
                        g = Math.floor(g / count);
                        b = Math.floor(b / count);

                        return (r << 16) | (g << 8) | b; // Return as hex color
                    }

                    const avgDirtColor = getAverageColor(dirtTex);
                    const avgGrassColor = getAverageColor(grassTex);


                    // ASYNC Pre-generation (Networked)
                    // Connect to Java Server (localhost:25565)
                    const SERVER_URL = 'http://localhost:25565';

                    // Hide Canvas initially
                    app.canvas.style.opacity = '0';
                    app.canvas.style.transition = 'opacity 1s';

                    // SIMPLE LOAD STRATEGY (User Request)
                    // 1. Connect to Server
                    // 2. Spawn Randomly
                    // 3. Load Circle Radius (Render Distance)
                    // 4. Start Game Loop

                    app.canvas.style.opacity = '0'; // Fade in effect
                    app.canvas.style.transition = 'opacity 1s';

                    async function simpleStart() {
                        const loader = document.getElementById('loading');
                        const h1 = document.querySelector('#loading h1');

                        // 1. Wait for Server (Server blocks startup until generated)
                        while (true) {
                            try {
                                const res = await fetch('http://localhost:25565/status');
                                if (res.ok) break;
                            } catch (e) {
                                h1.innerText = "Waiting for Server...";
                            }
                            await new Promise(r => setTimeout(r, 1000));
                        }

                        // 2. Fetch Player Position (Persistence)
                        try {
                            const pRes = await fetch('http://localhost:25565/player');
                            if (pRes.ok) {
                                const pData = await pRes.json();
                                player.x = pData.x;
                                player.y = pData.y;
                                camera.x = player.x;
                                camera.y = player.y;
                                console.log("Restored player position (Persistence):", player.x, player.y);
                            }
                        } catch (e) {
                            console.warn("Could not fetch saved position, using default.");
                        }

                        h1.innerText = "Loading World...";

                        // 3. Circle Radius Load
                        const radius = config.renderDistance; // e.g. 5 or user set
                        const pCx = Math.floor(player.x / (16 * 16));
                        const pCy = Math.floor(player.y / (16 * 16));
                        const chunksToLoad = [];

                        // Generate Circle Pattern
                        for (let y = -radius; y <= radius; y++) {
                            for (let x = -radius; x <= radius; x++) {
                                if (x * x + y * y <= radius * radius) {
                                    chunksToLoad.push({ x: pCx + x, y: pCy + y });
                                }
                            }
                        }

                        // 4. Fire Requests (Throttled Background Fetch)
                        let idx = 0;
                        const interval = setInterval(() => {
                            for (let i = 0; i < 10; i++) { // 10 per tick = 200/sec (Safe)
                                if (idx >= chunksToLoad.length) {
                                    clearInterval(interval);

                                    // Start Game Loop when requests are SENT
                                    startGameLoop();

                                    // Visual Fade In
                                    app.canvas.style.opacity = '1';
                                    loader.style.opacity = '0';
                                    setTimeout(() => loader.remove(), 1000);
                                    return;
                                }
                                const c = chunksToLoad[idx++];
                                chunkFetcher.postMessage({ type: 'fetchChunk', cx: c.x, cy: c.y });
                            }
                        }, 50);
                    }

                    // Start Network Loading
                    simpleStart();

                    // Incremental GC State
                    let gcIterator = null;
                    const GC_RADIUS = config.renderDistance + 5; // Reduced from +20 to clear cache faster

                    let lastTime = performance.now();

                    // WRAPPED Game Loop (Started after loading)
                    function startGameLoop() {
                        let lastTime = performance.now();

                        app.ticker.add((ticker) => {
                            // Incremental Garbage Collection (Process 20 chunks per frame)
                            if (!gcIterator) gcIterator = chunks.keys();

                            const playerChunkX = Math.round(player.x / TILE_SIZE / CHUNK_SIZE);
                            const playerChunkY = Math.round(player.y / TILE_SIZE / CHUNK_SIZE);

                            let gcCount = 0;
                            while (gcCount < 20) {
                                const next = gcIterator.next();
                                if (next.done) {
                                    gcIterator = chunks.keys(); // Restart
                                    break;
                                }
                                const key = next.value;
                                const [cx, cy] = key.split(',').map(Number);
                                const dist = Math.max(Math.abs(cx - playerChunkX), Math.abs(cy - playerChunkY));

                                // Only delete if REALLY far (GC Radius)
                                if (dist > GC_RADIUS) {
                                    chunks.delete(key);
                                }
                                gcCount++;
                            }

                            // Time Delta
                            const time = performance.now();
                            const dt = Math.min((time - lastTime) / 1000, 0.1);
                            lastTime = time;

                            // Camera movement (WASD)
                            let moveX = 0, moveY = 0;
                            if (keys['a'] || keys['arrowleft']) moveX = -1;
                            if (keys['d'] || keys['arrowright']) moveX = 1;
                            if (keys['w'] || keys['arrowup']) moveY = -1;
                            if (keys['s'] || keys['arrowdown']) moveY = 1;

                            // Normalize diagonal movement
                            if (moveX !== 0 && moveY !== 0) {
                                moveX *= 0.707;
                                moveY *= 0.707;
                            }

                            // Movement logic - WASD only works in normal mode
                            if (!isAltPressed) {
                                // Normal mode: WASD moves player, camera follows
                                player.x += moveX * player.speed * dt;
                                player.y += moveY * player.speed * dt;
                                camera.x = player.x + player.width / 2;
                                camera.y = player.y + player.height / 2;
                            }
                            // In freelook mode, camera is moved by mouse drag only (no WASD)

                            // Update stats (FPS, location, zoom) with null checks
                            const fps = Math.round(app.ticker.FPS || 0);
                            const locX = player ? Math.floor(player.x) : 0;
                            const locY = player ? Math.floor(player.y) : 0;
                            const zoom = camera ? camera.zoom.toFixed(2) : '0.00';
                            const infoElement = document.getElementById('info');
                            if (infoElement) {
                                infoElement.textContent = `FPS: ${fps} | x: ${locX} y: ${locY} | Zoom: ${zoom}x`;
                            }

                            // Update world-mouse interaction every frame (fixes "laggy" highlight on camera move)
                            // Calculate world coordinates from mouse screen position
                            // world.x/y are the screen center offsets? No, world transform is: 
                            // world.x = -camera.x * zoom + screenW/2
                            // mouseScreen = worldPos * zoom + world.x
                            // worldPos = (mouseScreen - world.x) / zoom

                            // Use world.scale.x which is set to camera.zoom in this loop
                            if (world.scale.x !== 0) {
                                const worldX = (mouse.x - world.x) / world.scale.x;
                                const worldY = (mouse.y - world.y) / world.scale.y;

                                hoveredTileX = Math.floor(worldX / TILE_SIZE);
                                hoveredTileY = Math.floor(worldY / TILE_SIZE);
                            }

                            // Update select sprite position to hovered tile
                            if (hoveredTileX !== null && hoveredTileY !== null) {
                                selectSprite.x = hoveredTileX * TILE_SIZE;
                                selectSprite.y = hoveredTileY * TILE_SIZE;
                            }

                            // Handle input (left=break/dirt, right=place/grass)
                            const isInteractable = !isAltPressed && !camera.freelook;

                            // Only allow building in normal mode, not in freelook
                            if ((mouse.left || mouse.right) && isInteractable) {
                                const worldX = Math.floor((mouse.x - world.x) / camera.zoom / TILE_SIZE);
                                const worldY = Math.floor((mouse.y - world.y) / camera.zoom / TILE_SIZE);
                                const val = mouse.right ? 1 : 0;

                                if (mouse.lastX !== undefined && mouse.lastY !== undefined) {
                                    // Bresenham's Line Algorithm for smooth drawing
                                    let x0 = mouse.lastX;
                                    let y0 = mouse.lastY;
                                    const x1 = worldX;
                                    const y1 = worldY;
                                    const dx = Math.abs(x1 - x0);
                                    const dy = Math.abs(y1 - y0);
                                    const sx = (x0 < x1) ? 1 : -1;
                                    const sy = (y0 < y1) ? 1 : -1;
                                    let err = dx - dy;

                                    while (true) {
                                        setTile(x0, y0, val);
                                        if (x0 === x1 && y0 === y1) break;
                                        const e2 = 2 * err;
                                        if (e2 > -dy) { err -= dy; x0 += sx; }
                                        if (e2 < dx) { err += dx; y0 += sy; }
                                    }
                                } else {
                                    setTile(worldX, worldY, val);
                                }

                                // Update last position
                                mouse.lastX = worldX;
                                mouse.lastY = worldY;
                            } else {
                                // Reset last position if not clicking
                                mouse.lastX = undefined;
                                mouse.lastY = undefined;
                            }

                            // Hide selection sprite in freelook mode
                            if (selectSprite) {
                                selectSprite.visible = isInteractable && hoveredTileX !== null && hoveredTileY !== null;
                            }

                            render();
                            renderOverlays();


                            // Transform world (camera system - center camera position on screen)
                            // Reverted rounding to fix diagonal movement feel
                            world.scale.set(camera.zoom);
                            world.x = -camera.x * camera.zoom + app.screen.width / 2;
                            world.y = -camera.y * camera.zoom + app.screen.height / 2;

                            // Crosshair Position Update Removed


                            // Cursor is now updated in 'mousemove' listener for zero latency.
                            // Removed game loop update to prevent fighting/jitter.

                            // Process Dirty Chunks (Batch Rendering)
                            // Process Dirty Chunks (Batch Rendering) - With Distance Culling to prevent autogen loop
                            if (dirtyChunks.size > 0 && renderChunk) {
                                // SNAPSHOT: Create array copy and clear Set immediately.
                                // This prevents infinite loops where rendering adds new dirty chunks during the same frame.
                                const batch = Array.from(dirtyChunks);
                                dirtyChunks.clear();

                                // Calculate center chunk for culling
                                const centerCX = Math.floor(camera.x / TILE_SIZE / CHUNK_SIZE);
                                const centerCY = Math.floor(camera.y / TILE_SIZE / CHUNK_SIZE);
                                const renderCap = config.renderDistance + 4; // Allow small buffer

                                for (const key of batch) {
                                    const [cx, cy] = key.split(',').map(Number);

                                    // SAFETY: Skip rendering if too far (Prevents infinite generation loop)
                                    if (Math.abs(cx - centerCX) > renderCap || Math.abs(cy - centerCY) > renderCap) {
                                        continue;
                                    }

                                    // Remove old container FIRST
                                    if (chunkContainers.has(key)) {
                                        const containers = chunkContainers.get(key);
                                        if (containers.dirt) {
                                            dirtLayer.removeChild(containers.dirt);
                                            containers.dirt.destroy({ children: true });
                                        }
                                        if (containers.grass) {
                                            grassLayer.removeChild(containers.grass);
                                            containers.grass.destroy({ children: true });
                                        }
                                        chunkContainers.delete(key);
                                    }
                                    // Re-render
                                    renderChunk(cx, cy);
                                }
                            }
                        });

                        // Render function - chunk-based with caching
                        let lastLODState = camera.zoom < config.lodThreshold;

                        // Chunk Rendering Function - assign to outer scope variable
                        renderChunk = function (cx, cy) {
                            const key = `${cx},${cy}`;

                            // Check if chunk data exists. If not, don't render anything yet
                            // (fetchChunk was triggered by getChunk, just wait for next frame)
                            if (!chunks.has(key)) return;

                            const chunk = getChunk(cx, cy);
                            const chunkDirt = new PIXI.Container();
                            const chunkGrass = new PIXI.Container();

                            // LOD: If zoomed out below threshold, render simple colored tiles (Minimap style)
                            if (camera.zoom < config.lodThreshold) {
                                const graphics = new PIXI.Graphics();

                                // Draw each tile as a simple colored rectangle
                                for (let ty = 0; ty < CHUNK_SIZE; ty++) {
                                    for (let tx = 0; tx < CHUNK_SIZE; tx++) {
                                        const tileVal = chunk[ty][tx];
                                        const color = tileVal === 1 ? avgGrassColor : avgDirtColor;

                                        graphics.beginFill(color);
                                        graphics.drawRect(
                                            (cx * CHUNK_SIZE + tx) * TILE_SIZE,
                                            (cy * CHUNK_SIZE + ty) * TILE_SIZE,
                                            TILE_SIZE,
                                            TILE_SIZE
                                        );
                                        graphics.endFill();
                                    }
                                }

                                chunkDirt.addChild(graphics);
                                chunkContainers.set(key, { dirt: chunkDirt, grass: chunkGrass });

                                dirtLayer.addChild(chunkDirt);

                                return;
                            }

                            // Render all tiles in this chunk
                            for (let ty = 0; ty < CHUNK_SIZE; ty++) {
                                for (let tx = 0; tx < CHUNK_SIZE; tx++) {
                                    const worldX = cx * CHUNK_SIZE + tx;
                                    const worldY = cy * CHUNK_SIZE + ty;

                                    // Dirt tile -> Dirt Layer
                                    const dirtIdx = getDirtIdx(worldX, worldY);
                                    const dirtTexture = getTileTexture(dirtTex, dirtIdx);
                                    const dirtSprite = new PIXI.Sprite(dirtTexture);
                                    dirtSprite.x = worldX * TILE_SIZE;
                                    dirtSprite.y = worldY * TILE_SIZE;
                                    dirtSprite.width = TILE_SIZE;
                                    dirtSprite.height = TILE_SIZE;
                                    chunkDirt.addChild(dirtSprite);

                                    // Grass tile -> Grass Layer
                                    // Use getTileSafe to avoid triggering chunk fetches during render
                                    const hasGrass = getTileSafe(worldX, worldY) === 1 ||
                                        getTileSafe(worldX + 1, worldY) === 1 ||
                                        getTileSafe(worldX, worldY + 1) === 1 ||
                                        getTileSafe(worldX + 1, worldY + 1) === 1;

                                    if (hasGrass) {
                                        const grassIdx = getGrassIdx(worldX, worldY);
                                        const grassTexture = getTileTexture(grassTex, grassIdx);
                                        const grassSprite = new PIXI.Sprite(grassTexture);

                                        // Aligned to White Grid (Dual Grid) - Use Center Anchor
                                        grassSprite.anchor.set(0.5);
                                        grassSprite.x = (worldX + 1) * TILE_SIZE;
                                        grassSprite.y = (worldY + 1) * TILE_SIZE;

                                        grassSprite.width = TILE_SIZE;
                                        grassSprite.height = TILE_SIZE;
                                        chunkGrass.addChild(grassSprite);
                                    }
                                }
                            }

                            chunkContainers.set(key, { dirt: chunkDirt, grass: chunkGrass });
                            dirtLayer.addChild(chunkDirt);
                            grassLayer.addChild(chunkGrass);
                        }

                        function render() {
                            // Reset chunk count each frame
                            chunksRendered = 0;

                            // Check if we crossed LOD threshold
                            const currentLODState = camera.zoom < config.lodThreshold;
                            if (lastLODState !== currentLODState) {
                                // Clear all chunks when crossing LOD threshold
                                for (const [key, containers] of chunkContainers.entries()) {
                                    if (containers.dirt) {
                                        dirtLayer.removeChild(containers.dirt);
                                        containers.dirt.destroy();
                                    }
                                    if (containers.grass) {
                                        grassLayer.removeChild(containers.grass);
                                        containers.grass.destroy();
                                    }
                                }
                                chunkContainers.clear();
                                lastLODState = currentLODState;
                            }

                            // AGGRESSIVE GC: Prevent memory leaks
                            if (chunks.size > 1000) {
                                // Calculate player chunk position for GC
                                const playerChunkX = Math.floor(player.x / TILE_SIZE / CHUNK_SIZE);
                                const playerChunkY = Math.floor(player.y / TILE_SIZE / CHUNK_SIZE);
                                const renderDistance = config.renderDistance;

                                // Force cleanup of ANY chunk outside view + buffer
                                for (const key of chunks.keys()) {
                                    const [cx, cy] = key.split(',').map(Number);
                                    if (Math.abs(cx - playerChunkX) > renderDistance + 2 ||
                                        Math.abs(cy - playerChunkY) > renderDistance + 2) {
                                        chunks.delete(key);
                                    }
                                }
                            }

                            // Calculate visible bounds based on viewport
                            const viewHalfW = (app.screen.width / camera.zoom) / 2;
                            const viewHalfH = (app.screen.height / camera.zoom) / 2;

                            // Convert to chunk coordinates - limit to render distance from config
                            const maxRenderDist = Math.min(config.renderDistance, 32); // Increased cap for Infinite World feel

                            // Calculate viewport-based chunk range
                            // Increased pad (2 chunks) to prevent clipping of edge sprites (Dual Grid)
                            let startChunkX = Math.floor((camera.x - viewHalfW) / (TILE_SIZE * CHUNK_SIZE)) - 2;
                            let endChunkX = Math.ceil((camera.x + viewHalfW) / (TILE_SIZE * CHUNK_SIZE)) + 2;
                            let startChunkY = Math.floor((camera.y - viewHalfH) / (TILE_SIZE * CHUNK_SIZE)) - 2;
                            let endChunkY = Math.ceil((camera.y + viewHalfH) / (TILE_SIZE * CHUNK_SIZE)) + 2;

                            // Also limit by render distance from player chunk
                            const playerChunkXCenter = Math.floor(player.x / TILE_SIZE / CHUNK_SIZE);
                            const playerChunkYCenter = Math.floor(player.y / TILE_SIZE / CHUNK_SIZE);
                            startChunkX = Math.max(startChunkX, playerChunkXCenter - maxRenderDist);
                            endChunkX = Math.min(endChunkX, playerChunkXCenter + maxRenderDist);
                            startChunkY = Math.max(startChunkY, playerChunkYCenter - maxRenderDist);
                            endChunkY = Math.min(endChunkY, playerChunkYCenter + maxRenderDist);

                            // Determine which chunks should be visible
                            const chunksToRender = new Set();
                            for (let cy = startChunkY; cy <= endChunkY; cy++) {
                                for (let cx = startChunkX; cx <= endChunkX; cx++) {
                                    chunksToRender.add(`${cx},${cy}`);
                                }
                            }

                            // Remove chunks that are out of range
                            for (const [key, containers] of chunkContainers.entries()) {
                                if (!chunksToRender.has(key)) {
                                    if (containers.dirt) {
                                        dirtLayer.removeChild(containers.dirt);
                                        containers.dirt.destroy({ children: true });
                                    }
                                    if (containers.grass) {
                                        grassLayer.removeChild(containers.grass);
                                        containers.grass.destroy({ children: true });
                                    }
                                    chunkContainers.delete(key);
                                }
                            }

                            // Render new chunks (only if not already rendered)
                            // Time Slicing Scale: More chunks if zoomed out
                            const MAX_CHUNKS_PER_FRAME = config.maxChunksPerFrame || 10;
                            let chunksCreated = 0;

                            // Loop through chunks (standard scanline order: top-to-bottom)
                            for (const key of chunksToRender) {
                                if (!chunkContainers.has(key)) {
                                    if (chunksCreated < MAX_CHUNKS_PER_FRAME) {
                                        const [cx, cy] = key.split(',').map(Number);
                                        renderChunk(cx, cy);
                                        chunksCreated++;
                                    }
                                    // If we hit limit, we just stop creating for this frame. 
                                    // They will be picked up next frame.
                                }
                                chunksRendered++;
                            }

                            // Update stats with active chunk count (rendered containers)
                            const fps = Math.round(app.ticker.FPS);
                            const activeChunks = chunkContainers.size;
                            const cachedChunks = chunks.size;
                            const loadingChunks = pendingChunks.size;
                            document.getElementById('info').textContent = `FPS: ${fps} | x: ${Math.floor(player.x)} y: ${Math.floor(player.y)} | Zoom: ${camera.zoom.toFixed(2)}x | Rendered: ${activeChunks} | Cached: ${cachedChunks} | Loading: ${loadingChunks}`;
                        }

                        // Render overlays (grid, highlights, etc) - called after chunk rendering
                        let overlayGraphics = null;

                        function renderOverlays() {
                            // Skip overlay rendering entirely if grid is disabled (massive performance boost)
                            if (!showGrid) {
                                if (overlayGraphics) {
                                    world.removeChild(overlayGraphics);
                                    overlayGraphics.destroy();
                                    overlayGraphics = null;
                                }
                                return;
                            }

                            // Reuse graphics object (Performance Optimization)
                            if (overlayGraphics) {
                                overlayGraphics.clear();
                            } else {
                                overlayGraphics = new PIXI.Graphics();
                            }

                            // 4. White visual grid (aligned with world grid) - ONLY IF GRID IS ON
                            // Removing "Always Render" behavior to save FPS
                            /*
                           overlayGraphics.lineStyle(0.5, 0xffffff, 0.2);
                            */

                            // Calculate visible area for grid (RESTORED for debug usage)
                            const playerChunkX = Math.round(player.x / TILE_SIZE / CHUNK_SIZE);
                            const playerChunkY = Math.round(player.y / TILE_SIZE / CHUNK_SIZE);
                            const renderDistance = Math.min(5, Math.ceil(5 / Math.max(camera.zoom, 1.0)));
                            const startX = (playerChunkX - renderDistance) * CHUNK_SIZE;
                            const endX = (playerChunkX + renderDistance + 1) * CHUNK_SIZE;
                            const startY = (playerChunkY - renderDistance) * CHUNK_SIZE;
                            const endY = (playerChunkY + renderDistance + 1) * CHUNK_SIZE;

                            /*
                            // ... [omitted expensive generic loop] ...
                            for (let x = startX; x <= endX; x++) { ... }
                            */

                            // Just use the debug loop below if needed.


                            // Multi-layer DEBUG grid system (when G is pressed)
                            if (showGrid) {
                                // 1. Green shades for grass tiles
                                for (let y = startY; y < endY; y++) {
                                    for (let x = startX; x < endX; x++) {
                                        if (getTile(x, y) === 1) {
                                            overlayGraphics.beginFill(0x00ff00, 0.1);
                                            overlayGraphics.drawRect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE);
                                            overlayGraphics.endFill();
                                        }
                                    }
                                }

                                // 2. Blue chunk boundaries
                                overlayGraphics.lineStyle(2, 0x0000ff, 0.5);
                                const chunkStartX = Math.floor(startX / CHUNK_SIZE) * CHUNK_SIZE;
                                const chunkEndX = Math.ceil(endX / CHUNK_SIZE) * CHUNK_SIZE;
                                const chunkStartY = Math.floor(startY / CHUNK_SIZE) * CHUNK_SIZE;
                                const chunkEndY = Math.ceil(endY / CHUNK_SIZE) * CHUNK_SIZE;

                                for (let x = chunkStartX; x <= chunkEndX; x += CHUNK_SIZE) {
                                    overlayGraphics.moveTo(x * TILE_SIZE, chunkStartY * TILE_SIZE);
                                    overlayGraphics.lineTo(x * TILE_SIZE, chunkEndY * TILE_SIZE);
                                }
                                for (let y = chunkStartY; y <= chunkEndY; y += CHUNK_SIZE) {
                                    overlayGraphics.moveTo(chunkStartX * TILE_SIZE, y * TILE_SIZE);
                                    overlayGraphics.lineTo(chunkEndX * TILE_SIZE, y * TILE_SIZE);
                                }
                                overlayGraphics.stroke(); // Make lines visible

                                // 3. Red Tile Grid (World Grid)
                                // FIX: Use full opacity and correct color (0xFF0000)
                                overlayGraphics.lineStyle(1, 0xFF0000, 0.5);
                                for (let x = startX; x <= endX; x++) {
                                    overlayGraphics.moveTo(x * TILE_SIZE, startY * TILE_SIZE);
                                    overlayGraphics.lineTo(x * TILE_SIZE, endY * TILE_SIZE);
                                }
                                for (let y = startY; y <= endY; y++) {
                                    overlayGraphics.moveTo(startX * TILE_SIZE, y * TILE_SIZE);
                                    overlayGraphics.lineTo(endX * TILE_SIZE, y * TILE_SIZE);
                                }

                                // 4. White Offset Grid (2x Thinner)
                                overlayGraphics.lineStyle(0.5, 0xFFFFFF, 0.3);
                                const offset = 8; // FIX: 8px Offset (Half Block for Dual Grid)
                                for (let x = startX; x <= endX; x++) {
                                    overlayGraphics.moveTo(x * TILE_SIZE + offset, startY * TILE_SIZE + offset);
                                    overlayGraphics.lineTo(x * TILE_SIZE + offset, endY * TILE_SIZE + offset);
                                }
                                for (let y = startY; y <= endY; y++) {
                                    overlayGraphics.moveTo(startX * TILE_SIZE + offset, y * TILE_SIZE + offset);
                                    overlayGraphics.lineTo(endX * TILE_SIZE + offset, y * TILE_SIZE + offset);
                                }
                            }

                            overlayGraphics.stroke(); // Make lines visible

                            overlayGraphics.zIndex = 2000; // Ensure overlays are on top of chunks (zIndex 0) and selection (zIndex 1000)
                            world.addChild(overlayGraphics);
                        }
                    } // End renderOverlays
                });
            } // End initGame function

            // HTML Cursor Logic (Simple Follower)
            const follower = document.getElementById("follower-element");
            window.addEventListener('mousemove', (event) => {
                const clientX = event.clientX;
                const clientY = event.clientY;
                follower.style.left = `${clientX}px`;
                follower.style.top = `${clientY}px`;
            });

        }); // End window.addEventListener
        // CHUNK FETCHER INTEGRATION (Background Network Thread)
        // This background thread just DOWNLOADS data from Java. It does not generate it.
        const workerCode = `
        const SERVER_URL = 'http://localhost:25565';
        const CHUNK_SIZE = 16;

        self.onmessage = async function (e) {
            const { type, cx, cy } = e.data;

            if (type === 'fetchChunk') {
                try {
                    const res = await fetch(SERVER_URL + '/chunk?x=' + cx + '&y=' + cy);
                    if (res.ok) {
                        // Response is JSON String "1010\\n..."
                        const rawData = await res.json();
                        
                        // Parse String to 2D Array in Worker
                        const rows = rawData.split('\\n');
                        const chunk2D = [];
                        for (let y = 0; y < CHUNK_SIZE; y++) {
                            chunk2D[y] = [];
                            const rowStr = rows[y] ? rows[y].trim() : "";
                            for (let x = 0; x < CHUNK_SIZE; x++) {
                                chunk2D[y][x] = parseInt(rowStr[x] || '0');
                            }
                        }

                        self.postMessage({
                            type: 'chunkData',
                            cx, cy,
                            data: chunk2D
                        });
                    } else {
                        self.postMessage({ type: 'chunkError', cx, cy });
                    }
                } catch (err) {
                    self.postMessage({ type: 'chunkError', cx, cy, error: err.message });
                }
            }
        };
        `;

        const blob = new Blob([workerCode], { type: 'application/javascript' });
        const chunkFetcher = new Worker(URL.createObjectURL(blob));
        chunkFetcher.onmessage = function (e) {
            const { type, cx, cy, data } = e.data;
            const key = `${cx},${cy}`;
            if (type === 'chunkData') {
                const chunk2D = data; // Received 2D JSON Array directly
                chunks.set(key, chunk2D);

                // EVENT-DRIVEN RENDERING (User Request: "Constant Render / Perfect Loop")
                // Immediately render the chunk when data arrives. No "Dirty" state.
                if (renderChunk) {
                    renderChunk(cx, cy);
                    // Update neighbors (Autotiling edges)
                    renderChunk(cx - 1, cy);
                    renderChunk(cx + 1, cy);
                    renderChunk(cx, cy - 1);
                    renderChunk(cx, cy + 1);
                }
            }
        };

        function fetchChunkViaWorker(cx, cy) {
            // Ensure unique request
            const key = `${cx},${cy}`;
            if (pendingChunks.has(key) || chunks.has(key)) return;
            pendingChunks.add(key);
            chunkFetcher.postMessage({ type: 'fetchChunk', cx, cy });
        }

        // Save World Function
        async function saveWorld() {
            const saveBtn = document.getElementById('saveBtn');
            const saveStatus = document.getElementById('saveStatus');

            if (modifiedChunks.size === 0) {
                // Just log, but continue to save player position
                console.log("No modified chunks, saving player state only...");
            }

            // Disable button during save
            saveBtn.disabled = true;
            saveBtn.textContent = 'Saving...';
            saveStatus.textContent = `Saving ${modifiedChunks.size} chunks...`;
            saveStatus.style.color = '#ff0';
            saveStatus.style.display = 'block';

            try {
                // Convert chunk data to JSON format
                const chunksToSave = [];
                for (const key of modifiedChunks) {
                    if (chunks.has(key)) {
                        const chunk = chunks.get(key);
                        // Convert 2D array to string format "1010\n0101..."
                        let dataStr = '';
                        for (let y = 0; y < CHUNK_SIZE; y++) {
                            for (let x = 0; x < CHUNK_SIZE; x++) {
                                dataStr += chunk[y][x];
                            }
                            if (y < CHUNK_SIZE - 1) dataStr += '\\n';
                        }
                        chunksToSave.push({ key, data: dataStr });
                    }
                }

                const response = await fetch('http://localhost:25565/save', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        chunks: chunksToSave,
                        player: { x: player.x, y: player.y }
                    })
                });

                const result = await response.json();

                if (response.ok) {
                    modifiedChunks.clear(); // Clear after successful save
                    saveStatus.textContent = `Saved ${result.saved} chunks!`;
                    saveStatus.style.color = '#0f0';
                } else {
                    saveStatus.textContent = 'Save failed!';
                    saveStatus.style.color = '#f00';
                }
            } catch (e) {
                console.error('Save error:', e);
                saveStatus.textContent = 'Connection error!';
                saveStatus.style.color = '#f00';
            }

            // Re-enable button
            saveBtn.disabled = false;
            saveBtn.textContent = '[SAVE]';

            // Hide status after delay
            setTimeout(() => saveStatus.style.display = 'none', 3000);
        }

        // Bind save button
        document.getElementById('saveBtn').addEventListener('click', saveWorld);

    </script>
</body>

</html>