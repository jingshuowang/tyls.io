<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8">
    <title>tyls.io</title>
    <link rel="icon" href="data:,">
    <style>
        @font-face {
            font-family: 'Minecraft';
            src: url('../Assets/Font/pixel.ttf') format('truetype');
        }

        body {
            margin: 0;
            overflow: hidden;
            /* Hide default/CSS cursor for Software Cursor */
            background: #000;
        }

        canvas {
            display: block;
            image-rendering: pixelated;
            image-rendering: crisp-edges;
            cursor: none;
        }

        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            color: #ffffff;
            font-family: 'Minecraft', monospace;
            font-size: 16px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
            pointer-events: none;
            z-index: 100;
        }

        #activity {
            position: absolute;
            top: 10px;
            right: 10px;
            color: #ffffff;
            font-family: 'Minecraft', monospace;
            font-size: 20px;
            font-weight: bold;
            text-shadow: 0 0 5px rgba(255, 255, 255, 0.5);
            opacity: 0;
            transition: opacity 0.2s;
            pointer-events: none;
        }

        #activity.flash {
            opacity: 1;
        }

        /* Custom HTML Cursor */
        /* Custom HTML Cursor */
        #follower-element {
            width: 32px;
            height: 32px;
            background-image: url('../Assets/Image/cursor.png');
            background-size: contain;
            background-repeat: no-repeat;
            position: fixed;
            transform: translate(-50%, -50%);
            /* Center? Usually cursors are top-left... let's keep top-left */
            /* transform: translate(0, 0); */
            pointer-events: none;
            z-index: 10000;
            image-rendering: pixelated;
        }

        /* Force Hide System Cursor Globally */
        * {
            cursor: none !important;
        }
    </style>
</head>

<body>
    <div id="info"></div>
    <div id="activity"></div>
    <div id="follower-element"></div>

    <!-- Save Button -->




    <!-- Loading Screen Removed per User Request -->

    <script>
        window.onerror = function (msg, url, line, col, error) {
            const div = document.createElement('div');
            div.style.position = 'fixed';
            div.style.top = '50%';
            div.style.left = '50%';
            div.style.transform = 'translate(-50%, -50%)';
            div.style.background = 'rgba(255,0,0,0.8)';
            div.style.color = 'white';
            div.style.padding = '20px';
            div.style.border = '2px solid white';
            div.style.zIndex = '99999';
            div.style.fontFamily = 'monospace';
            div.innerText = `CRITICAL ERROR:\n${msg}\nLine: ${line}`;
            document.body.appendChild(div);
            return false;
        };
    </script>

    <script src="https://cdn.jsdelivr.net/npm/pixi.js@8.5.2/dist/pixi.min.js"></script>
    <script>
        // --- INLINED VARIABLES (Formerly variables.js) ---
        // Game Constants
        const TILE_SIZE = 16;
        const CHUNK_SIZE = 16;
        const SERVER_URL = 'http://localhost:25565';

        // Configuration (Overridden by config.json)
        let config = {
            playerSpeed: 200,
            defaultZoom: 3.0,
            minZoom: 0.25,
            maxZoom: 10,
            chunkSize: 16,
            renderDistance: 5,
            lodThreshold: 0.8,
            maxChunksPerFrame: 10
        };

        // Game State
        const chunks = new Map();
        const chunkContainers = new Map();
        const dirtyChunks = new Set();
        const pendingChunks = new Set();
        const modifiedChunks = new Set(); // Track chunks modified by player for saving
        let chunksRendered = 0;

        // Entities
        const camera = { x: 0, y: 0, zoom: 3.0, freelook: false };
        const player = { x: 128, y: 128, width: 16, height: 16, speed: 200 };
        const mouse = { x: 0, y: 0, left: false, right: false, lastX: undefined, lastY: undefined };

        // Interaction
        let isAltPressed = false;
        let showGrid = false;
        let hoveredTileX = null;
        let hoveredTileY = null;
        let selectSprite = null;

        // Input
        const keys = {};
        let pressedKeys = new Set();
        const globalTextureCache = new Map();

        // Globals
        let app, world, dirtLayer, grassLayer, renderChunk = null, fetchChunkViaWorker = null;
        let db = null; // Database instance
    </script>
    <script>
        // Wait for PixiJS to load
        window.addEventListener('load', async () => {
            // --- DB REMOVED (User Request) ---
            // Settings
            // Settings (Loaded from variables.js)



            // Settings
            // Settings (Loaded from variables.js)



            // Global PixiJS Settings for Pixel Art
            PIXI.TextureSource.defaultOptions.scaleMode = 'nearest';

            // PixiJS App (v8 requires await)
            // PixiJS App (using global 'app' from variables.js)
            app = new PIXI.Application();
            await app.init({
                width: window.innerWidth,
                height: window.innerHeight,
                backgroundColor: 0x1a1a1a,
                antialias: false,
                roundPixels: true,  // Pixel-perfect rendering
                preference: 'maximum-performance', // Hint to browser
                powerPreference: 'high-performance'
            });
            // Attempt to uncap FPS (0 = uncapped / monitor limit)
            app.ticker.maxFPS = 0;
            document.body.appendChild(app.canvas);

            // Resize canvas to fill screen (fixes black bar at top)
            function resizeCanvas() {
                app.renderer.resize(window.innerWidth, window.innerHeight);
            }
            window.addEventListener('resize', resizeCanvas);
            resizeCanvas(); // Call once to ensure proper size

            // Pixel-perfect (v8 compatible)
            // FPS Uncapped (User requested)



            // World container
            // World container (global 'world')
            world = new PIXI.Container();
            world.sortableChildren = true; // Enable z-index sorting for world (tiles/players)
            app.stage.sortableChildren = true; // Enable z-index sorting for stage (UI/Crosshair)
            app.stage.addChild(world);

            // Layers for Z-sorting (Fixes "cutoff" grass/half tiles)
            // Layers for Z-sorting (global 'dirtLayer', 'grassLayer')
            dirtLayer = new PIXI.Container();
            grassLayer = new PIXI.Container();
            world.addChild(dirtLayer);
            world.addChild(grassLayer);

            // Track hovered tile position (Global from variables.js)
            // let hoveredTileX = null;
            // let hoveredTileY = null;

            // Mouse tracking


            // NOTE: selectSprite and event handlers moved inside Promise.all().then() to ensure texture is loaded


            // Chunk-based world data
            // RENDER_DISTANCE now comes from config.renderDistance
            // Chunk-based world data (Global from variables.js)
            // const chunks = new Map(); 
            // const chunkContainers = new Map();
            // const dirtyChunks = new Set();
            // let chunksRendered = 0;

            // renderChunk function reference (defined below, declared in variables.js)
            // let renderChunk = null; (Global)

            // Simple Perlin-like noise REMOVED (Legacy, Server handles generation now)

            // Chunk Management (Client Cache)
            // Data is fetched from Server, stored here
            // chunks map is global.


            // Track pending requests (Global from variables.js)
            // const pendingChunks = new Set();

            async function fetchChunk(cx, cy) {
                const key = `${cx},${cy}`;
                if (chunks.has(key) || pendingChunks.has(key)) return;

                pendingChunks.add(key);
                try {
                    const res = await fetch(`http://localhost:25565/chunk?x=${cx}&y=${cy}`);
                    if (res.ok) {
                        // JSON Response is a String: "1010\n0101..."
                        // We need to parse this back to 2D Array
                        const rawData = await res.json();
                        const rows = rawData.split('\n');
                        const chunk = [];

                        for (let y = 0; y < CHUNK_SIZE; y++) {
                            chunk[y] = [];
                            const rowStr = rows[y] ? rows[y].trim() : "";
                            for (let x = 0; x < CHUNK_SIZE; x++) {
                                chunk[y][x] = parseInt(rowStr[x] || '0');
                            }
                        }
                        chunks.set(key, chunk);

                        // Trigger Render for this chunk
                        if (typeof dirtyChunks !== 'undefined') {
                            dirtyChunks.add(key);
                            // Also update neighbors
                            dirtyChunks.add(`${cx - 1},${cy}`);
                            dirtyChunks.add(`${cx + 1},${cy}`);
                            dirtyChunks.add(`${cx},${cy - 1}`);
                            dirtyChunks.add(`${cx},${cy + 1}`);
                        }
                    }
                } catch (e) {
                    // console.error("Chunk Fetch Failed", cx, cy, e);
                } finally {
                    pendingChunks.delete(key);
                }
            }

            function getChunk(cx, cy) {
                const key = `${cx},${cy}`;
                if (chunks.has(key)) {
                    return chunks.get(key);
                }

                // WASM DB Lookups REMOVED
                // if (db) { ... }

                // Fallback / Loading placeholder
                const empty = [];
                for (let i = 0; i < CHUNK_SIZE; i++) empty[i] = new Array(CHUNK_SIZE).fill(0);
                return empty;
            }

            function getTile(x, y) {
                const cx = Math.floor(x / CHUNK_SIZE);
                const cy = Math.floor(y / CHUNK_SIZE);
                const tx = ((x % CHUNK_SIZE) + CHUNK_SIZE) % CHUNK_SIZE;
                const ty = ((y % CHUNK_SIZE) + CHUNK_SIZE) % CHUNK_SIZE;
                const chunk = getChunk(cx, cy);
                return chunk[ty][tx];
            }

            // Helper: Get Tile without forcing chunk generation (prevents render lag)
            // Helper: Get Tile safe (Synchronous WASM Access)
            function getTileSafe(x, y) {
                const cx = Math.floor(x / CHUNK_SIZE);
                const cy = Math.floor(y / CHUNK_SIZE);

                // WASM: getChunk is instant (checks Cache -> DB -> Empty)
                // This ensures neighbors are loaded for correct edge connections (fixing diagonal gaps)
                const chunk = getChunk(cx, cy);

                const tx = ((x % CHUNK_SIZE) + CHUNK_SIZE) % CHUNK_SIZE;
                const ty = ((y % CHUNK_SIZE) + CHUNK_SIZE) % CHUNK_SIZE;
                return chunk[ty][tx];
            }

            function setTile(x, y, value) {
                const cx = Math.floor(x / CHUNK_SIZE);
                const cy = Math.floor(y / CHUNK_SIZE);
                const tx = ((x % CHUNK_SIZE) + CHUNK_SIZE) % CHUNK_SIZE;
                const ty = ((y % CHUNK_SIZE) + CHUNK_SIZE) % CHUNK_SIZE;
                const chunk = getChunk(cx, cy);
                if (chunk[ty][tx] === value) return;
                chunk[ty][tx] = value;

                // Mark chunk for re-render and saving
                const key = `${cx},${cy}`;
                dirtyChunks.add(key);
                modifiedChunks.add(key); // Track for save
            }

            // Get dirt variant (4x4 grid = 16 variations)
            function getDirtIdx(x, y) {
                // Use position-based pseudo-random for consistent dirt pattern
                const hash = (x * 374761393 + y * 668265263) & 0xffffffff;
                return Math.abs(hash) % 16; // Random dirt tile 0-15
            }

            // Global Texture Cache (from variables.js)

            function getTileTexture(sourceTexture, idx) {
                if (!globalTextureCache.has(sourceTexture)) {
                    globalTextureCache.set(sourceTexture, {});
                }
                const cache = globalTextureCache.get(sourceTexture);

                if (cache[idx]) {
                    return cache[idx];
                }

                const w = sourceTexture.width || 64;
                const h = sourceTexture.height || 64;

                let tileW, tileH, col, row;

                // Smart Layout Detection based on Aspect Ratio
                if (Math.abs(w - h) < 4) { // Tolerance for square
                    // 4x4 Grid (Standard)
                    tileW = w / 4;
                    tileH = h / 4;
                    col = idx % 4;
                    row = Math.floor(idx / 4);
                } else if (w > h) {
                    // Horizontal Strip (16x1)
                    tileW = w / 16;
                    tileH = h;
                    col = idx;
                    row = 0;
                } else {
                    // Vertical Strip (1x16)
                    tileW = w;
                    tileH = h / 16;
                    col = 0;
                    row = idx;
                }

                // In PixiJS v8, create texture from source with frame rectangle
                const tex = new PIXI.Texture({
                    source: sourceTexture.source,
                    frame: new PIXI.Rectangle(col * tileW, row * tileH, tileW, tileH)
                });

                cache[idx] = tex;
                return tex;
            }

            // Load config from tweaker (config.json) and initialize game
            // config defined in variables.js

            // Try to load config.json, then initialize game
            fetch('config.json')
                .then(res => res.json())
                .then(data => {
                    config = { ...config, ...data };
                    // Config loaded silently
                })
                .catch(() => {
                    // Using default config silently
                })
                .finally(() => {
                    initGame();
                });

            function initGame() {
                // Camera, Player, Mouse defined in variables.js

                // DEFAULT SPAWN (0,0) - Overridden by Persistence in simpleStart()
                player.x = 0;
                player.y = 0;

                // Snap camera to player immediately
                camera.x = player.x;
                camera.y = player.y;

                // Resetting critical values if needed
                camera.zoom = config.defaultZoom;
                player.speed = config.playerSpeed;

                // Track hovered tile (Global)
                hoveredTileX = null;
                hoveredTileY = null;

                // Game loop - runs every frame
                app.ticker.add((delta) => {
                    // Update select sprite position every frame
                    if (selectSprite && hoveredTileX !== null && hoveredTileY !== null) {
                        selectSprite.x = hoveredTileX * TILE_SIZE;
                        selectSprite.y = hoveredTileY * TILE_SIZE;
                    }
                });

                // Consolidated mousemove listener - mouse tracking moved to global event
                // and logic moved to main game loop to ensure updates when camera moves

                // Mouse tracking handled globally below
                // Context menu prevention
                app.canvas.addEventListener('contextmenu', (e) => e.preventDefault());



                // Mouse drag for freelook panning
                let isDragging = false;
                let dragStartX = 0;
                let dragStartY = 0;
                let cameraStartX = 0;
                let cameraStartY = 0;

                app.canvas.addEventListener('mousedown', (e) => {
                    if (isAltPressed && e.button === 0) {
                        isDragging = true;
                        dragStartX = e.clientX;
                        dragStartY = e.clientY;
                        cameraStartX = camera.x;
                        cameraStartY = camera.y;
                        // app.canvas.style.cursor = 'grabbing'; // Removed
                    }
                }, true); // Use capture to run before other handlers

                app.canvas.addEventListener('mousemove', (e) => {
                    if (isDragging && isAltPressed) {
                        const dx = (e.clientX - dragStartX) / camera.zoom;
                        const dy = (e.clientY - dragStartY) / camera.zoom;
                        camera.x = cameraStartX - dx;
                        camera.y = cameraStartY - dy;
                    }
                });

                app.canvas.addEventListener('mouseup', () => {
                    if (isDragging) {
                        isDragging = false;
                        // app.canvas.style.cursor = isAltPressed ? 'grab' : "url('Assets/Image/cursor.png'), auto"; // Removed
                    }
                });

                // Exponential zoom - ONLY in freelook mode
                app.canvas.addEventListener('wheel', (e) => {
                    if (!isAltPressed) return; // Only zoom when Alt is pressed
                    e.preventDefault();
                    // Increased scroll sensitivity for faster zooming
                    const zoomFactor = e.deltaY < 0 ? 1.25 : 0.8;
                    camera.zoom = Math.max(config.minZoom, Math.min(config.maxZoom, camera.zoom * zoomFactor));
                });

                // Garbage Collection: INCREMENTAL (No Lag Spikes)
                // Logic moved to Ticker inside startGameLoop for smoother execution
                /*
                setInterval(() => {
                    // ... old code ...
                }, 5000);
                */

                // Keyboard
                // Keyboard (Global in variables.js)
                // const keys = {};
                // let showGrid = false;
                // let isAltPressed = false; 

                // Activity indicator - track currently pressed keys
                // let pressedKeys = new Set();
                let fadeTimeout = null;

                function updateActivity() {
                    const activity = document.getElementById('activity');
                    if (pressedKeys.size === 0) {
                        // Fade out when no keys pressed
                        activity.classList.remove('flash');
                    } else {
                        // Show all pressed keys with + between them
                        const keyList = Array.from(pressedKeys).join(' + ');
                        activity.textContent = keyList;
                        activity.classList.add('flash');
                    }
                }

                window.addEventListener('keydown', (e) => {
                    keys[e.key.toLowerCase()] = true;

                    // Toggle Alt mode (press Alt to toggle on/off)
                    if (e.key === 'Alt' && !e.repeat) {
                        isAltPressed = !isAltPressed;
                        camera.freelook = isAltPressed;

                        if (isAltPressed) {
                            // Entering freelook
                            // app.canvas.style.cursor = 'grab'; // Removed
                            document.getElementById('info').textContent = 'FREELOOK MODE - Drag to pan, Scroll to zoom, Alt to exit';
                        } else {
                            // Exiting freelook - snap camera back to player and reset zoom
                            camera.x = player.x + player.width / 2;
                            camera.y = player.y + player.height / 2;
                            camera.zoom = config.defaultZoom; // Reset to default zoom (2.0)
                            // app.canvas.style.cursor = "url('Assets/Image/cursor.png'), auto"; // Removed
                        }
                        e.preventDefault();
                    }

                    // Add key to pressed set
                    let keyName = e.key;
                    if (keyName === ' ') keyName = 'Space';
                    if (keyName.length === 1) keyName = keyName.toUpperCase();
                    pressedKeys.add(keyName);
                    updateActivity();

                    if (e.key.toLowerCase() === 'g') {
                        showGrid = !showGrid;
                    }
                });

                window.addEventListener('keyup', (e) => {
                    keys[e.key.toLowerCase()] = false;

                    // Remove key from pressed set
                    let keyName = e.key;
                    if (keyName === ' ') keyName = 'Space';
                    if (keyName.length === 1) keyName = keyName.toUpperCase();
                    pressedKeys.delete(keyName);
                    updateActivity();
                });

                // Grass tile mapping (from README)
                const GRASS_MAP = {
                    '0000': 12, // The Void
                    '1000': 15, // Inner Corner - Top Left
                    '0100': 8,  // Inner Corner - Top Right
                    '0010': 0,  // Inner Corner - Bottom Left
                    '0001': 13, // Inner Corner - Bottom Right
                    '1100': 9,  // Horizontal Edge - Ceiling
                    '0011': 3,  // Horizontal Edge - Floor
                    '1010': 11, // Vertical Edge - Right Face
                    '0101': 1,  // Vertical Edge - Left Face
                    '0110': 14, // Diagonal - Forward Slash
                    '1001': 4,  // Diagonal - Back Slash
                    '1110': 7,  // Outer Corner - Bottom Right
                    '1101': 10, // Outer Corner - Bottom Left
                    '1011': 2,  // Outer Corner - Top Right
                    '0111': 5,  // Outer Corner - Top Left
                    '1111': 6   // Full Solid
                };

                function getGrassIdx(x, y) {
                    // Check 4 corners: TL, TR, BL, BR
                    // F (filled/grass) = 1, E (empty/dirt) = 0
                    // Use getTileSafe to avoid triggering chunk fetches
                    const tl = getTileSafe(x, y) === 1 ? '1' : '0';
                    const tr = getTileSafe(x + 1, y) === 1 ? '1' : '0';
                    const bl = getTileSafe(x, y + 1) === 1 ? '1' : '0';
                    const br = getTileSafe(x + 1, y + 1) === 1 ? '1' : '0';
                    const key = tl + tr + bl + br;
                    return GRASS_MAP[key] !== undefined ? GRASS_MAP[key] : 6;
                }

                // Create placeholder texture when image files are missing
                function createPlaceholderTexture(color) {
                    const canvas = document.createElement('canvas');
                    canvas.width = 64; // 4x4 grid of 16x16 tiles
                    canvas.height = 64;
                    const ctx = canvas.getContext('2d');
                    ctx.fillStyle = `#${color.toString(16).padStart(6, '0')}`;
                    ctx.fillRect(0, 0, 64, 64);
                    return PIXI.Texture.from(canvas);
                }



                // Load textures using modern Assets API (v8+)
                Promise.all([
                    PIXI.Assets.load('../Assets/Image/Tile/dirt.png').catch(() => {
                        console.warn('dirt.png not found, using placeholder');
                        return createPlaceholderTexture(0x8B4513); // Brown
                    }),
                    PIXI.Assets.load('../Assets/Image/Tile/grass.png').catch(() => {
                        console.warn('grass.png not found, using placeholder');
                        return createPlaceholderTexture(0x228B22); // Green
                    }),
                    PIXI.Assets.load('../Assets/Image/select.png').catch(() => {
                        console.warn('select.png not found, using placeholder');
                        const canvas = document.createElement('canvas');
                        canvas.width = 32; canvas.height = 16;
                        const ctx = canvas.getContext('2d');
                        ctx.strokeStyle = '#FFFFFF'; ctx.lineWidth = 2; ctx.strokeRect(16, 0, 16, 16); // Pressed
                        return PIXI.Texture.from(canvas);
                    }),
                    PIXI.Assets.load('../Assets/Image/crosshair.png').catch(() => {
                        console.warn('crosshair.png not found, using placeholder');
                        const canvas = document.createElement('canvas');
                        canvas.width = 16; canvas.height = 16;
                        const ctx = canvas.getContext('2d');
                        ctx.fillStyle = '#FFFFFF'; ctx.fillRect(7, 0, 2, 16); ctx.fillRect(0, 7, 16, 2);
                        return PIXI.Texture.from(canvas);
                    })
                ]).then(([dirtTexLoaded, grassTexLoaded, selectTexLoaded, crosshairTexLoaded]) => {
                    // Update global references and set nearest neighbor scaling (Pixel Art)
                    dirtTexLoaded.source.scaleMode = 'nearest';
                    grassTexLoaded.source.scaleMode = 'nearest';
                    selectTexLoaded.source.scaleMode = 'nearest';
                    crosshairTexLoaded.source.scaleMode = 'nearest';

                    const dirtTex = dirtTexLoaded;
                    const grassTex = grassTexLoaded;
                    const selectTex = selectTexLoaded;
                    const crosshairTex = crosshairTexLoaded;

                    // Setup Block Highlight (using loaded texture)
                    // Assumes horizontal sprite sheet (32x16)
                    const selectTexNormal = new PIXI.Texture({
                        source: selectTex.source,
                        frame: new PIXI.Rectangle(0, 0, TILE_SIZE, TILE_SIZE)
                    });
                    const selectTexPressed = new PIXI.Texture({
                        source: selectTex.source,
                        frame: new PIXI.Rectangle(0, TILE_SIZE, TILE_SIZE, TILE_SIZE)
                    });

                    selectSprite = new PIXI.Sprite(selectTexNormal);
                    selectSprite.width = TILE_SIZE;
                    selectSprite.height = TILE_SIZE;
                    selectSprite.visible = false;
                    selectSprite.zIndex = 1000; // Ensure it's always on top
                    world.addChild(selectSprite);

                    // Setup Crosshair Sprite (REMOVED: Using HTML Follower)
                    /*
                    const crosshairSprite = new PIXI.Sprite(crosshairTex);
                    crosshairSprite.anchor.set(0.5);
                    crosshairSprite.zIndex = 9999; 
                    world.addChild(crosshairSprite);
                    */
                    // Crosshair sprite removed in favor of HTML cursor


                    // Setup Cursor: Using HTML Follower only (Performance)
                    // System cursor hidden via CSS
                    app.canvas.style.cursor = 'none';

                    let cursorSprite = null; // Removed Sprite Logic

                    // Mouse move handler - just track position
                    // Mouse move handler - Extremely Lightweight (Just updates data)
                    window.addEventListener('mousemove', (e) => {
                        mouse.x = e.clientX;
                        mouse.y = e.clientY;
                    });

                    // Synced Cursor: Merged into PixiJS Ticker (The "Engine Heartbeat")
                    // This ensures the cursor updates exactly when the game renders, removing jitter.
                    app.ticker.add(() => {
                        // 1. Cursor handling moved to CSS/HTML


                        // 2. Update World Highlight
                        if (world.scale.x !== 0) {
                            const worldX = (mouse.x - world.x) / world.scale.x;
                            const worldY = (mouse.y - world.y) / world.scale.y;

                            hoveredTileX = Math.floor(worldX / TILE_SIZE);
                            hoveredTileY = Math.floor(worldY / TILE_SIZE);

                            if (selectSprite) {
                                selectSprite.x = hoveredTileX * TILE_SIZE;
                                selectSprite.y = hoveredTileY * TILE_SIZE;
                            }
                        }
                    }, PIXI.UPDATE_PRIORITY.INTERACTION); // High priority update

                    // Mouse down - change to pressed texture
                    window.addEventListener('mousedown', (e) => {
                        if (e.button === 0) {
                            mouse.left = true;
                            // Change texture if selectSprite is ready
                            if (selectSprite) selectSprite.texture = selectTexPressed;
                        } else if (e.button === 2) {
                            mouse.right = true;
                        }
                    });

                    // Mouse up - change back to normal texture
                    window.addEventListener('mouseup', (e) => {
                        if (e.button === 0) {
                            mouse.left = false;
                            if (selectSprite) selectSprite.texture = selectTexNormal;
                        } else if (e.button === 2) {
                            mouse.right = false;
                        }
                    });


                    // Calculate average colors for LOD rendering
                    function getAverageColor(texture) {
                        const canvas = document.createElement('canvas');
                        const ctx = canvas.getContext('2d');
                        canvas.width = texture.width;
                        canvas.height = texture.height;

                        // Draw texture to canvas
                        const img = texture.source.resource;
                        ctx.drawImage(img, 0, 0);

                        // Get pixel data
                        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                        const data = imageData.data;

                        let r = 0, g = 0, b = 0, count = 0;
                        for (let i = 0; i < data.length; i += 4) {
                            // Skip transparent pixels (alpha < 128)
                            if (data[i + 3] >= 128) {
                                r += data[i];
                                g += data[i + 1];
                                b += data[i + 2];
                                count++;
                            }
                        }

                        r = Math.floor(r / count);
                        g = Math.floor(g / count);
                        b = Math.floor(b / count);

                        return (r << 16) | (g << 8) | b; // Return as hex color
                    }

                    const avgDirtColor = getAverageColor(dirtTex);
                    const avgGrassColor = getAverageColor(grassTex);


                    // ASYNC Pre-generation (Networked)
                    // Connect to Java Server (localhost:25565)
                    const SERVER_URL = 'http://localhost:25565';

                    // Hide Canvas initially
                    app.canvas.style.opacity = '0';
                    app.canvas.style.transition = 'opacity 1s';

                    // SIMPLE LOAD STRATEGY (User Request)
                    // 1. Connect to Server
                    // 2. Spawn Randomly
                    // 3. Load Circle Radius (Render Distance)
                    // 4. Start Game Loop

                    app.canvas.style.opacity = '0'; // Fade in effect
                    app.canvas.style.transition = 'opacity 1s';

                    async function simpleStart() {
                        // 1. Load Player Position from DB
                        // 1. Load Player Position from DB (REMOVED)
                        // if (db) { ... }

                        // 2. Start Game Loop Immediately (No network pre-loading needed)
                        startGameLoop();
                        app.canvas.style.opacity = '1';
                    }

                    // Start Game
                    simpleStart();

                    // Incremental GC State
                    let gcIterator = null;
                    const GC_RADIUS = config.renderDistance + 5; // Reduced from +20 to clear cache faster

                    let lastTime = performance.now();

                    // WRAPPED Game Loop (Started after loading)
                    function startGameLoop() {
                        let lastTime = performance.now();
                        let lastLODState = false; // Track LOD state for threshold crossing

                        app.ticker.add((ticker) => {
                            // Incremental Garbage Collection (Process 20 chunks per frame)
                            if (!gcIterator) gcIterator = chunks.keys();

                            const playerChunkX = Math.round(player.x / TILE_SIZE / CHUNK_SIZE);
                            const playerChunkY = Math.round(player.y / TILE_SIZE / CHUNK_SIZE);

                            let gcCount = 0;
                            while (gcCount < 20) {
                                const next = gcIterator.next();
                                if (next.done) {
                                    gcIterator = chunks.keys(); // Restart
                                    break;
                                }
                                const key = next.value;
                                const [cx, cy] = key.split(',').map(Number);
                                const dist = Math.max(Math.abs(cx - playerChunkX), Math.abs(cy - playerChunkY));

                                // Only delete if REALLY far (GC Radius)
                                if (dist > GC_RADIUS) {
                                    chunks.delete(key);
                                }
                                gcCount++;
                            }

                            // Time Delta
                            const time = performance.now();
                            const dt = Math.min((time - lastTime) / 1000, 0.1);
                            lastTime = time;

                            // Camera movement (WASD)
                            let moveX = 0, moveY = 0;
                            if (keys['a'] || keys['arrowleft']) moveX = -1;
                            if (keys['d'] || keys['arrowright']) moveX = 1;
                            if (keys['w'] || keys['arrowup']) moveY = -1;
                            if (keys['s'] || keys['arrowdown']) moveY = 1;

                            // Normalize diagonal movement
                            if (moveX !== 0 && moveY !== 0) {
                                moveX *= 0.707;
                                moveY *= 0.707;
                            }

                            // Movement logic - WASD only works in normal mode
                            if (!isAltPressed) {
                                // Normal mode: WASD moves player, camera follows
                                player.x += moveX * player.speed * dt;
                                player.y += moveY * player.speed * dt;
                                camera.x = player.x + player.width / 2;
                                camera.y = player.y + player.height / 2;

                                // Trigger Auto-Save on movement (Debounced)
                                if (moveX !== 0 || moveY !== 0) {
                                    triggerSave();
                                }
                            }
                            // In freelook mode, camera is moved by mouse drag only (no WASD)

                            // Update stats (FPS, location, zoom) with null checks
                            const fps = Math.round(app.ticker.FPS || 0);
                            const locX = player ? Math.floor(player.x) : 0;
                            const locY = player ? Math.floor(player.y) : 0;
                            const zoom = camera ? camera.zoom.toFixed(2) : '0.00';
                            const infoElement = document.getElementById('info');
                            if (infoElement) {
                                infoElement.textContent = `FPS: ${fps} | x: ${locX} y: ${locY} | Zoom: ${zoom}x`;
                            }

                            // Update world-mouse interaction every frame (fixes "laggy" highlight on camera move)
                            // Calculate world coordinates from mouse screen position
                            // world.x/y are the screen center offsets? No, world transform is: 
                            // world.x = -camera.x * zoom + screenW/2
                            // mouseScreen = worldPos * zoom + world.x
                            // worldPos = (mouseScreen - world.x) / zoom

                            // Use world.scale.x which is set to camera.zoom in this loop
                            if (world.scale.x !== 0) {
                                const worldX = (mouse.x - world.x) / world.scale.x;
                                const worldY = (mouse.y - world.y) / world.scale.y;

                                hoveredTileX = Math.floor(worldX / TILE_SIZE);
                                hoveredTileY = Math.floor(worldY / TILE_SIZE);
                            }

                            // Update select sprite position to hovered tile
                            if (hoveredTileX !== null && hoveredTileY !== null) {
                                selectSprite.x = hoveredTileX * TILE_SIZE;
                                selectSprite.y = hoveredTileY * TILE_SIZE;
                            }

                            // Handle input (left=break/dirt, right=place/grass)
                            const isInteractable = !isAltPressed && !camera.freelook;

                            // Only allow building in normal mode, not in freelook
                            if ((mouse.left || mouse.right) && isInteractable) {
                                const worldX = Math.floor((mouse.x - world.x) / camera.zoom / TILE_SIZE);
                                const worldY = Math.floor((mouse.y - world.y) / camera.zoom / TILE_SIZE);
                                const val = mouse.right ? 1 : 0;

                                if (mouse.lastX !== undefined && mouse.lastY !== undefined) {
                                    // Bresenham's Line Algorithm for smooth drawing
                                    let x0 = mouse.lastX;
                                    let y0 = mouse.lastY;
                                    const x1 = worldX;
                                    const y1 = worldY;
                                    const dx = Math.abs(x1 - x0);
                                    const dy = Math.abs(y1 - y0);
                                    const sx = (x0 < x1) ? 1 : -1;
                                    const sy = (y0 < y1) ? 1 : -1;
                                    let err = dx - dy;

                                    while (true) {
                                        setTile(x0, y0, val);
                                        if (x0 === x1 && y0 === y1) break;
                                        const e2 = 2 * err;
                                        if (e2 > -dy) { err -= dy; x0 += sx; }
                                        if (e2 < dx) { err += dx; y0 += sy; }
                                    }
                                } else {
                                    setTile(worldX, worldY, val);
                                }

                                mouse.lastY = worldY;

                                // Trigger Immediate Save for Loop Stability/Modifications
                                // We don't wait for movement for block changes.
                                // But to avoid spamming network on every pixel drawn in line, we might want to debounce too?
                                // User said: "whenever a event is happening like player is moving or block changed"
                                // Let's use the same debounce trigger, or make it slightly faster?
                                triggerSave();
                            } else {
                                // Reset last position if not clicking
                                mouse.lastX = undefined;
                                mouse.lastY = undefined;
                            }

                            // Hide selection sprite in freelook mode
                            if (selectSprite) {
                                selectSprite.visible = isInteractable && hoveredTileX !== null && hoveredTileY !== null;
                            }

                            render();
                            renderOverlays();


                            // Transform world (camera system - center camera position on screen)
                            // Reverted rounding to fix diagonal movement feel
                            world.scale.set(camera.zoom);
                            world.x = -camera.x * camera.zoom + app.screen.width / 2;
                            world.y = -camera.y * camera.zoom + app.screen.height / 2;

                            // Crosshair Position Update Removed


                            // Cursor is now updated in 'mousemove' listener for zero latency.
                            // Removed game loop update to prevent fighting/jitter.

                            // Process Dirty Chunks (Batch Rendering)
                            // Process Dirty Chunks (Batch Rendering) - With Distance Culling to prevent autogen loop
                            if (dirtyChunks.size > 0 && renderChunk) {
                                // SNAPSHOT: Create array copy and clear Set immediately.
                                // This prevents infinite loops where rendering adds new dirty chunks during the same frame.
                                const batch = Array.from(dirtyChunks);
                                dirtyChunks.clear();

                                // Calculate center chunk for culling
                                const centerCX = Math.floor(camera.x / TILE_SIZE / CHUNK_SIZE);
                                const centerCY = Math.floor(camera.y / TILE_SIZE / CHUNK_SIZE);
                                const renderCap = config.renderDistance + 4; // Allow small buffer

                                for (const key of batch) {
                                    const [cx, cy] = key.split(',').map(Number);

                                    // SAFETY: Skip rendering if too far (Prevents infinite generation loop)
                                    if (Math.abs(cx - centerCX) > renderCap || Math.abs(cy - centerCY) > renderCap) {
                                        continue;
                                    }

                                    // Remove old container FIRST
                                    if (chunkContainers.has(key)) {
                                        const containers = chunkContainers.get(key);
                                        if (containers.dirt) {
                                            dirtLayer.removeChild(containers.dirt);
                                            containers.dirt.destroy({ children: true });
                                        }
                                        if (containers.grass) {
                                            grassLayer.removeChild(containers.grass);
                                            containers.grass.destroy({ children: true });
                                        }
                                        chunkContainers.delete(key);
                                    }
                                    // Re-render
                                    renderChunk(cx, cy);
                                }
                            }


                            // Render function - chunk-based with caching

                            // Chunk Rendering Function - assign to outer scope variable
                            renderChunk = function (cx, cy) {
                                const key = `${cx},${cy}`;

                                // Check if chunk data exists. If not, request it and skip this frame
                                if (!chunks.has(key)) {
                                    // Request from Server (Via Worker) - only if worker is ready
                                    if (typeof fetchChunkViaWorker === 'function') {
                                        fetchChunkViaWorker(cx, cy);
                                    }
                                    return; // Will render next frame when data arrives
                                }

                                const chunk = getChunk(cx, cy);
                                const chunkDirt = new PIXI.Container();
                                const chunkGrass = new PIXI.Container();

                                // LOD: If zoomed out below threshold, render simple colored tiles (Minimap style)
                                if (camera.zoom < config.lodThreshold) {
                                    const graphics = new PIXI.Graphics();

                                    // Draw each tile as a simple colored rectangle
                                    for (let ty = 0; ty < CHUNK_SIZE; ty++) {
                                        for (let tx = 0; tx < CHUNK_SIZE; tx++) {
                                            const tileVal = chunk[ty][tx];
                                            const color = tileVal === 1 ? avgGrassColor : avgDirtColor;

                                            graphics.beginFill(color);
                                            graphics.drawRect(
                                                (cx * CHUNK_SIZE + tx) * TILE_SIZE,
                                                (cy * CHUNK_SIZE + ty) * TILE_SIZE,
                                                TILE_SIZE,
                                                TILE_SIZE
                                            );
                                            graphics.endFill();
                                        }
                                    }

                                    chunkDirt.addChild(graphics);
                                    chunkContainers.set(key, { dirt: chunkDirt, grass: chunkGrass });

                                    dirtLayer.addChild(chunkDirt);

                                    return;
                                }

                                // Render all tiles in this chunk
                                for (let ty = 0; ty < CHUNK_SIZE; ty++) {
                                    for (let tx = 0; tx < CHUNK_SIZE; tx++) {
                                        const worldX = cx * CHUNK_SIZE + tx;
                                        const worldY = cy * CHUNK_SIZE + ty;

                                        // Dirt tile -> Dirt Layer
                                        const dirtIdx = getDirtIdx(worldX, worldY);
                                        const dirtTexture = getTileTexture(dirtTex, dirtIdx);
                                        const dirtSprite = new PIXI.Sprite(dirtTexture);
                                        dirtSprite.x = worldX * TILE_SIZE;
                                        dirtSprite.y = worldY * TILE_SIZE;
                                        dirtSprite.width = TILE_SIZE;
                                        dirtSprite.height = TILE_SIZE;
                                        chunkDirt.addChild(dirtSprite);

                                        // Grass tile -> Grass Layer
                                        // Use getTileSafe to avoid triggering chunk fetches during render
                                        const hasGrass = getTileSafe(worldX, worldY) === 1 ||
                                            getTileSafe(worldX + 1, worldY) === 1 ||
                                            getTileSafe(worldX, worldY + 1) === 1 ||
                                            getTileSafe(worldX + 1, worldY + 1) === 1;

                                        if (hasGrass) {
                                            const grassIdx = getGrassIdx(worldX, worldY);
                                            const grassTexture = getTileTexture(grassTex, grassIdx);
                                            const grassSprite = new PIXI.Sprite(grassTexture);

                                            // Aligned to White Grid (Dual Grid) - Use Center Anchor
                                            grassSprite.anchor.set(0.5);
                                            grassSprite.x = (worldX + 1) * TILE_SIZE;
                                            grassSprite.y = (worldY + 1) * TILE_SIZE;

                                            grassSprite.width = TILE_SIZE;
                                            grassSprite.height = TILE_SIZE;
                                            chunkGrass.addChild(grassSprite);
                                        }
                                    }
                                }

                                chunkContainers.set(key, { dirt: chunkDirt, grass: chunkGrass });
                                dirtLayer.addChild(chunkDirt);
                                grassLayer.addChild(chunkGrass);
                            }

                            function render() {
                                // Skip if renderChunk not ready yet
                                if (!renderChunk) return;

                                // Reset chunk count each frame
                                chunksRendered = 0;

                                // Check if we crossed LOD threshold
                                const currentLODState = camera.zoom < config.lodThreshold;
                                if (lastLODState !== currentLODState) {
                                    // Clear all chunks when crossing LOD threshold
                                    for (const [key, containers] of chunkContainers.entries()) {
                                        if (containers.dirt) {
                                            dirtLayer.removeChild(containers.dirt);
                                            containers.dirt.destroy();
                                        }
                                        if (containers.grass) {
                                            grassLayer.removeChild(containers.grass);
                                            containers.grass.destroy();
                                        }
                                    }
                                    chunkContainers.clear();
                                    lastLODState = currentLODState;
                                }

                                // AGGRESSIVE GC: Prevent memory leaks
                                if (chunks.size > 1000) {
                                    // Calculate player chunk position for GC
                                    const playerChunkX = Math.floor(player.x / TILE_SIZE / CHUNK_SIZE);
                                    const playerChunkY = Math.floor(player.y / TILE_SIZE / CHUNK_SIZE);
                                    const renderDistance = config.renderDistance;

                                    // Force cleanup of ANY chunk outside view + buffer
                                    for (const key of chunks.keys()) {
                                        const [cx, cy] = key.split(',').map(Number);
                                        if (Math.abs(cx - playerChunkX) > renderDistance + 2 ||
                                            Math.abs(cy - playerChunkY) > renderDistance + 2) {
                                            chunks.delete(key);
                                        }
                                    }
                                }

                                // Calculate visible bounds based on viewport
                                const viewHalfW = (app.screen.width / camera.zoom) / 2;
                                const viewHalfH = (app.screen.height / camera.zoom) / 2;

                                // Convert to chunk coordinates - limit to render distance from config
                                const maxRenderDist = Math.min(config.renderDistance, 32); // Increased cap for Infinite World feel

                                // Calculate viewport-based chunk range
                                // Increased pad (2 chunks) to prevent clipping of edge sprites (Dual Grid)
                                let startChunkX = Math.floor((camera.x - viewHalfW) / (TILE_SIZE * CHUNK_SIZE)) - 2;
                                let endChunkX = Math.ceil((camera.x + viewHalfW) / (TILE_SIZE * CHUNK_SIZE)) + 2;
                                let startChunkY = Math.floor((camera.y - viewHalfH) / (TILE_SIZE * CHUNK_SIZE)) - 2;
                                let endChunkY = Math.ceil((camera.y + viewHalfH) / (TILE_SIZE * CHUNK_SIZE)) + 2;

                                // Also limit by render distance from player chunk
                                const playerChunkXCenter = Math.floor(player.x / TILE_SIZE / CHUNK_SIZE);
                                const playerChunkYCenter = Math.floor(player.y / TILE_SIZE / CHUNK_SIZE);
                                startChunkX = Math.max(startChunkX, playerChunkXCenter - maxRenderDist);
                                endChunkX = Math.min(endChunkX, playerChunkXCenter + maxRenderDist);
                                startChunkY = Math.max(startChunkY, playerChunkYCenter - maxRenderDist);
                                endChunkY = Math.min(endChunkY, playerChunkYCenter + maxRenderDist);

                                // Determine which chunks should be visible
                                const chunksToRender = new Set();
                                for (let cy = startChunkY; cy <= endChunkY; cy++) {
                                    for (let cx = startChunkX; cx <= endChunkX; cx++) {
                                        chunksToRender.add(`${cx},${cy}`);
                                    }
                                }

                                // Remove chunks that are out of range
                                for (const [key, containers] of chunkContainers.entries()) {
                                    if (!chunksToRender.has(key)) {
                                        if (containers.dirt) {
                                            dirtLayer.removeChild(containers.dirt);
                                            containers.dirt.destroy({ children: true });
                                        }
                                        if (containers.grass) {
                                            grassLayer.removeChild(containers.grass);
                                            containers.grass.destroy({ children: true });
                                        }
                                        chunkContainers.delete(key);
                                    }
                                }

                                // Render new chunks (only if not already rendered)
                                // Time Slicing Scale: More chunks if zoomed out
                                const MAX_CHUNKS_PER_FRAME = config.maxChunksPerFrame || 10;
                                let chunksCreated = 0;

                                // Loop through chunks (standard scanline order: top-to-bottom)
                                for (const key of chunksToRender) {
                                    if (!chunkContainers.has(key)) {
                                        if (chunksCreated < MAX_CHUNKS_PER_FRAME) {
                                            const [cx, cy] = key.split(',').map(Number);
                                            renderChunk(cx, cy);
                                            chunksCreated++;
                                        }
                                        // If we hit limit, we just stop creating for this frame. 
                                        // They will be picked up next frame.
                                    }
                                    chunksRendered++;
                                }

                                // Update stats - Cached and Rendered (no Loading indicator)
                                const fps = Math.round(app.ticker.FPS);
                                const activeChunks = chunkContainers.size;
                                const cachedChunks = chunks.size;
                                document.getElementById('info').textContent = `FPS: ${fps} | x: ${Math.floor(player.x)} y: ${Math.floor(player.y)} | Zoom: ${camera.zoom.toFixed(2)}x | Rendered: ${activeChunks} | Cached: ${cachedChunks}`;


                            } // End render

                            // Update Grid Positions
                            if (typeof renderOverlays === 'function') renderOverlays();
                        });
                    } // End startGameLoop

                    // Render overlays (grid, highlights, etc) - called after chunk rendering
                    let overlayGraphics = null;

                    function renderOverlays() {
                        // Skip overlay rendering entirely if grid is disabled (massive performance boost)
                        if (!showGrid) {
                            if (overlayGraphics) {
                                world.removeChild(overlayGraphics);
                                overlayGraphics.destroy();
                                overlayGraphics = null;
                            }
                            if (window.gridRed) window.gridRed.visible = false;
                            if (window.gridWhite) window.gridWhite.visible = false;
                            return; // Exit function
                        }

                        // reuse graphics   
                        if (overlayGraphics) {
                            overlayGraphics.clear();
                        } else {
                            overlayGraphics = new PIXI.Graphics();
                        }

                        // Calculate visible area
                        const playerChunkX = Math.round(player.x / TILE_SIZE / CHUNK_SIZE);
                        const playerChunkY = Math.round(player.y / TILE_SIZE / CHUNK_SIZE);
                        const renderDistance = Math.min(5, Math.ceil(5 / Math.max(camera.zoom, 1.0)));
                        const startX = (playerChunkX - renderDistance) * CHUNK_SIZE;
                        const endX = (playerChunkX + renderDistance + 1) * CHUNK_SIZE;
                        const startY = (playerChunkY - renderDistance) * CHUNK_SIZE;
                        const endY = (playerChunkY + renderDistance + 1) * CHUNK_SIZE;


                        // OPTIMIZED GRID RENDERING (TilingSprite)
                        // Initialize TilingSprites once if not exists
                        if (!window.gridRed) {
                            // Create Red Grid Texture (16x16 with red border)
                            const cvsRed = document.createElement('canvas');
                            cvsRed.width = TILE_SIZE; cvsRed.height = TILE_SIZE;
                            const ctxRed = cvsRed.getContext('2d');
                            ctxRed.lineWidth = 1;
                            ctxRed.strokeStyle = 'rgba(255, 0, 0, 0.5)';
                            ctxRed.strokeRect(0, 0, TILE_SIZE, TILE_SIZE);
                            const texRed = PIXI.Texture.from(cvsRed);
                            window.gridRed = new PIXI.TilingSprite(texRed, app.screen.width, app.screen.height);
                            window.gridRed.alpha = 1.0;
                            window.gridRed.zIndex = 2000;
                            window.gridRed.visible = false;
                            world.addChild(window.gridRed);
                        }

                        if (!window.gridWhite) {
                            // Create White Grid Texture (16x16 with VERY thin white border)
                            const cvsWhite = document.createElement('canvas');
                            cvsWhite.width = TILE_SIZE; cvsWhite.height = TILE_SIZE;
                            const ctxWhite = cvsWhite.getContext('2d');
                            // Use 0.5px line for thinner appearance
                            ctxWhite.lineWidth = 0.5;
                            ctxWhite.strokeStyle = 'rgba(255, 255, 255, 0.15)'; // Very subtle
                            ctxWhite.strokeRect(0.25, 0.25, TILE_SIZE - 0.5, TILE_SIZE - 0.5);
                            const texWhite = PIXI.Texture.from(cvsWhite);
                            window.gridWhite = new PIXI.TilingSprite(texWhite, app.screen.width, app.screen.height);
                            window.gridWhite.alpha = 0.5; // Even more transparent
                            window.gridWhite.zIndex = 2001;
                            window.gridWhite.visible = false;
                            world.addChild(window.gridWhite);
                        }

                        // Update Grid Visibility and Position
                        window.gridRed.visible = true;
                        window.gridWhite.visible = true;

                        // Align grid with World View (Camera)
                        // TilingSprite pattern origin is at (0,0) of the sprite.
                        // We move the sprite to cover the view.
                        const viewX = camera.x - (app.screen.width / camera.zoom / 2);
                        const viewY = camera.y - (app.screen.height / camera.zoom / 2);
                        const viewW = app.screen.width / camera.zoom;
                        const viewH = app.screen.height / camera.zoom;

                        // 1. Position the TilingSprite to cover the camera view
                        // We snap it to TILE_SIZE to avoid jitter, but TilingSprite handles subpixel logic if we set tilePosition?
                        // Actually, simpler: Set sprite to ViewRect. Set tilePosition to (ViewX, ViewY).

                        window.gridRed.width = viewW + TILE_SIZE * 2;
                        window.gridRed.height = viewH + TILE_SIZE * 2;
                        window.gridRed.x = Math.floor(viewX / TILE_SIZE) * TILE_SIZE;
                        window.gridRed.y = Math.floor(viewY / TILE_SIZE) * TILE_SIZE;
                        // Shift texture pattern opposite to movement to stick to world?
                        // If sprite is at worldX, worldY... and texture is 16x16.
                        // If we move sprite 16px, pattern matches.
                        // So we don't need to change tilePosition if we snap x/y to grid!
                        window.gridRed.tilePosition.x = 0;
                        window.gridRed.tilePosition.y = 0;

                        // White Grid (Offset 8px)
                        window.gridWhite.width = viewW + TILE_SIZE * 2;
                        window.gridWhite.height = viewH + TILE_SIZE * 2;
                        window.gridWhite.x = window.gridRed.x - (TILE_SIZE / 2);
                        window.gridWhite.y = window.gridRed.y - (TILE_SIZE / 2);
                        window.gridWhite.tilePosition.x = 0;
                        window.gridWhite.tilePosition.y = 0;


                        // 1. Green shades for grass tiles (Keep loop for now, hard to tile-sprite)
                        for (let y = startY; y < endY; y++) {
                            for (let x = startX; x < endX; x++) {
                                if (getTile(x, y) === 1) {
                                    overlayGraphics.beginFill(0x00ff00, 0.15); // Slightly more visible green shade
                                    overlayGraphics.drawRect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE);
                                    overlayGraphics.endFill();
                                }
                            }
                        }

                        // 2. Blue chunk boundaries
                        overlayGraphics.lineStyle(2, 0x0000ff, 0.5);
                        const chunkStartX = Math.floor(startX / CHUNK_SIZE) * CHUNK_SIZE;
                        const chunkEndX = Math.ceil(endX / CHUNK_SIZE) * CHUNK_SIZE;
                        const chunkStartY = Math.floor(startY / CHUNK_SIZE) * CHUNK_SIZE;
                        const chunkEndY = Math.ceil(endY / CHUNK_SIZE) * CHUNK_SIZE;

                        for (let x = chunkStartX; x <= chunkEndX; x += CHUNK_SIZE) {
                            overlayGraphics.moveTo(x * TILE_SIZE, chunkStartY * TILE_SIZE);
                            overlayGraphics.lineTo(x * TILE_SIZE, chunkEndY * TILE_SIZE);
                        }
                        for (let y = chunkStartY; y <= chunkEndY; y += CHUNK_SIZE) {
                            overlayGraphics.moveTo(chunkStartX * TILE_SIZE, y * TILE_SIZE);
                            overlayGraphics.lineTo(chunkEndX * TILE_SIZE, y * TILE_SIZE);
                        }
                        overlayGraphics.stroke();

                        overlayGraphics.zIndex = 2002;
                        world.addChild(overlayGraphics);
                    } // End renderOverlays


                    // HTML Cursor Logic (Simple Follower)
                    const follower = document.getElementById("follower-element");
                    window.addEventListener('mousemove', (event) => {
                        const clientX = event.clientX;
                        const clientY = event.clientY;
                        follower.style.left = `${clientX}px`;
                        follower.style.top = `${clientY}px`;
                    });


                    // CHUNK FETCHER INTEGRATION (Background Network Thread)
                    // This background thread just DOWNLOADS data from Java. It does not generate it.
                    const workerCode = `
        const SERVER_URL = 'http://localhost:25565';
        const CHUNK_SIZE = 16;

        self.onmessage = async function (e) {
            const { type, cx, cy } = e.data;

            if (type === 'fetchChunk') {
                try {
                    const res = await fetch(SERVER_URL + '/chunk?x=' + cx + '&y=' + cy);
                    if (res.ok) {
                        // Response is raw string "101010..." (256 chars)
                        // Use text(), not json() because server sends text/plain
                        let rawData = await res.text();
                        
                        // SANITIZATION: Remove any newlines just in case DB has legacy data
                        rawData = rawData.replace(/[\\n\\r]/g, '');

                        const chunk2D = [];
                        for (let y = 0; y < CHUNK_SIZE; y++) {
                            chunk2D[y] = [];
                            for (let x = 0; x < CHUNK_SIZE; x++) {
                                // Linear mapping: index = y * CHUNK_SIZE + x
                                const idx = y * CHUNK_SIZE + x;
                                chunk2D[y][x] = parseInt(rawData[idx] || '0');
                            }
                        }

                        self.postMessage({
                            type: 'chunkData',
                            cx, cy,
                            data: chunk2D
                        });
                    } else {
                        self.postMessage({ type: 'chunkError', cx, cy });
                    }
                } catch (err) {
                    self.postMessage({ type: 'chunkError', cx, cy, error: err.message });
                }
            }
        };
        `;

                    const blob = new Blob([workerCode], { type: 'application/javascript' });
                    const chunkFetcher = new Worker(URL.createObjectURL(blob));
                    chunkFetcher.onmessage = function (e) {
                        const { type, cx, cy, data } = e.data;
                        const key = `${cx},${cy}`;
                        if (type === 'chunkData') {
                            const chunk2D = data; // Received 2D JSON Array directly
                            chunks.set(key, chunk2D);

                            // EVENT-DRIVEN RENDERING (User Request: "Constant Render / Perfect Loop")
                            // Immediately render the chunk when data arrives. No "Dirty" state.
                            if (renderChunk) {
                                renderChunk(cx, cy);
                                // Update neighbors (Autotiling edges)
                                renderChunk(cx - 1, cy);
                                renderChunk(cx + 1, cy);
                                renderChunk(cx, cy - 1);
                                renderChunk(cx, cy + 1);
                            }
                        }
                    };

                    fetchChunkViaWorker = function (cx, cy) {
                        // Ensure unique request
                        const key = `${cx},${cy}`;
                        if (pendingChunks.has(key) || chunks.has(key)) return;
                        pendingChunks.add(key);
                        chunkFetcher.postMessage({ type: 'fetchChunk', cx, cy });
                    };

                    // Save World Function
                    // Save World Function (Auto-Save Optimized)
                    async function saveWorld() {
                        if (!socket || socket.readyState !== WebSocket.OPEN) {
                            console.warn("Cannot save: WS not connected");
                            alert("Cannot save: Server Disconnected");
                            return;
                        }

                        const saveData = {
                            type: "save",
                            player: {
                                x: player.x,
                                y: player.y
                            },
                            chunks: []
                        };

                        // Gather Modified Chunks
                        if (modifiedChunks.size > 0) {
                            for (const key of modifiedChunks) {
                                if (chunks.has(key)) {
                                    const chunk = chunks.get(key);
                                    // Flatten
                                    let dataStr = '';
                                    for (let y = 0; y < CHUNK_SIZE; y++) {
                                        for (let x = 0; x < CHUNK_SIZE; x++) {
                                            dataStr += chunk[y][x];
                                        }
                                    }
                                    saveData.chunks.push({
                                        key: key,
                                        data: dataStr
                                    });
                                }
                            }
                        }

                        // Needed for the specific manual parser on server which expects a flat list sometimes or specific keys?
                        // The server parser looks for "key":"..." then "data":"..." repeatedly.
                        // JSON.stringify will produce `... "chunks":[{"key":"...", "data":"..."}, ...] ...`
                        // My robust parser in Java (the loop) should handle this standard JSON array format fine 
                        // because it searches for "key": and "data": sequentially.

                        console.log("Sending Save via WebSocket...");
                        sendJson(saveData);

                        // Clear modified set locally (optimistic)
                        modifiedChunks.clear();

                        const btn = document.getElementById('saveBtn');
                        if (btn) btn.innerText = "Saving...";
                    }

                    async function persistDB() {
                        // DB REMOVED
                    }



                    // Event-Driven Auto-Save Logic
                    let saveTimeout = null;
                    const SAVE_DELAY = 2000; // 2 seconds of inactivity before saving player position

                    function triggerSave() {
                        // If already saving, ignore or debounce?
                        // Simple debounce: reset timer
                        if (saveTimeout) clearTimeout(saveTimeout);
                        saveTimeout = setTimeout(() => {
                            saveWorld();
                            saveTimeout = null;
                        }, SAVE_DELAY);
                    }
                }); // End Promise.all().then()
            } // End initGame

            // --- WebSocket Multiplayer Logic ---
            let socket;
            const otherPlayers = new Map(); // id -> {x, y, sprite}

            function initMultiplayer() {
                try {
                    socket = new WebSocket('ws://localhost:25566');
                    window.socket = socket; // Make socket globally accessible for getChunk

                    socket.onopen = () => {
                        console.log("[WS] Connected to Multiplayer Server");
                        // Send identification or join packet?
                        // For now just start sending position
                    };

                    socket.onmessage = (event) => {
                        const msg = event.data;
                        try {
                            const data = JSON.parse(msg);

                            // 1. Position Update
                            if (data.type === 'pos') {
                                if (data.id === socket.uuid) return;
                                updateRemotePlayer(data.id, data.x, data.y);
                            }
                            // 2. Chunk Data Received
                            else if (data.type === 'chunk') {
                                const key = data.key;
                                const rawData = data.data; // "001010..."

                                // Parse Data
                                const chunk2D = [];
                                for (let y = 0; y < CHUNK_SIZE; y++) {
                                    chunk2D[y] = [];
                                    for (let x = 0; x < CHUNK_SIZE; x++) {
                                        chunk2D[y][x] = parseInt(rawData[y * CHUNK_SIZE + x]);
                                    }
                                }

                                chunks.set(key, chunk2D);
                                if (window.requestedChunks) window.requestedChunks.delete(key);

                                // Force Re-Render of this chunk if near
                                // (The main loop will pick it up on next frame automatically)
                            }
                            // 3. Save Acknowledgement
                            else if (data.type === 'saveAck') {
                                console.log("[WS] Save Successful! Chunks saved:", data.count);
                                // Update UI if needed
                                const btn = document.getElementById('saveBtn');
                                if (btn) {
                                    btn.innerText = "Saved!";
                                    setTimeout(() => btn.innerText = "Save Game", 2000);
                                }
                            }

                        } catch (e) {
                            console.warn("WS Parse Error", e);
                        }
                    };

                    socket.onclose = () => {
                        console.log("[WS] Disconnected. Retrying in 5s...");
                        setTimeout(initMultiplayer, 5000);
                    };

                } catch (e) {
                    console.error("[WS] Connection Failed", e);
                }
            }

            function sendJson(data) {
                if (socket && socket.readyState === WebSocket.OPEN) {
                    socket.send(JSON.stringify(data));
                }
            }

            // Generate a simple ID for this session
            const myId = Date.now().toString();

            function updateRemotePlayer(id, x, y) {
                if (!world) return;

                let p = otherPlayers.get(id);
                if (!p) {
                    // Create new sprite for other player
                    const graphics = new PIXI.Graphics();
                    graphics.beginFill(0xFF0000); // Red for other players
                    graphics.drawRect(0, 0, 16, 16);
                    graphics.endFill();

                    p = { sprite: graphics, targetX: x, targetY: y };
                    p.sprite.x = x;
                    p.sprite.y = y;
                    p.sprite.zIndex = 100;

                    world.addChild(p.sprite);
                    otherPlayers.set(id, p);
                }

                // Update target for interpolation
                p.targetX = x;
                p.targetY = y;
                // Instant snap for now, or lerp in ticker?
                p.sprite.x = x;
                p.sprite.y = y;
            }

            // Start Multiplayer
            setTimeout(initMultiplayer, 1000);

            // Broadcast loop
            setInterval(() => {
                if (socket && socket.readyState === WebSocket.OPEN && player) {
                    const payload = JSON.stringify({
                        type: 'pos',
                        id: myId,
                        x: player.x,
                        y: player.y
                    });
                    socket.send(payload);
                }
            }, 50); // 20 times per second

        }); // End window.addEventListener

        // Initialize (One-time save on close?)
        window.addEventListener('beforeunload', () => {
            // Try to fire a beacon or sync save? HARD to do reliably.
            // Rely on the frequent triggers.
        });

    </script>
</body>

</html>