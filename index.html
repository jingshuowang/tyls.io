<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8">
    <title>tyls.io</title>
    <!-- PixiJS Library v7 (stable) -->
    <script src="https://cdn.jsdelivr.net/npm/pixi.js@7.x/dist/pixi.min.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #000;
            overflow: hidden;
            font-family: monospace;
            cursor: none;
            /* Hide system cursor */
        }

        #ui {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            font-size: 12px;
            text-shadow: 1px 1px 2px black;
            background: rgba(0, 0, 0, 0.5);
            padding: 10px;
            border-radius: 5px;
            z-index: 100;
        }

        .error {
            color: #ff4444;
            font-weight: bold;
            font-size: 14px;
        }
    </style>
</head>

<body>
    <div id="pos"
        style="position: absolute; top: 10px; left: 10px; color: white; font-size: 12px; text-shadow: 1px 1px 2px black; background: rgba(0, 0, 0, 0.5); padding: 10px; border-radius: 5px; z-index: 100; font-family: monospace;">
    </div>

    <script>
        // Error handling
        let hasError = false;
        window.addEventListener('error', (e) => {
            hasError = true;
            const errorDiv = document.getElementById('pos');
            errorDiv.innerHTML = `<span class="error">❌ ERROR: ${e.message}<br>Line: ${e.lineno}<br>Check console (F12)</span>`;
            console.error('%c ❌ ERROR:', 'color: red; font-size: 20px; font-weight: bold', e.message);
            console.error('File:', e.filename, 'Line:', e.lineno, 'Col:', e.colno);
            console.error(e.error);
        });

        // Wait for PixiJS to load
        window.addEventListener('load', () => {
            try {
                // PixiJS v7 Application Setup
                const app = new PIXI.Application({
                    width: window.innerWidth,
                    height: window.innerHeight,
                    backgroundColor: 0x1a1a1a,
                    resolution: window.devicePixelRatio || 1,
                    autoDensity: true,
                    antialias: false // Disable for pixel-perfect rendering
                });
                document.body.appendChild(app.view);

                // Force pixel-perfect rendering
                app.renderer.view.style.imageRendering = 'pixelated';
                app.renderer.view.style.imageRendering = 'crisp-edges';

                // Handle window resize
                window.addEventListener('resize', () => {
                    app.renderer.resize(window.innerWidth, window.innerHeight);
                });

                // Constants
                const TILE_SIZE = 16;
                const CHUNK_SIZE = 16;
                const CHUNK_PIXEL_SIZE = CHUNK_SIZE * TILE_SIZE;

                // Load textures with error handling
                const grassTexture = PIXI.Texture.from('Assets/Image/Tile/grass.png');
                const dirtTexture = PIXI.Texture.from('Assets/Image/Tile/dirt.png');
                const frameTexture = PIXI.Texture.from('Assets/Image/frame.png');
                const crosshairTexture = PIXI.Texture.from('Assets/Image/crosshair.png');
                const cursorTexture = PIXI.Texture.from('Assets/Image/cursor.png');

                // Display errors in red if assets fail to load
                const assetErrors = [];
                [grassTexture, dirtTexture, frameTexture, crosshairTexture, cursorTexture].forEach((texture, i) => {
                    const names = ['grass.png', 'dirt.png', 'frame.png', 'crosshair.png', 'cursor.png'];
                    texture.baseTexture.on('error', () => {
                        const error = `❌ Failed to load: ${names[i]}`;
                        assetErrors.push(error);
                        document.getElementById('pos').innerHTML = `<span style="color: red; font-weight: bold;">${assetErrors.join('<br>')}</span>`;
                        console.error(error);
                    });
                });

                // Create layered container system
                const worldContainer = new PIXI.Container();
                app.stage.addChild(worldContainer);

                // Layer 1: Tiles (bottom)
                const tilesContainer = new PIXI.Container();
                worldContainer.addChild(tilesContainer);

                // Layer 2: Grid overlay (middle)
                const gridContainer = new PIXI.Container();
                worldContainer.addChild(gridContainer);

                // Layer 3: Selector/highlights (top of world)
                const overlayContainer = new PIXI.Container();
                worldContainer.addChild(overlayContainer);

                // UI Container (always on top, not affected by world transform)
                const uiContainer = new PIXI.Container();
                app.stage.addChild(uiContainer);

                // Cursor sprite
                const cursorSprite = new PIXI.Sprite(cursorTexture);
                cursorSprite.anchor.set(0.5);
                cursorSprite.width = 32;
                cursorSprite.height = 32;
                uiContainer.addChild(cursorSprite);

                // Crosshair sprite
                const crosshairSprite = new PIXI.Sprite(crosshairTexture);
                crosshairSprite.anchor.set(0.5);
                crosshairSprite.width = 32;
                crosshairSprite.height = 32;
                crosshairSprite.alpha = 0.4;
                uiContainer.addChild(crosshairSprite);

                // Block selector sprite (frame overlay)
                const selectorSprite = new PIXI.Sprite(getTileTexture(frameTexture.baseTexture, 0, 1));
                selectorSprite.anchor.set(0); // Top-left anchor to match tiles
                selectorSprite.width = TILE_SIZE;
                selectorSprite.height = TILE_SIZE;
                overlayContainer.addChild(selectorSprite); // Add to overlay layer

                // Grid overlay
                const gridGraphics = new PIXI.Graphics();
                gridGraphics.visible = false;
                gridContainer.addChild(gridGraphics); // Add to grid layer

                // Helper: Get texture from spritesheet
                function getTileTexture(baseTexture, index, cols = 4, tileSize = 16) {
                    const col = index % cols;
                    const row = Math.floor(index / cols);
                    return new PIXI.Texture(
                        baseTexture,
                        new PIXI.Rectangle(col * tileSize, row * tileSize, tileSize, tileSize)
                    );
                }

                // Seeded random for dirt tiles
                function seededRandom(x, y) {
                    const seed = x * 374761393 + y * 668265263;
                    let value = Math.sin(seed) * 43758.5453;
                    return value - Math.floor(value);
                }

                function getDirtTileIndex(x, y) {
                    return Math.floor(seededRandom(x, y) * 16);
                }

                // Grass tile mapping (CORRECTED based on user blueprint)
                // Pattern format: TL,TR,BL,BR where 0=Empty(dirt), 1=Filled(grass)
                const GRASS_TILE_MAP = {
                    '0,0,0,0': 12,  // 1. The Void - all empty
                    '1,0,0,0': 15,  // 2. Inner Corner Sharp - Top Left
                    '0,1,0,0': 8,   // 3. Inner Corner Sharp - Top Right
                    '0,0,1,0': 0,   // 4. Inner Corner Sharp - Bottom Left
                    '0,0,0,1': 13,  // 5. Inner Corner Sharp - Bottom Right
                    '1,1,0,0': 9,   // 6. Horizontal Edge - Ceiling
                    '0,0,1,1': 3,   // 7. Horizontal Edge - Floor
                    '1,0,1,0': 11,  // 8. Vertical Edge - Right Face
                    '0,1,0,1': 1,   // 9. Vertical Edge - Left Face
                    '0,1,1,0': 14,  // 10. Diagonal - Forward Slash
                    '1,0,0,1': 4,   // 11. Diagonal - Back Slash
                    '1,1,1,0': 7,   // 12. Outer Corner - Bottom Right cut
                    '1,1,0,1': 10,  // 13. Outer Corner - Bottom Left cut
                    '1,0,1,1': 2,   // 14. Outer Corner - Top Right cut
                    '0,1,1,1': 5,   // 15. Outer Corner - Top Left cut
                    '1,1,1,1': 6    // 16. Full Solid - all grass
                };

                function getGrassTileIndex(x, y) {
                    // Dual-grid: check neighbors at world grid positions
                    const tl = getTile(x, y);
                    const tr = getTile(x + 1, y);
                    const bl = getTile(x, y + 1);
                    const br = getTile(x + 1, y + 1);
                    const key = `${tl},${tr},${bl},${br}`;
                    return GRASS_TILE_MAP[key] !== undefined ? GRASS_TILE_MAP[key] : 6;
                }

                // Perlin noise
                class PerlinNoise {
                    constructor(seed = 0) {
                        this.perm = [];
                        for (let i = 0; i < 256; i++) this.perm[i] = i;
                        for (let i = 255; i > 0; i--) {
                            const j = Math.floor(seededRandom(i, seed) * (i + 1));
                            [this.perm[i], this.perm[j]] = [this.perm[j], this.perm[i]];
                        }
                        this.perm = [...this.perm, ...this.perm];
                    }
                    fade(t) { return t * t * t * (t * (t * 6 - 15) + 10); }
                    lerp(t, a, b) { return a + t * (b - a); }
                    grad(hash, x, y) {
                        const h = hash & 15;
                        const u = h < 8 ? x : y;
                        const v = h < 4 ? y : h === 12 || h === 14 ? x : 0;
                        return ((h & 1) === 0 ? u : -u) + ((h & 2) === 0 ? v : -v);
                    }
                    noise(x, y) {
                        const X = Math.floor(x) & 255;
                        const Y = Math.floor(y) & 255;
                        x -= Math.floor(x);
                        y -= Math.floor(y);
                        const u = this.fade(x);
                        const v = this.fade(y);
                        const a = this.perm[X] + Y;
                        const b = this.perm[X + 1] + Y;
                        return this.lerp(v,
                            this.lerp(u, this.grad(this.perm[a], x, y), this.grad(this.perm[b], x - 1, y)),
                            this.lerp(u, this.grad(this.perm[a + 1], x, y - 1), this.grad(this.perm[b + 1], x - 1, y - 1))
                        );
                    }
                }

                const perlin = new PerlinNoise(42);

                // Chunk system
                const chunks = new Map();
                const chunkContainers = new Map();

                function generateChunk(cx, cy) {
                    const tiles = [];
                    for (let y = 0; y < CHUNK_SIZE; y++) {
                        tiles[y] = [];
                        for (let x = 0; x < CHUNK_SIZE; x++) {
                            const worldX = cx * CHUNK_SIZE + x;
                            const worldY = cy * CHUNK_SIZE + y;
                            const noise = perlin.noise(worldX * 0.05, worldY * 0.05);
                            tiles[y][x] = noise > 0.1 ? 0 : 1; // 0=grass, 1=dirt
                        }
                    }
                    return tiles;
                }

                function getChunk(cx, cy) {
                    const key = `${cx},${cy}`;
                    if (!chunks.has(key)) {
                        chunks.set(key, generateChunk(cx, cy));
                    }
                    return chunks.get(key);
                }

                function getTile(worldX, worldY) {
                    const cx = Math.floor(worldX / CHUNK_SIZE);
                    const cy = Math.floor(worldY / CHUNK_SIZE);
                    const chunk = getChunk(cx, cy);
                    const tx = ((worldX % CHUNK_SIZE) + CHUNK_SIZE) % CHUNK_SIZE;
                    const ty = ((worldY % CHUNK_SIZE) + CHUNK_SIZE) % CHUNK_SIZE;
                    return chunk[ty][tx];
                }

                // Render chunk as PixiJS container
                function renderChunk(cx, cy) {
                    const key = `${cx},${cy}`;

                    // Remove old container if exists
                    if (chunkContainers.has(key)) {
                        const oldContainer = chunkContainers.get(key);
                        worldContainer.removeChild(oldContainer);
                        oldContainer.destroy({ children: true });
                    }

                    const chunk = getChunk(cx, cy);
                    const container = new PIXI.Container();

                    for (let ty = 0; ty < CHUNK_SIZE; ty++) {
                        for (let tx = 0; tx < CHUNK_SIZE; tx++) {
                            const worldX = cx * CHUNK_SIZE + tx;
                            const worldY = cy * CHUNK_SIZE + ty;

                            // Dirt sprite
                            const dirtIdx = getDirtTileIndex(worldX, worldY);
                            const dirtSprite = new PIXI.Sprite(getTileTexture(dirtTexture.baseTexture, dirtIdx));
                            dirtSprite.x = worldX * TILE_SIZE;
                            dirtSprite.y = worldY * TILE_SIZE;
                            dirtSprite.anchor.set(0);
                            dirtSprite.width = TILE_SIZE;
                            dirtSprite.height = TILE_SIZE;
                            container.addChild(dirtSprite);

                            // Grass sprite - try NEGATIVE offset
                            const grassIdx = getGrassTileIndex(worldX, worldY);
                            const grassSprite = new PIXI.Sprite(getTileTexture(grassTexture.baseTexture, grassIdx));
                            grassSprite.x = (worldX - 0.5) * TILE_SIZE;
                            grassSprite.y = (worldY - 0.5) * TILE_SIZE;
                            grassSprite.anchor.set(0.5);
                            grassSprite.width = TILE_SIZE;
                            grassSprite.height = TILE_SIZE;
                            container.addChild(grassSprite);

                            // Debug: show world grid position for dirt blocks (only in grid mode)
                            // Will be toggled by grid visibility
                            if (getTile(worldX, worldY) === 1) { // 1 = dirt
                                const debugRect = new PIXI.Graphics();
                                debugRect.beginFill(0x00ff00, 0.2); // Light green shade
                                debugRect.drawRect(worldX * TILE_SIZE, worldY * TILE_SIZE, TILE_SIZE, TILE_SIZE);
                                debugRect.endFill();
                                debugRect.name = 'dirtDebug';
                                container.addChild(debugRect);
                            }
                        }
                    }

                    tilesContainer.addChild(container); // Add to tiles layer
                    chunkContainers.set(key, container);
                    return container;
                }

                // Player
                const player = {
                    x: 0,
                    y: 0,
                    width: 14,
                    height: 14,
                    speed: 150
                };

                // Camera
                const camera = {
                    x: 0,
                    y: 0,
                    zoom: 2,
                    minZoom: 1,
                    maxZoom: 4,
                    freelook: false,
                    showGrid: false
                };

                // Input
                const keys = {};
                const mouse = {
                    x: window.innerWidth / 2,
                    y: window.innerHeight / 2,
                    leftDown: false,
                    rightDown: false
                };

                document.addEventListener('keydown', e => {
                    keys[e.key.toLowerCase()] = true;
                    if (e.key === 'Alt') {
                        camera.freelook = !camera.freelook;
                        e.preventDefault();
                    }
                    if (e.key.toLowerCase() === 'g') {
                        camera.showGrid = !camera.showGrid;
                    }
                });
                document.addEventListener('keyup', e => {
                    keys[e.key.toLowerCase()] = false;
                });

                document.addEventListener('mousemove', (e) => {
                    const prevX = mouse.x;
                    const prevY = mouse.y;
                    const rect = app.view.getBoundingClientRect();
                    mouse.x = e.clientX - rect.left;
                    mouse.y = e.clientY - rect.top;

                    if (camera.freelook && mouse.leftDown) {
                        const dx = (mouse.x - prevX) / camera.zoom;
                        const dy = (mouse.y - prevY) / camera.zoom;
                        camera.x -= dx;
                        camera.y -= dy;
                    }

                    // Drag to place/remove blocks with line interpolation
                    if (!camera.freelook && (mouse.leftDown || mouse.rightDown)) {
                        const mouseWorldX = mouse.x / camera.zoom + camera.x;
                        const mouseWorldY = mouse.y / camera.zoom + camera.y;
                        const currentX = Math.floor(mouseWorldX / TILE_SIZE);
                        const currentY = Math.floor(mouseWorldY / TILE_SIZE);

                        // Get previous position
                        const prevWorldX = prevX / camera.zoom + camera.x;
                        const prevWorldY = prevY / camera.zoom + camera.y;
                        const lastX = Math.floor(prevWorldX / TILE_SIZE);
                        const lastY = Math.floor(prevWorldY / TILE_SIZE);

                        // Draw line between last and current position
                        const dx = Math.abs(currentX - lastX);
                        const dy = Math.abs(currentY - lastY);
                        const sx = lastX < currentX ? 1 : -1;
                        const sy = lastY < currentY ? 1 : -1;
                        let err = dx - dy;
                        let x = lastX;
                        let y = lastY;

                        const affectedChunks = new Set();

                        while (true) {
                            const chunkX = Math.floor(x / CHUNK_SIZE);
                            const chunkY = Math.floor(y / CHUNK_SIZE);
                            const chunk = getChunk(chunkX, chunkY);
                            const tileX = ((x % CHUNK_SIZE) + CHUNK_SIZE) % CHUNK_SIZE;
                            const tileY = ((y % CHUNK_SIZE) + CHUNK_SIZE) % CHUNK_SIZE;

                            if (mouse.leftDown) {
                                chunk[tileY][tileX] = 0; // Remove dirt
                            } else if (mouse.rightDown) {
                                chunk[tileY][tileX] = 1; // Place dirt
                            }

                            // Track affected chunks
                            affectedChunks.add(`${chunkX},${chunkY}`);
                            if (tileX === 0) affectedChunks.add(`${chunkX - 1},${chunkY}`);
                            if (tileX === CHUNK_SIZE - 1) affectedChunks.add(`${chunkX + 1},${chunkY}`);
                            if (tileY === 0) affectedChunks.add(`${chunkX},${chunkY - 1}`);
                            if (tileY === CHUNK_SIZE - 1) affectedChunks.add(`${chunkX},${chunkY + 1}`);

                            if (x === currentX && y === currentY) break;

                            const e2 = 2 * err;
                            if (e2 > -dy) { err -= dy; x += sx; }
                            if (e2 < dx) { err += dx; y += sy; }
                        }

                        // Re-render all affected chunks
                        affectedChunks.forEach(key => {
                            const [cx, cy] = key.split(',').map(Number);
                            renderChunk(cx, cy);
                        });
                    }
                });

                document.addEventListener('mousedown', (e) => {
                    if (e.button === 0) {
                        mouse.leftDown = true;
                        if (!camera.freelook) {
                            const mouseWorldX = mouse.x / camera.zoom + camera.x;
                            const mouseWorldY = mouse.y / camera.zoom + camera.y;
                            const worldX = Math.floor(mouseWorldX / TILE_SIZE);
                            const worldY = Math.floor(mouseWorldY / TILE_SIZE);

                            const chunkX = Math.floor(worldX / CHUNK_SIZE);
                            const chunkY = Math.floor(worldY / CHUNK_SIZE);
                            const chunk = getChunk(chunkX, chunkY);

                            const tileX = ((worldX % CHUNK_SIZE) + CHUNK_SIZE) % CHUNK_SIZE;
                            const tileY = ((worldY % CHUNK_SIZE) + CHUNK_SIZE) % CHUNK_SIZE;

                            chunk[tileY][tileX] = 0; // Remove dirt (left click)

                            // Re-render current chunk
                            renderChunk(chunkX, chunkY);

                            // Re-render neighboring chunks if on edge
                            if (tileX === 0) renderChunk(chunkX - 1, chunkY);
                            if (tileX === CHUNK_SIZE - 1) renderChunk(chunkX + 1, chunkY);
                            if (tileY === 0) renderChunk(chunkX, chunkY - 1);
                            if (tileY === CHUNK_SIZE - 1) renderChunk(chunkX, chunkY + 1);
                        }
                    } else if (e.button === 2) {
                        mouse.rightDown = true;
                        if (!camera.freelook) {
                            const mouseWorldX = mouse.x / camera.zoom + camera.x;
                            const mouseWorldY = mouse.y / camera.zoom + camera.y;
                            const worldX = Math.floor(mouseWorldX / TILE_SIZE);
                            const worldY = Math.floor(mouseWorldY / TILE_SIZE);

                            const chunkX = Math.floor(worldX / CHUNK_SIZE);
                            const chunkY = Math.floor(worldY / CHUNK_SIZE);
                            const chunk = getChunk(chunkX, chunkY);

                            const tileX = ((worldX % CHUNK_SIZE) + CHUNK_SIZE) % CHUNK_SIZE;
                            const tileY = ((worldY % CHUNK_SIZE) + CHUNK_SIZE) % CHUNK_SIZE;

                            chunk[tileY][tileX] = 1; // Place dirt (right click)

                            // Re-render current chunk
                            renderChunk(chunkX, chunkY);

                            // Re-render neighboring chunks if on edge
                            if (tileX === 0) renderChunk(chunkX - 1, chunkY);
                            if (tileX === CHUNK_SIZE - 1) renderChunk(chunkX + 1, chunkY);
                            if (tileY === 0) renderChunk(chunkX, chunkY - 1);
                            if (tileY === CHUNK_SIZE - 1) renderChunk(chunkX, chunkY + 1);
                        }
                    }
                });

                document.addEventListener('mouseup', (e) => {
                    if (e.button === 0) mouse.leftDown = false;
                    else if (e.button === 2) mouse.rightDown = false;
                });

                document.addEventListener('contextmenu', (e) => e.preventDefault());

                document.addEventListener('wheel', (e) => {
                    e.preventDefault();
                    const zoomDelta = e.deltaY > 0 ? 0.9 : 1.1;
                    camera.zoom = Math.max(camera.minZoom, Math.min(camera.maxZoom, camera.zoom * zoomDelta));
                });

                // Game loop
                let lastTime = performance.now();

                app.ticker.add(() => {
                    try {
                        if (hasError) return; // Stop if error occurred

                        const time = performance.now();
                        const dt = Math.min((time - lastTime) / 1000, 0.1);
                        lastTime = time;

                        // Movement
                        let moveX = 0, moveY = 0;
                        if (keys['a'] || keys['arrowleft']) moveX = -1;
                        if (keys['d'] || keys['arrowright']) moveX = 1;
                        if (keys['w'] || keys['arrowup']) moveY = -1;
                        if (keys['s'] || keys['arrowdown']) moveY = 1;

                        if (moveX !== 0 && moveY !== 0) {
                            moveX *= 0.707;
                            moveY *= 0.707;
                        }

                        player.x = Math.round(player.x + moveX * player.speed * dt);
                        player.y = Math.round(player.y + moveY * player.speed * dt);

                        // Camera follow
                        if (!camera.freelook) {
                            camera.x = player.x + player.width / 2 - (app.screen.width / 2) / camera.zoom;
                            camera.y = player.y + player.height / 2 - (app.screen.height / 2) / camera.zoom;
                        }

                        // Update world container transform
                        worldContainer.x = -camera.x * camera.zoom;
                        worldContainer.y = -camera.y * camera.zoom;
                        worldContainer.scale.set(camera.zoom);

                        // Continuous block placement while holding mouse button
                        if (!camera.freelook && (mouse.leftDown || mouse.rightDown)) {
                            const mouseWorldX = mouse.x / camera.zoom + camera.x;
                            const mouseWorldY = mouse.y / camera.zoom + camera.y;
                            const worldX = Math.floor(mouseWorldX / TILE_SIZE);
                            const worldY = Math.floor(mouseWorldY / TILE_SIZE);

                            const chunkX = Math.floor(worldX / CHUNK_SIZE);
                            const chunkY = Math.floor(worldY / CHUNK_SIZE);
                            const chunk = getChunk(chunkX, chunkY);
                            const tileX = ((worldX % CHUNK_SIZE) + CHUNK_SIZE) % CHUNK_SIZE;
                            const tileY = ((worldY % CHUNK_SIZE) + CHUNK_SIZE) % CHUNK_SIZE;

                            const currentValue = chunk[tileY][tileX];
                            const newValue = mouse.leftDown ? 0 : 1;

                            // Only update if value changed
                            if (currentValue !== newValue) {
                                chunk[tileY][tileX] = newValue;

                                // Re-render affected chunks
                                renderChunk(chunkX, chunkY);
                                if (tileX === 0) renderChunk(chunkX - 1, chunkY);
                                if (tileX === CHUNK_SIZE - 1) renderChunk(chunkX + 1, chunkY);
                                if (tileY === 0) renderChunk(chunkX, chunkY - 1);
                                if (tileY === CHUNK_SIZE - 1) renderChunk(chunkX, chunkY + 1);
                            }
                        }

                        // Calculate visible chunks
                        const viewWidth = app.screen.width / camera.zoom;
                        const viewHeight = app.screen.height / camera.zoom;
                        const startChunkX = Math.floor((camera.x - TILE_SIZE) / CHUNK_PIXEL_SIZE);
                        const endChunkX = Math.ceil((camera.x + viewWidth + TILE_SIZE) / CHUNK_PIXEL_SIZE);
                        const startChunkY = Math.floor((camera.y - TILE_SIZE) / CHUNK_PIXEL_SIZE);
                        const endChunkY = Math.ceil((camera.y + viewHeight + TILE_SIZE) / CHUNK_PIXEL_SIZE);

                        // Render visible chunks
                        for (let cy = startChunkY; cy < endChunkY; cy++) {
                            for (let cx = startChunkX; cx < endChunkX; cx++) {
                                const key = `${cx},${cy}`;
                                if (!chunkContainers.has(key)) {
                                    renderChunk(cx, cy);
                                }
                            }
                        }

                        // Update block selector (snap to world grid where blocks are placed)
                        if (!camera.freelook) {
                            const mouseWorldX = mouse.x / camera.zoom + camera.x;
                            const mouseWorldY = mouse.y / camera.zoom + camera.y;
                            // Snap to world grid for data
                            const hoverWorldX = Math.floor(mouseWorldX / TILE_SIZE);
                            const hoverWorldY = Math.floor(mouseWorldY / TILE_SIZE);

                            // Position selector on world grid
                            selectorSprite.x = hoverWorldX * TILE_SIZE;
                            selectorSprite.y = hoverWorldY * TILE_SIZE;
                            selectorSprite.visible = true;

                            // Frame 0 = hover, Frame 1 = pressed
                            const frameIndex = (mouse.leftDown || mouse.rightDown) ? 1 : 0;
                            selectorSprite.texture = getTileTexture(frameTexture.baseTexture, frameIndex, 1);
                        } else {
                            selectorSprite.visible = false;
                        }

                        // Update grid
                        if (camera.showGrid) {
                            gridGraphics.clear();

                            const viewWidth = app.screen.width / camera.zoom;
                            const viewHeight = app.screen.height / camera.zoom;
                            const startX = Math.floor(camera.x / TILE_SIZE) * TILE_SIZE;
                            const endX = Math.ceil((camera.x + viewWidth) / TILE_SIZE) * TILE_SIZE;
                            const startY = Math.floor(camera.y / TILE_SIZE) * TILE_SIZE;
                            const endY = Math.ceil((camera.y + viewHeight) / TILE_SIZE) * TILE_SIZE;

                            // Draw tile grid (RED)
                            gridGraphics.lineStyle(0.5, 0xff0000, 0.15);
                            gridGraphics.beginFill(0, 0);
                            for (let x = startX; x <= endX; x += TILE_SIZE) {
                                for (let y = startY; y <= endY; y += TILE_SIZE) {
                                    // Draw on world grid
                                    gridGraphics.drawRect(x, y, TILE_SIZE, TILE_SIZE);
                                }
                            }
                            gridGraphics.endFill();

                            // Draw chunk grid (BLUE)
                            const CHUNK_PIXEL_SIZE = CHUNK_SIZE * TILE_SIZE;
                            const startChunkX = Math.floor(camera.x / CHUNK_PIXEL_SIZE) * CHUNK_PIXEL_SIZE;
                            const endChunkX = Math.ceil((camera.x + viewWidth) / CHUNK_PIXEL_SIZE) * CHUNK_PIXEL_SIZE;
                            const startChunkY = Math.floor(camera.y / CHUNK_PIXEL_SIZE) * CHUNK_PIXEL_SIZE;
                            const endChunkY = Math.ceil((camera.y + viewHeight) / CHUNK_PIXEL_SIZE) * CHUNK_PIXEL_SIZE;

                            gridGraphics.lineStyle(1.5, 0x0000ff, 0.3);
                            gridGraphics.beginFill(0, 0);
                            for (let x = startChunkX; x <= endChunkX; x += CHUNK_PIXEL_SIZE) {
                                for (let y = startChunkY; y <= endChunkY; y += CHUNK_PIXEL_SIZE) {
                                    // Draw on world grid
                                    gridGraphics.drawRect(x, y, CHUNK_PIXEL_SIZE, CHUNK_PIXEL_SIZE);
                                }
                            }
                            gridGraphics.endFill();

                            console.log('Grid drawn! showGrid:', camera.showGrid, 'visible:', gridGraphics.visible);
                            gridGraphics.visible = true;
                        } else {
                            gridGraphics.visible = false;
                        }

                        // Update crosshair
                        crosshairSprite.x = app.screen.width / 2;
                        crosshairSprite.y = app.screen.height / 2;

                        // Update cursor
                        cursorSprite.x = mouse.x;
                        cursorSprite.y = mouse.y;

                        // UI
                        document.getElementById('pos').textContent =
                            `Pos: ${Math.floor(player.x)}, ${Math.floor(player.y)} | Zoom: ${camera.zoom.toFixed(1)}x | Chunks: ${chunks.size} | FPS: ${Math.round(app.ticker.FPS)}`;
                    } catch (error) {
                        hasError = true;
                        const errorDiv = document.getElementById('pos');
                        errorDiv.innerHTML = `<span class="error">❌ LOOP ERROR: ${error.message}<br>Check console (F12)</span>`;
                        console.error('%c ❌ GAME LOOP ERROR:', 'color: red; font-size: 20px; font-weight: bold', error);
                        console.error(error.stack);
                    }
                });

                // Initial chunk load
                renderChunk(0, 0);

            } catch (error) {
                hasError = true;
                const errorDiv = document.getElementById('pos');
                errorDiv.innerHTML = `<span class="error">❌ INIT ERROR: ${error.message}<br>Check console (F12)</span>`;
                console.error('%c ❌ INITIALIZATION ERROR:', 'color: red; font-size: 20px; font-weight: bold', error);
                console.error(error.stack);
            }
        }); // End window.load
    </script>
</body>

</html>