<!DOCTYPE html>
<html>

<head>
    <title>tyls.io</title>
    <link rel="icon" href="data:,">
    <style>
        @font-face {
            font-family: 'Minecraft';
            src: url('./Assets/Font/pixel.ttf') format('truetype');
        }

        body {
            margin: 0;
            overflow: hidden;
            background: #000;
        }

        canvas {
            display: block;
            image-rendering: pixelated;
            image-rendering: crisp-edges;
            cursor: none;
            /* Hide default/CSS cursor for Software Cursor */
        }

        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            color: #ffffff;
            font-family: 'Minecraft', monospace;
            font-size: 16px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
            pointer-events: none;
            z-index: 100;
        }

        #activity {
            position: absolute;
            top: 10px;
            right: 10px;
            color: #ffffff;
            font-family: 'Minecraft', monospace;
            font-size: 20px;
            font-weight: bold;
            text-shadow: 0 0 5px rgba(255, 255, 255, 0.5);
            opacity: 0;
            transition: opacity 0.2s;
            pointer-events: none;
        }

        #activity.flash {
            opacity: 1;
        }
    </style>
</head>

<body>
    <div id="info"></div>
    <div id="activity"></div>

    <script src="https://cdn.jsdelivr.net/npm/pixi.js@8.5.2/dist/pixi.min.js"></script>
    <script>
        // Wait for PixiJS to load
        window.addEventListener('load', async () => {



            // Settings
            const TILE_SIZE = 16;
            const CHUNK_SIZE = 16;



            // Global PixiJS Settings for Pixel Art
            PIXI.TextureSource.defaultOptions.scaleMode = 'nearest';

            // PixiJS App (v8 requires await)
            const app = new PIXI.Application();
            await app.init({
                width: window.innerWidth,
                height: window.innerHeight,
                backgroundColor: 0x1a1a1a,
                antialias: false,
                roundPixels: true,  // Pixel-perfect rendering
                preference: 'maximum-performance', // Hint to browser
                powerPreference: 'high-performance'
            });
            // Attempt to uncap FPS (0 = uncapped / monitor limit)
            app.ticker.maxFPS = 0;
            document.body.appendChild(app.canvas);

            // Resize canvas to fill screen (fixes black bar at top)
            function resizeCanvas() {
                app.renderer.resize(window.innerWidth, window.innerHeight);
            }
            window.addEventListener('resize', resizeCanvas);
            resizeCanvas(); // Call once to ensure proper size

            // Pixel-perfect (v8 compatible)
            // FPS Uncapped (User requested)



            // World container
            const world = new PIXI.Container();
            world.sortableChildren = true; // Enable z-index sorting for world (tiles/players)
            app.stage.sortableChildren = true; // Enable z-index sorting for stage (UI/Crosshair)
            app.stage.addChild(world);

            // Layers for Z-sorting (Fixes "cutoff" grass/half tiles)
            const dirtLayer = new PIXI.Container();
            const grassLayer = new PIXI.Container();
            world.addChild(dirtLayer);
            world.addChild(grassLayer);

            // Track hovered tile position
            let hoveredTileX = null;
            let hoveredTileY = null;

            // Mouse tracking


            // NOTE: selectSprite and event handlers moved inside Promise.all().then() to ensure texture is loaded


            // Chunk-based world data
            // RENDER_DISTANCE now comes from config.renderDistance
            const chunks = new Map(); // "cx,cy" -> chunk data
            const chunkContainers = new Map(); // "cx,cy" -> { dirt: Container, grass: Container }
            const dirtyChunks = new Set(); // Set of chunk keys to re-render this frame
            let chunksRendered = 0;

            // renderChunk function reference - defined inside Promise.all().then() but accessed by setTile
            let renderChunk = null;

            // Simple Perlin-like noise
            function noise2D(x, y) {
                const X = Math.floor(x) & 255;
                const Y = Math.floor(y) & 255;
                x -= Math.floor(x);
                y -= Math.floor(y);
                const u = x * x * (3 - 2 * x);
                const v = y * y * (3 - 2 * y);
                const a = (X * 374761393 + Y * 668265263) & 0xffffffff;
                const b = ((X + 1) * 374761393 + Y * 668265263) & 0xffffffff;
                const c = (X * 374761393 + (Y + 1) * 668265263) & 0xffffffff;
                const d = ((X + 1) * 374761393 + (Y + 1) * 668265263) & 0xffffffff;
                const hash = (n) => (Math.sin(n) * 43758.5453123) % 1;
                return (hash(a) * (1 - u) + hash(b) * u) * (1 - v) +
                    (hash(c) * (1 - u) + hash(d) * u) * v;
            }

            // Get or create chunk
            function getChunk(cx, cy) {
                const key = `${cx},${cy}`;
                if (!chunks.has(key)) {
                    // Generate chunk with Perlin noise
                    const chunk = [];
                    for (let ty = 0; ty < CHUNK_SIZE; ty++) {
                        chunk[ty] = [];
                        for (let tx = 0; tx < CHUNK_SIZE; tx++) {
                            const worldX = cx * CHUNK_SIZE + tx;
                            const worldY = cy * CHUNK_SIZE + ty;

                            // Multi-octave Perlin noise for more natural terrain
                            const scale1 = 0.08;  // Large features (smaller = bigger features)
                            const scale2 = 0.2;   // Medium features
                            const noise1 = noise2D(worldX * scale1, worldY * scale1);
                            const noise2 = noise2D(worldX * scale2, worldY * scale2);
                            const combinedNoise = noise1 * 0.7 + noise2 * 0.3;

                            chunk[ty][tx] = combinedNoise > 0.15 ? 1 : 0; // 1=grass, 0=dirt
                        }
                    }
                    chunks.set(key, chunk);

                    // FIX: Dirty neighbors to ensure smooth edges (Dual Grid)
                    // CRITICAL FIX: Only dirty neighbors that ALERTADLY EXIST.
                    // This prevents infinite loop of Generation -> Render -> Generate Neighbor -> Render -> ...
                    if (typeof dirtyChunks !== 'undefined') {
                        const neighbors = [
                            `${cx - 1},${cy}`,
                            `${cx + 1},${cy}`,
                            `${cx},${cy - 1}`,
                            `${cx},${cy + 1}`
                        ];
                        for (const nKey of neighbors) {
                            if (chunks.has(nKey)) {
                                dirtyChunks.add(nKey);
                            }
                        }
                    }
                }
                return chunks.get(key);
            }

            function getTile(x, y) {
                const cx = Math.floor(x / CHUNK_SIZE);
                const cy = Math.floor(y / CHUNK_SIZE);
                const tx = ((x % CHUNK_SIZE) + CHUNK_SIZE) % CHUNK_SIZE;
                const ty = ((y % CHUNK_SIZE) + CHUNK_SIZE) % CHUNK_SIZE;
                const chunk = getChunk(cx, cy);
                return chunk[ty][tx];
            }

            // Helper: Get Tile without forcing chunk generation (prevents render lag)
            function getTileSafe(x, y) {
                const cx = Math.floor(x / CHUNK_SIZE);
                const cy = Math.floor(y / CHUNK_SIZE);
                const key = `${cx},${cy}`;
                // If chunk doesn't exist, don't generate it. Just return 0 (dirt).
                if (!chunks.has(key)) return 0;

                const tx = ((x % CHUNK_SIZE) + CHUNK_SIZE) % CHUNK_SIZE;
                const ty = ((y % CHUNK_SIZE) + CHUNK_SIZE) % CHUNK_SIZE;
                return chunks.get(key)[ty][tx];
            }

            function setTile(x, y, value) {
                const cx = Math.floor(x / CHUNK_SIZE);
                const cy = Math.floor(y / CHUNK_SIZE);
                const tx = ((x % CHUNK_SIZE) + CHUNK_SIZE) % CHUNK_SIZE;
                const ty = ((y % CHUNK_SIZE) + CHUNK_SIZE) % CHUNK_SIZE;
                const chunk = getChunk(cx, cy);
                if (chunk[ty][tx] === value) return;
                chunk[ty][tx] = value;

                // Mark chunk for re-render (Batching)
                // We don't render immediately anymore to prevent lag from multiple updates (dragging)
                const key = `${cx},${cy}`;
                dirtyChunks.add(key);
            }

            // Get dirt variant (4x4 grid = 16 variations)
            function getDirtIdx(x, y) {
                // Use position-based pseudo-random for consistent dirt pattern
                const hash = (x * 374761393 + y * 668265263) & 0xffffffff;
                return Math.abs(hash) % 16; // Random dirt tile 0-15
            }

            const globalTextureCache = new Map();

            function getTileTexture(sourceTexture, idx) {
                if (!globalTextureCache.has(sourceTexture)) {
                    globalTextureCache.set(sourceTexture, {});
                }
                const cache = globalTextureCache.get(sourceTexture);

                if (cache[idx]) {
                    return cache[idx];
                }

                const w = sourceTexture.width || 64;
                const h = sourceTexture.height || 64;

                let tileW, tileH, col, row;

                // Smart Layout Detection based on Aspect Ratio
                if (Math.abs(w - h) < 4) { // Tolerance for square
                    // 4x4 Grid (Standard)
                    tileW = w / 4;
                    tileH = h / 4;
                    col = idx % 4;
                    row = Math.floor(idx / 4);
                } else if (w > h) {
                    // Horizontal Strip (16x1)
                    tileW = w / 16;
                    tileH = h;
                    col = idx;
                    row = 0;
                } else {
                    // Vertical Strip (1x16)
                    tileW = w;
                    tileH = h / 16;
                    col = 0;
                    row = idx;
                }

                // In PixiJS v8, create texture from source with frame rectangle
                const tex = new PIXI.Texture({
                    source: sourceTexture.source,
                    frame: new PIXI.Rectangle(col * tileW, row * tileH, tileW, tileH)
                });

                cache[idx] = tex;
                return tex;
            }

            // Load config from tweaker (config.json) and initialize game
            let config = {
                playerSpeed: 200,
                defaultZoom: 3.0,
                minZoom: 0.25,
                maxZoom: 10,
                chunkSize: 16,
                renderDistance: 5,
                lodThreshold: 0.8
            };

            // Try to load config.json, then initialize game
            fetch('config.json')
                .then(res => res.json())
                .then(data => {
                    config = { ...config, ...data };
                    // Config loaded silently
                })
                .catch(() => {
                    // Using default config silently
                })
                .finally(() => {
                    initGame();
                });

            function initGame() {
                // Camera
                // Camera
                const camera = { x: 0, y: 0, zoom: config.defaultZoom, freelook: false };

                // Player (start in center of world, not at edge)
                const player = { x: 128, y: 128, width: 16, height: 16, speed: config.playerSpeed };

                // Mouse
                const mouse = { x: 0, y: 0, left: false, right: false };
                let selectSprite = null;



                // Track hovered tile
                let hoveredTileX = null;
                let hoveredTileY = null;

                // Game loop - runs every frame
                app.ticker.add((delta) => {
                    // Update select sprite position every frame
                    if (selectSprite && hoveredTileX !== null && hoveredTileY !== null) {
                        selectSprite.x = hoveredTileX * TILE_SIZE;
                        selectSprite.y = hoveredTileY * TILE_SIZE;
                    }
                });

                // Consolidated mousemove listener - mouse tracking moved to global event
                // and logic moved to main game loop to ensure updates when camera moves

                // Mouse tracking handled globally below
                // Context menu prevention
                app.canvas.addEventListener('contextmenu', (e) => e.preventDefault());



                // Mouse drag for freelook panning
                let isDragging = false;
                let dragStartX = 0;
                let dragStartY = 0;
                let cameraStartX = 0;
                let cameraStartY = 0;

                app.canvas.addEventListener('mousedown', (e) => {
                    if (isAltPressed && e.button === 0) {
                        isDragging = true;
                        dragStartX = e.clientX;
                        dragStartY = e.clientY;
                        cameraStartX = camera.x;
                        cameraStartY = camera.y;
                        app.canvas.style.cursor = 'grabbing';
                    }
                }, true); // Use capture to run before other handlers

                app.canvas.addEventListener('mousemove', (e) => {
                    if (isDragging && isAltPressed) {
                        const dx = (e.clientX - dragStartX) / camera.zoom;
                        const dy = (e.clientY - dragStartY) / camera.zoom;
                        camera.x = cameraStartX - dx;
                        camera.y = cameraStartY - dy;
                    }
                });

                app.canvas.addEventListener('mouseup', () => {
                    if (isDragging) {
                        isDragging = false;
                        app.canvas.style.cursor = isAltPressed ? 'grab' : "url('Assets/Image/cursor.png'), auto";
                    }
                });

                // Exponential zoom - ONLY in freelook mode
                app.canvas.addEventListener('wheel', (e) => {
                    if (!isAltPressed) return; // Only zoom when Alt is pressed
                    e.preventDefault();
                    // Increased scroll sensitivity for faster zooming
                    const zoomFactor = e.deltaY < 0 ? 1.25 : 0.8;
                    camera.zoom = Math.max(config.minZoom, Math.min(config.maxZoom, camera.zoom * zoomFactor));
                });

                // Garbage Collection for Chunks (Prevent Memory Leak)
                setInterval(() => {
                    const playerChunkX = Math.round(player.x / TILE_SIZE / CHUNK_SIZE);
                    const playerChunkY = Math.round(player.y / TILE_SIZE / CHUNK_SIZE);
                    const GC_RADIUS = config.renderDistance + 20; // Keep slightly more than render distance

                    for (const key of chunks.keys()) {
                        const [cx, cy] = key.split(',').map(Number);
                        const dist = Math.max(Math.abs(cx - playerChunkX), Math.abs(cy - playerChunkY));
                        if (dist > GC_RADIUS) {
                            chunks.delete(key);
                        }
                    }
                }, 5000); // Run every 5 seconds

                // Keyboard
                const keys = {};
                let showGrid = false;
                let isAltPressed = false; // Track Alt key for freelook

                // Activity indicator - track currently pressed keys
                let pressedKeys = new Set();
                let fadeTimeout = null;

                function updateActivity() {
                    const activity = document.getElementById('activity');
                    if (pressedKeys.size === 0) {
                        // Fade out when no keys pressed
                        activity.classList.remove('flash');
                    } else {
                        // Show all pressed keys with + between them
                        const keyList = Array.from(pressedKeys).join(' + ');
                        activity.textContent = keyList;
                        activity.classList.add('flash');
                    }
                }

                window.addEventListener('keydown', (e) => {
                    keys[e.key.toLowerCase()] = true;

                    // Toggle Alt mode (press Alt to toggle on/off)
                    if (e.key === 'Alt' && !e.repeat) {
                        isAltPressed = !isAltPressed;
                        camera.freelook = isAltPressed;

                        if (isAltPressed) {
                            // Entering freelook
                            app.canvas.style.cursor = 'grab';
                            document.getElementById('info').textContent = 'FREELOOK MODE - Drag to pan, Scroll to zoom, Alt to exit';
                        } else {
                            // Exiting freelook - snap camera back to player and reset zoom
                            camera.x = player.x + player.width / 2;
                            camera.y = player.y + player.height / 2;
                            camera.zoom = config.defaultZoom; // Reset to default zoom (2.0)
                            app.canvas.style.cursor = "url('Assets/Image/cursor.png'), auto";
                        }
                        e.preventDefault();
                    }

                    // Add key to pressed set
                    let keyName = e.key;
                    if (keyName === ' ') keyName = 'Space';
                    if (keyName.length === 1) keyName = keyName.toUpperCase();
                    pressedKeys.add(keyName);
                    updateActivity();

                    if (e.key.toLowerCase() === 'g') {
                        showGrid = !showGrid;
                    }
                });

                window.addEventListener('keyup', (e) => {
                    keys[e.key.toLowerCase()] = false;

                    // Remove key from pressed set
                    let keyName = e.key;
                    if (keyName === ' ') keyName = 'Space';
                    if (keyName.length === 1) keyName = keyName.toUpperCase();
                    pressedKeys.delete(keyName);
                    updateActivity();
                });

                // Grass tile mapping (from README)
                const GRASS_MAP = {
                    '0000': 12, // The Void
                    '1000': 15, // Inner Corner - Top Left
                    '0100': 8,  // Inner Corner - Top Right
                    '0010': 0,  // Inner Corner - Bottom Left
                    '0001': 13, // Inner Corner - Bottom Right
                    '1100': 9,  // Horizontal Edge - Ceiling
                    '0011': 3,  // Horizontal Edge - Floor
                    '1010': 11, // Vertical Edge - Right Face
                    '0101': 1,  // Vertical Edge - Left Face
                    '0110': 14, // Diagonal - Forward Slash
                    '1001': 4,  // Diagonal - Back Slash
                    '1110': 7,  // Outer Corner - Bottom Right
                    '1101': 10, // Outer Corner - Bottom Left
                    '1011': 2,  // Outer Corner - Top Right
                    '0111': 5,  // Outer Corner - Top Left
                    '1111': 6   // Full Solid
                };

                function getGrassIdx(x, y) {
                    // Check 4 corners: TL, TR, BL, BR
                    // F (filled/grass) = 1, E (empty/dirt) = 0
                    const tl = getTile(x, y) === 1 ? '1' : '0';
                    const tr = getTile(x + 1, y) === 1 ? '1' : '0';
                    const bl = getTile(x, y + 1) === 1 ? '1' : '0';
                    const br = getTile(x + 1, y + 1) === 1 ? '1' : '0';
                    const key = tl + tr + bl + br;
                    return GRASS_MAP[key] !== undefined ? GRASS_MAP[key] : 6;
                }

                // Create placeholder texture when image files are missing
                function createPlaceholderTexture(color) {
                    const canvas = document.createElement('canvas');
                    canvas.width = 64; // 4x4 grid of 16x16 tiles
                    canvas.height = 64;
                    const ctx = canvas.getContext('2d');
                    ctx.fillStyle = `#${color.toString(16).padStart(6, '0')}`;
                    ctx.fillRect(0, 0, 64, 64);
                    return PIXI.Texture.from(canvas);
                }



                // Load textures using modern Assets API (v8+)
                Promise.all([
                    PIXI.Assets.load('Assets/Image/Tile/dirt.png').catch(() => {
                        console.warn('dirt.png not found, using placeholder');
                        return createPlaceholderTexture(0x8B4513); // Brown
                    }),
                    PIXI.Assets.load('Assets/Image/Tile/grass.png').catch(() => {
                        console.warn('grass.png not found, using placeholder');
                        return createPlaceholderTexture(0x228B22); // Green
                    }),
                    PIXI.Assets.load('Assets/Image/select.png').catch(() => {
                        console.warn('select.png not found, using placeholder');
                        const canvas = document.createElement('canvas');
                        canvas.width = 32; canvas.height = 16;
                        const ctx = canvas.getContext('2d');
                        ctx.strokeStyle = '#FF0000'; ctx.lineWidth = 2; ctx.strokeRect(16, 0, 16, 16); // Pressed
                        return PIXI.Texture.from(canvas);
                    }),
                    PIXI.Assets.load('Assets/Image/crosshair.png').catch(() => {
                        console.warn('crosshair.png not found, using placeholder');
                        const canvas = document.createElement('canvas');
                        canvas.width = 16; canvas.height = 16;
                        const ctx = canvas.getContext('2d');
                        ctx.fillStyle = '#FFFFFF'; ctx.fillRect(7, 0, 2, 16); ctx.fillRect(0, 7, 16, 2);
                        return PIXI.Texture.from(canvas);
                    })
                ]).then(([dirtTexLoaded, grassTexLoaded, selectTexLoaded, crosshairTexLoaded]) => {
                    // Update global references and set nearest neighbor scaling (Pixel Art)
                    dirtTexLoaded.source.scaleMode = 'nearest';
                    grassTexLoaded.source.scaleMode = 'nearest';
                    selectTexLoaded.source.scaleMode = 'nearest';
                    crosshairTexLoaded.source.scaleMode = 'nearest';

                    const dirtTex = dirtTexLoaded;
                    const grassTex = grassTexLoaded;
                    const selectTex = selectTexLoaded;
                    const crosshairTex = crosshairTexLoaded;

                    // Setup Block Highlight (using loaded texture)
                    // Assumes horizontal sprite sheet (32x16)
                    const selectTexNormal = new PIXI.Texture({
                        source: selectTex.source,
                        frame: new PIXI.Rectangle(0, 0, TILE_SIZE, TILE_SIZE)
                    });
                    const selectTexPressed = new PIXI.Texture({
                        source: selectTex.source,
                        frame: new PIXI.Rectangle(0, TILE_SIZE, TILE_SIZE, TILE_SIZE)
                    });

                    selectSprite = new PIXI.Sprite(selectTexNormal);
                    selectSprite.width = TILE_SIZE;
                    selectSprite.height = TILE_SIZE;
                    selectSprite.visible = false;
                    selectSprite.zIndex = 1000; // Ensure it's always on top
                    world.addChild(selectSprite);

                    // Setup Crosshair Sprite (One-time creation)
                    const crosshairSprite = new PIXI.Sprite(crosshairTex);
                    crosshairSprite.anchor.set(0.5);
                    crosshairSprite.zIndex = 9999; // Super high z-index (Above world)
                    app.stage.addChild(crosshairSprite);

                    // Setup Cursor: Restored Custom Sprite (Decoupled for performance)
                    // Hiding system cursor
                    app.canvas.style.cursor = 'none';

                    let cursorSprite = null; // Declare here so game loop can see it
                    PIXI.Assets.load('Assets/Image/cursor.png').then((cursorTex) => {
                        cursorTex.source.scaleMode = 'nearest';
                        cursorSprite = new PIXI.Sprite(cursorTex);
                        cursorSprite.scale.set(2);
                        cursorSprite.zIndex = 10000;
                        cursorSprite.anchor.set(0.5); // Center the cursor on the mouse point
                        app.stage.addChild(cursorSprite);
                    }).catch(() => {
                        console.warn("Cursor image failed to load, falling back to system cursor");
                        app.canvas.style.cursor = 'auto'; // Fallback
                    });

                    // Mouse move handler - just track position
                    // Mouse move handler - Extremely Lightweight (Just updates data)
                    window.addEventListener('mousemove', (e) => {
                        mouse.x = e.clientX;
                        mouse.y = e.clientY;
                    });

                    // Synced Cursor: Merged into PixiJS Ticker (The "Engine Heartbeat")
                    // This ensures the cursor updates exactly when the game renders, removing jitter.
                    app.ticker.add(() => {
                        // 1. Update Cursor Sprite
                        if (cursorSprite) {
                            cursorSprite.x = mouse.x;
                            cursorSprite.y = mouse.y;
                        }

                        // 2. Update World Highlight
                        if (world.scale.x !== 0) {
                            const worldX = (mouse.x - world.x) / world.scale.x;
                            const worldY = (mouse.y - world.y) / world.scale.y;

                            hoveredTileX = Math.floor(worldX / TILE_SIZE);
                            hoveredTileY = Math.floor(worldY / TILE_SIZE);

                            if (selectSprite) {
                                selectSprite.x = hoveredTileX * TILE_SIZE;
                                selectSprite.y = hoveredTileY * TILE_SIZE;
                            }
                        }
                    }, PIXI.UPDATE_PRIORITY.INTERACTION); // High priority update

                    // Mouse down - change to pressed texture
                    window.addEventListener('mousedown', (e) => {
                        if (e.button === 0) {
                            mouse.left = true;
                            // Change texture if selectSprite is ready
                            if (selectSprite) selectSprite.texture = selectTexPressed;
                        } else if (e.button === 2) {
                            mouse.right = true;
                        }
                    });

                    // Mouse up - change back to normal texture
                    window.addEventListener('mouseup', (e) => {
                        if (e.button === 0) {
                            mouse.left = false;
                            if (selectSprite) selectSprite.texture = selectTexNormal;
                        } else if (e.button === 2) {
                            mouse.right = false;
                        }
                    });


                    // Calculate average colors for LOD rendering
                    function getAverageColor(texture) {
                        const canvas = document.createElement('canvas');
                        const ctx = canvas.getContext('2d');
                        canvas.width = texture.width;
                        canvas.height = texture.height;

                        // Draw texture to canvas
                        const img = texture.source.resource;
                        ctx.drawImage(img, 0, 0);

                        // Get pixel data
                        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                        const data = imageData.data;

                        let r = 0, g = 0, b = 0, count = 0;
                        for (let i = 0; i < data.length; i += 4) {
                            // Skip transparent pixels (alpha < 128)
                            if (data[i + 3] >= 128) {
                                r += data[i];
                                g += data[i + 1];
                                b += data[i + 2];
                                count++;
                            }
                        }

                        r = Math.floor(r / count);
                        g = Math.floor(g / count);
                        b = Math.floor(b / count);

                        return (r << 16) | (g << 8) | b; // Return as hex color
                    }

                    const avgDirtColor = getAverageColor(dirtTex);
                    const avgGrassColor = getAverageColor(grassTex);


                    // Pre-generate chunks around spawn to prevent lag spikes
                    const pregenRadius = config.renderDistance + 5; // Generate extra chunks
                    let chunksGenerated = 0;
                    const totalChunks = (pregenRadius * 2 + 1) * (pregenRadius * 2 + 1);

                    for (let cy = -pregenRadius; cy <= pregenRadius; cy++) {
                        for (let cx = -pregenRadius; cx <= pregenRadius; cx++) {
                            getChunk(cx, cy); // This generates and caches the chunk
                            chunksGenerated++;
                            if (chunksGenerated % 100 === 0) {
                                // Chunk generation progress (removed loading bar)
                            }
                        }
                    }




                    let lastTime = performance.now();

                    // Game loop
                    app.ticker.add(() => {
                        const time = performance.now();
                        const dt = Math.min((time - lastTime) / 1000, 0.1);
                        lastTime = time;

                        // Camera movement (WASD)
                        let moveX = 0, moveY = 0;
                        if (keys['a'] || keys['arrowleft']) moveX = -1;
                        if (keys['d'] || keys['arrowright']) moveX = 1;
                        if (keys['w'] || keys['arrowup']) moveY = -1;
                        if (keys['s'] || keys['arrowdown']) moveY = 1;

                        // Normalize diagonal movement
                        if (moveX !== 0 && moveY !== 0) {
                            moveX *= 0.707;
                            moveY *= 0.707;
                        }

                        // Movement logic - WASD only works in normal mode
                        if (!isAltPressed) {
                            // Normal mode: WASD moves player, camera follows
                            player.x += moveX * player.speed * dt;
                            player.y += moveY * player.speed * dt;
                            camera.x = player.x + player.width / 2;
                            camera.y = player.y + player.height / 2;
                        }
                        // In freelook mode, camera is moved by mouse drag only (no WASD)

                        // Update stats (FPS, location, zoom) with null checks
                        const fps = Math.round(app.ticker.FPS || 0);
                        const locX = player ? Math.floor(player.x) : 0;
                        const locY = player ? Math.floor(player.y) : 0;
                        const zoom = camera ? camera.zoom.toFixed(2) : '0.00';
                        const infoElement = document.getElementById('info');
                        if (infoElement) {
                            infoElement.textContent = `FPS: ${fps} | x: ${locX} y: ${locY} | Zoom: ${zoom}x`;
                        }

                        // Update world-mouse interaction every frame (fixes "laggy" highlight on camera move)
                        // Calculate world coordinates from mouse screen position
                        // world.x/y are the screen center offsets? No, world transform is: 
                        // world.x = -camera.x * zoom + screenW/2
                        // mouseScreen = worldPos * zoom + world.x
                        // worldPos = (mouseScreen - world.x) / zoom

                        // Use world.scale.x which is set to camera.zoom in this loop
                        if (world.scale.x !== 0) {
                            const worldX = (mouse.x - world.x) / world.scale.x;
                            const worldY = (mouse.y - world.y) / world.scale.y;

                            hoveredTileX = Math.floor(worldX / TILE_SIZE);
                            hoveredTileY = Math.floor(worldY / TILE_SIZE);
                        }

                        // Update select sprite position to hovered tile
                        if (hoveredTileX !== null && hoveredTileY !== null) {
                            selectSprite.x = hoveredTileX * TILE_SIZE;
                            selectSprite.y = hoveredTileY * TILE_SIZE;
                        }

                        // Handle input (left=break/dirt, right=place/grass)
                        const isInteractable = !isAltPressed && !camera.freelook;

                        // Only allow building in normal mode, not in freelook
                        if ((mouse.left || mouse.right) && isInteractable) {
                            const worldX = Math.floor((mouse.x - world.x) / camera.zoom / TILE_SIZE);
                            const worldY = Math.floor((mouse.y - world.y) / camera.zoom / TILE_SIZE);
                            const val = mouse.right ? 1 : 0;

                            if (mouse.lastX !== undefined && mouse.lastY !== undefined) {
                                // Bresenham's Line Algorithm for smooth drawing
                                let x0 = mouse.lastX;
                                let y0 = mouse.lastY;
                                const x1 = worldX;
                                const y1 = worldY;
                                const dx = Math.abs(x1 - x0);
                                const dy = Math.abs(y1 - y0);
                                const sx = (x0 < x1) ? 1 : -1;
                                const sy = (y0 < y1) ? 1 : -1;
                                let err = dx - dy;

                                while (true) {
                                    setTile(x0, y0, val);
                                    if (x0 === x1 && y0 === y1) break;
                                    const e2 = 2 * err;
                                    if (e2 > -dy) { err -= dy; x0 += sx; }
                                    if (e2 < dx) { err += dx; y0 += sy; }
                                }
                            } else {
                                setTile(worldX, worldY, val);
                            }

                            // Update last position
                            mouse.lastX = worldX;
                            mouse.lastY = worldY;
                        } else {
                            // Reset last position if not clicking
                            mouse.lastX = undefined;
                            mouse.lastY = undefined;
                        }

                        // Hide selection sprite in freelook mode
                        if (selectSprite) {
                            selectSprite.visible = isInteractable && hoveredTileX !== null && hoveredTileY !== null;
                        }

                        render();
                        renderOverlays();


                        // Transform world (camera system - center camera position on screen)
                        // Reverted rounding to fix diagonal movement feel
                        world.scale.set(camera.zoom);
                        world.x = -camera.x * camera.zoom + app.screen.width / 2;
                        world.y = -camera.y * camera.zoom + app.screen.height / 2;

                        // Crosshair Position Update (Screen Space)
                        if (crosshairSprite) {
                            crosshairSprite.x = app.screen.width / 2;
                            crosshairSprite.y = app.screen.height / 2;
                        }

                        // Cursor is now updated in 'mousemove' listener for zero latency.
                        // Removed game loop update to prevent fighting/jitter.

                        // Process Dirty Chunks (Batch Rendering)
                        if (dirtyChunks.size > 0 && renderChunk) {
                            for (const key of dirtyChunks) {
                                const [cx, cy] = key.split(',').map(Number);
                                // Remove old container FIRST
                                if (chunkContainers.has(key)) {
                                    const containers = chunkContainers.get(key);
                                    if (containers.dirt) {
                                        dirtLayer.removeChild(containers.dirt);
                                        containers.dirt.destroy({ children: true });
                                    }
                                    if (containers.grass) {
                                        grassLayer.removeChild(containers.grass);
                                        containers.grass.destroy({ children: true });
                                    }
                                    chunkContainers.delete(key);
                                }
                                // Re-render
                                renderChunk(cx, cy);
                            }
                            dirtyChunks.clear();
                        }
                    });

                    // Render function - chunk-based with caching
                    let lastLODState = camera.zoom < config.lodThreshold;

                    // Chunk Rendering Function - assign to outer scope variable
                    renderChunk = function (cx, cy) {
                        const key = `${cx},${cy}`;
                        const chunk = getChunk(cx, cy);
                        const chunkDirt = new PIXI.Container();
                        const chunkGrass = new PIXI.Container();

                        // LOD: If zoomed out below threshold, render simple colored tiles (Minimap style)
                        if (camera.zoom < config.lodThreshold) {
                            const graphics = new PIXI.Graphics();

                            // Draw each tile as a simple colored rectangle
                            for (let ty = 0; ty < CHUNK_SIZE; ty++) {
                                for (let tx = 0; tx < CHUNK_SIZE; tx++) {
                                    const tileVal = chunk[ty][tx];
                                    const color = tileVal === 1 ? avgGrassColor : avgDirtColor;

                                    graphics.beginFill(color);
                                    graphics.drawRect(
                                        (cx * CHUNK_SIZE + tx) * TILE_SIZE,
                                        (cy * CHUNK_SIZE + ty) * TILE_SIZE,
                                        TILE_SIZE,
                                        TILE_SIZE
                                    );
                                    graphics.endFill();
                                }
                            }

                            chunkDirt.addChild(graphics);
                            chunkContainers.set(key, { dirt: chunkDirt, grass: chunkGrass });

                            dirtLayer.addChild(chunkDirt);

                            return;
                        }

                        // Render all tiles in this chunk
                        for (let ty = 0; ty < CHUNK_SIZE; ty++) {
                            for (let tx = 0; tx < CHUNK_SIZE; tx++) {
                                const worldX = cx * CHUNK_SIZE + tx;
                                const worldY = cy * CHUNK_SIZE + ty;

                                // Dirt tile -> Dirt Layer
                                const dirtIdx = getDirtIdx(worldX, worldY);
                                const dirtTexture = getTileTexture(dirtTex, dirtIdx);
                                const dirtSprite = new PIXI.Sprite(dirtTexture);
                                dirtSprite.x = worldX * TILE_SIZE;
                                dirtSprite.y = worldY * TILE_SIZE;
                                dirtSprite.width = TILE_SIZE;
                                dirtSprite.height = TILE_SIZE;
                                chunkDirt.addChild(dirtSprite);

                                // Grass tile -> Grass Layer
                                // Reverted to getTile to fix "Half Blocks" / Cutoff edges
                                // The lag was likely the Debug Grid, so generating 16x16 arrays is fine.
                                const hasGrass = getTile(worldX, worldY) === 1 ||
                                    getTile(worldX + 1, worldY) === 1 ||
                                    getTile(worldX, worldY + 1) === 1 ||
                                    getTile(worldX + 1, worldY + 1) === 1;

                                if (hasGrass) {
                                    const grassIdx = getGrassIdx(worldX, worldY);
                                    const grassTexture = getTileTexture(grassTex, grassIdx);
                                    const grassSprite = new PIXI.Sprite(grassTexture);

                                    // Aligned to White Grid (Dual Grid) - Use Center Anchor
                                    grassSprite.anchor.set(0.5);
                                    grassSprite.x = (worldX + 1) * TILE_SIZE;
                                    grassSprite.y = (worldY + 1) * TILE_SIZE;

                                    grassSprite.width = TILE_SIZE;
                                    grassSprite.height = TILE_SIZE;
                                    chunkGrass.addChild(grassSprite);
                                }
                            }
                        }

                        chunkContainers.set(key, { dirt: chunkDirt, grass: chunkGrass });
                        dirtLayer.addChild(chunkDirt);
                        grassLayer.addChild(chunkGrass);
                    }

                    function render() {
                        // Reset chunk count each frame
                        chunksRendered = 0;

                        // Check if we crossed LOD threshold
                        const currentLODState = camera.zoom < config.lodThreshold;
                        if (lastLODState !== currentLODState) {
                            // Clear all chunks when crossing LOD threshold
                            for (const [key, containers] of chunkContainers.entries()) {
                                if (containers.dirt) {
                                    dirtLayer.removeChild(containers.dirt);
                                    containers.dirt.destroy();
                                }
                                if (containers.grass) {
                                    grassLayer.removeChild(containers.grass);
                                    containers.grass.destroy();
                                }
                            }
                            chunkContainers.clear();
                            lastLODState = currentLODState;
                        }

                        // Calculate player chunk position (round to center player in chunk)
                        const playerChunkX = Math.round(player.x / TILE_SIZE / CHUNK_SIZE);
                        const playerChunkY = Math.round(player.y / TILE_SIZE / CHUNK_SIZE);

                        // Calculate visible bounds based on viewport
                        const viewHalfW = (app.screen.width / camera.zoom) / 2;
                        const viewHalfH = (app.screen.height / camera.zoom) / 2;

                        // Convert to chunk coordinates - limit to render distance from config
                        const maxRenderDist = Math.min(config.renderDistance, 32); // Increased cap for Infinite World feel

                        // Calculate viewport-based chunk range
                        let startChunkX = Math.floor((camera.x - viewHalfW) / (TILE_SIZE * CHUNK_SIZE)) - 1;
                        let endChunkX = Math.ceil((camera.x + viewHalfW) / (TILE_SIZE * CHUNK_SIZE)) + 1;
                        let startChunkY = Math.floor((camera.y - viewHalfH) / (TILE_SIZE * CHUNK_SIZE)) - 1;
                        let endChunkY = Math.ceil((camera.y + viewHalfH) / (TILE_SIZE * CHUNK_SIZE)) + 1;

                        // Also limit by render distance from player chunk
                        const playerChunkXCenter = Math.floor(player.x / TILE_SIZE / CHUNK_SIZE);
                        const playerChunkYCenter = Math.floor(player.y / TILE_SIZE / CHUNK_SIZE);
                        startChunkX = Math.max(startChunkX, playerChunkXCenter - maxRenderDist);
                        endChunkX = Math.min(endChunkX, playerChunkXCenter + maxRenderDist);
                        startChunkY = Math.max(startChunkY, playerChunkYCenter - maxRenderDist);
                        endChunkY = Math.min(endChunkY, playerChunkYCenter + maxRenderDist);

                        // Determine which chunks should be visible
                        const chunksToRender = new Set();
                        for (let cy = startChunkY; cy <= endChunkY; cy++) {
                            for (let cx = startChunkX; cx <= endChunkX; cx++) {
                                chunksToRender.add(`${cx},${cy}`);
                            }
                        }

                        // Remove chunks that are out of range
                        for (const [key, containers] of chunkContainers.entries()) {
                            if (!chunksToRender.has(key)) {
                                if (containers.dirt) {
                                    dirtLayer.removeChild(containers.dirt);
                                    containers.dirt.destroy({ children: true });
                                }
                                if (containers.grass) {
                                    grassLayer.removeChild(containers.grass);
                                    containers.grass.destroy({ children: true });
                                }
                                chunkContainers.delete(key);
                            }
                        }

                        // Render new chunks (only if not already rendered)
                        // Time Slicing Scale: More chunks if zoomed out
                        const MAX_CHUNKS_PER_FRAME = Math.max(20, Math.floor(100 / Math.max(0.1, camera.zoom)));
                        let chunksCreated = 0;

                        // Loop through chunks (standard scanline order: top-to-bottom)
                        for (const key of chunksToRender) {
                            if (!chunkContainers.has(key)) {
                                if (chunksCreated < MAX_CHUNKS_PER_FRAME) {
                                    const [cx, cy] = key.split(',').map(Number);
                                    renderChunk(cx, cy);
                                    chunksCreated++;
                                }
                                // If we hit limit, we just stop creating for this frame. 
                                // They will be picked up next frame.
                            }
                            chunksRendered++;
                        }

                        // Update stats with active chunk count (rendered containers)
                        const fps = Math.round(app.ticker.FPS);
                        const activeChunks = chunkContainers.size;
                        const cachedChunks = chunks.size;
                        document.getElementById('info').textContent = `FPS: ${fps} | x: ${Math.floor(player.x)} y: ${Math.floor(player.y)} | Zoom: ${camera.zoom.toFixed(2)}x | Rendered: ${activeChunks} | Cached: ${cachedChunks}`;
                    }

                    // Render overlays (grid, highlights, etc) - called after chunk rendering
                    let overlayGraphics = null;

                    function renderOverlays() {
                        // Skip overlay rendering entirely if grid is disabled (massive performance boost)
                        if (!showGrid) {
                            if (overlayGraphics) {
                                world.removeChild(overlayGraphics);
                                overlayGraphics.destroy();
                                overlayGraphics = null;
                            }
                            return;
                        }

                        // Reuse graphics object (Performance Optimization)
                        if (overlayGraphics) {
                            overlayGraphics.clear();
                        } else {
                            overlayGraphics = new PIXI.Graphics();
                        }

                        // 4. White visual grid (aligned with world grid) - ONLY IF GRID IS ON
                        // Removing "Always Render" behavior to save FPS
                        /*
                       overlayGraphics.lineStyle(0.5, 0xffffff, 0.2);
                        */

                        // Calculate visible area for grid (RESTORED for debug usage)
                        const playerChunkX = Math.round(player.x / TILE_SIZE / CHUNK_SIZE);
                        const playerChunkY = Math.round(player.y / TILE_SIZE / CHUNK_SIZE);
                        const renderDistance = Math.min(5, Math.ceil(5 / Math.max(camera.zoom, 1.0)));
                        const startX = (playerChunkX - renderDistance) * CHUNK_SIZE;
                        const endX = (playerChunkX + renderDistance + 1) * CHUNK_SIZE;
                        const startY = (playerChunkY - renderDistance) * CHUNK_SIZE;
                        const endY = (playerChunkY + renderDistance + 1) * CHUNK_SIZE;

                        /*
                        // ... [omitted expensive generic loop] ...
                        for (let x = startX; x <= endX; x++) { ... }
                        */

                        // Just use the debug loop below if needed.


                        // Multi-layer DEBUG grid system (when G is pressed)
                        if (showGrid) {
                            // 1. Green shades for grass tiles
                            for (let y = startY; y < endY; y++) {
                                for (let x = startX; x < endX; x++) {
                                    if (getTile(x, y) === 1) {
                                        overlayGraphics.beginFill(0x00ff00, 0.1);
                                        overlayGraphics.drawRect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE);
                                        overlayGraphics.endFill();
                                    }
                                }
                            }

                            // 2. Blue chunk boundaries
                            overlayGraphics.lineStyle(2, 0x0000ff, 0.5);
                            const chunkStartX = Math.floor(startX / CHUNK_SIZE) * CHUNK_SIZE;
                            const chunkEndX = Math.ceil(endX / CHUNK_SIZE) * CHUNK_SIZE;
                            const chunkStartY = Math.floor(startY / CHUNK_SIZE) * CHUNK_SIZE;
                            const chunkEndY = Math.ceil(endY / CHUNK_SIZE) * CHUNK_SIZE;

                            for (let x = chunkStartX; x <= chunkEndX; x += CHUNK_SIZE) {
                                overlayGraphics.moveTo(x * TILE_SIZE, chunkStartY * TILE_SIZE);
                                overlayGraphics.lineTo(x * TILE_SIZE, chunkEndY * TILE_SIZE);
                            }
                            for (let y = chunkStartY; y <= chunkEndY; y += CHUNK_SIZE) {
                                overlayGraphics.moveTo(chunkStartX * TILE_SIZE, y * TILE_SIZE);
                                overlayGraphics.lineTo(chunkEndX * TILE_SIZE, y * TILE_SIZE);
                            }
                            overlayGraphics.stroke(); // Make lines visible

                            // 3. Red tile grid
                            overlayGraphics.lineStyle(1, 0xff0000, 0.3);
                            for (let x = startX; x <= endX; x++) {
                                overlayGraphics.moveTo(x * TILE_SIZE, startY * TILE_SIZE);
                                overlayGraphics.lineTo(x * TILE_SIZE, endY * TILE_SIZE);
                            }
                            for (let y = startY; y <= endY; y++) {
                                overlayGraphics.moveTo(startX * TILE_SIZE, y * TILE_SIZE);
                                overlayGraphics.lineTo(endX * TILE_SIZE, y * TILE_SIZE);
                            }
                        }

                        overlayGraphics.stroke(); // Make lines visible

                        overlayGraphics.zIndex = 2000; // Ensure overlays are on top of chunks (zIndex 0) and selection (zIndex 1000)
                        world.addChild(overlayGraphics);
                    }
                });
            } // End initGame function
        }); // End window.addEventListener
    </script>
</body>

</html>