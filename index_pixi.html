<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8">
    <title>tyls.io - PixiJS</title>
    <!-- PixiJS Library -->
    <script src="https://pixijs.download/release/pixi.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #000;
            overflow: hidden;
            font-family: monospace;
        }

        #ui {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            font-size: 12px;
            text-shadow: 1px 1px 2px black;
            background: rgba(0, 0, 0, 0.5);
            padding: 10px;
            border-radius: 5px;
            z-index: 100;
        }
    </style>
</head>

<body>
    <div id="ui">
        <div>WASD/Arrows - Move</div>
        <div>Mouse Wheel - Zoom</div>
        <div>Alt - Freelook</div>
        <div>G - Grid</div>
        <div id="pos"></div>
    </div>

    <script>
        // PixiJS Application Setup
        const app = new PIXI.Application({
            width: window.innerWidth,
            height: window.innerHeight,
            backgroundColor: 0x1a1a1a,
            resolution: window.devicePixelRatio || 1,
            autoDensity: true,
            antialias: false
        });
        document.body.appendChild(app.view);

        // Handle window resize
        window.addEventListener('resize', () => {
            app.renderer.resize(window.innerWidth, window.innerHeight);
        });

        // Constants
        const TILE_SIZE = 16;
        const CHUNK_SIZE = 16;
        const CHUNK_PIXEL_SIZE = CHUNK_SIZE * TILE_SIZE;

        // Load textures
        const grassTexture = PIXI.Texture.from('Assets/grass.png');
        const dirtTexture = PIXI.Texture.from('Assets/dirt.png');
        const frameTexture = PIXI.Texture.from('Assets/frame.png');
        const crosshairTexture = PIXI.Texture.from('Assets/crosshair.png');
        const cursorTexture = PIXI.Texture.from('Assets/cursor.png');

        // Create main containers
        const worldContainer = new PIXI.Container();
        app.stage.addChild(worldContainer);

        // UI Container (always on top)
        const uiContainer = new PIXI.Container();
        app.stage.addChild(uiContainer);

        // Cursor sprite
        const cursorSprite = new PIXI.Sprite(cursorTexture);
        cursorSprite.anchor.set(0.5);
        cursorSprite.width = 32;
        cursorSprite.height = 32;
        uiContainer.addChild(cursorSprite);

        // Crosshair sprite
        const crosshairSprite = new PIXI.Sprite(crosshairTexture);
        crosshairSprite.anchor.set(0.5);
        crosshairSprite.width = 32;
        crosshairSprite.height = 32;
        crosshairSprite.alpha = 0.4;
        uiContainer.addChild(crosshairSprite);

        // Block selector sprite
        const selectorSprite = new PIXI.Sprite();
        selectorSprite.width = TILE_SIZE;
        selectorSprite.height = TILE_SIZE;
        worldContainer.addChild(selectorSprite);

        // Helper: Get texture from spritesheet
        function getTileTexture(baseTexture, index, cols = 4, tileSize = 16) {
            const col = index % cols;
            const row = Math.floor(index / cols);
            return new PIXI.Texture(
                baseTexture,
                new PIXI.Rectangle(col * tileSize, row * tileSize, tileSize, tileSize)
            );
        }

        // Seeded random for dirt tiles
        function seededRandom(x, y) {
            const seed = x * 374761393 + y * 668265263;
            let value = Math.sin(seed) * 43758.5453;
            return value - Math.floor(value);
        }

        function getDirtTileIndex(x, y) {
            return Math.floor(seededRandom(x, y) * 16);
        }

        // Grass tile mapping
        const GRASS_TILE_MAP = {
            '1,1,1,1': 12, '0,1,1,1': 15, '1,0,1,1': 8, '1,1,0,1': 0, '1,1,1,0': 13,
            '0,0,1,1': 9, '1,1,0,0': 3, '0,1,0,1': 11, '1,0,1,0': 1,
            '0,0,0,1': 7, '0,0,1,0': 10, '0,1,0,0': 2, '1,0,0,0': 15,
            '0,1,1,0': 14, '1,0,0,1': 4, '0,0,0,0': 6
        };

        function getGrassTileIndex(x, y) {
            const tl = getTile(x, y);
            const tr = getTile(x + 1, y);
            const bl = getTile(x, y + 1);
            const br = getTile(x + 1, y + 1);
            const key = `${tl},${tr},${bl},${br}`;
            return GRASS_TILE_MAP[key] !== undefined ? GRASS_TILE_MAP[key] : 6;
        }

        // Perlin noise
        class PerlinNoise {
            constructor(seed = 0) {
                this.perm = [];
                for (let i = 0; i < 256; i++) this.perm[i] = i;
                for (let i = 255; i > 0; i--) {
                    const j = Math.floor(seededRandom(i, seed) * (i + 1));
                    [this.perm[i], this.perm[j]] = [this.perm[j], this.perm[i]];
                }
                this.perm = [...this.perm, ...this.perm];
            }
            fade(t) { return t * t * t * (t * (t * 6 - 15) + 10); }
            lerp(t, a, b) { return a + t * (b - a); }
            grad(hash, x, y) {
                const h = hash & 15;
                const u = h < 8 ? x : y;
                const v = h < 4 ? y : h === 12 || h === 14 ? x : 0;
                return ((h & 1) === 0 ? u : -u) + ((h & 2) === 0 ? v : -v);
            }
            noise(x, y) {
                const X = Math.floor(x) & 255;
                const Y = Math.floor(y) & 255;
                x -= Math.floor(x);
                y -= Math.floor(y);
                const u = this.fade(x);
                const v = this.fade(y);
                const a = this.perm[X] + Y;
                const b = this.perm[X + 1] + Y;
                return this.lerp(v,
                    this.lerp(u, this.grad(this.perm[a], x, y), this.grad(this.perm[b], x - 1, y)),
                    this.lerp(u, this.grad(this.perm[a + 1], x, y - 1), this.grad(this.perm[b + 1], x - 1, y - 1))
                );
            }
        }

        const perlin = new PerlinNoise(42);

        // Chunk system
        const chunks = new Map();
        const chunkContainers = new Map();

        function generateChunk(cx, cy) {
            const tiles = [];
            for (let y = 0; y < CHUNK_SIZE; y++) {
                tiles[y] = [];
                for (let x = 0; x < CHUNK_SIZE; x++) {
                    const worldX = cx * CHUNK_SIZE + x;
                    const worldY = cy * CHUNK_SIZE + y;
                    const noise = perlin.noise(worldX * 0.05, worldY * 0.05);
                    tiles[y][x] = noise > 0.1 ? 0 : 1; // 0=grass, 1=dirt
                }
            }
            return tiles;
        }

        function getChunk(cx, cy) {
            const key = `${cx},${cy}`;
            if (!chunks.has(key)) {
                chunks.set(key, generateChunk(cx, cy));
            }
            return chunks.get(key);
        }

        function getTile(worldX, worldY) {
            const cx = Math.floor(worldX / CHUNK_SIZE);
            const cy = Math.floor(worldY / CHUNK_SIZE);
            const chunk = getChunk(cx, cy);
            const tx = ((worldX % CHUNK_SIZE) + CHUNK_SIZE) % CHUNK_SIZE;
            const ty = ((worldY % CHUNK_SIZE) + CHUNK_SIZE) % CHUNK_SIZE;
            return chunk[ty][tx];
        }

        // Render chunk as PixiJS container
        function renderChunk(cx, cy) {
            const key = `${cx},${cy}`;

            // Remove old container if exists
            if (chunkContainers.has(key)) {
                const oldContainer = chunkContainers.get(key);
                worldContainer.removeChild(oldContainer);
                oldContainer.destroy({ children: true });
            }

            const chunk = getChunk(cx, cy);
            const container = new PIXI.Container();

            for (let ty = 0; ty < CHUNK_SIZE; ty++) {
                for (let tx = 0; tx < CHUNK_SIZE; tx++) {
                    const worldX = cx * CHUNK_SIZE + tx;
                    const worldY = cy * CHUNK_SIZE + ty;
                    const visualX = (worldX + 0.5) * TILE_SIZE;
                    const visualY = (worldY + 0.5) * TILE_SIZE;

                    // Dirt sprite
                    const dirtIdx = getDirtTileIndex(worldX, worldY);
                    const dirtSprite = new PIXI.Sprite(getTileTexture(dirtTexture.baseTexture, dirtIdx));
                    dirtSprite.x = visualX;
                    dirtSprite.y = visualY;
                    dirtSprite.anchor.set(0.5);
                    dirtSprite.width = TILE_SIZE;
                    dirtSprite.height = TILE_SIZE;
                    container.addChild(dirtSprite);

                    // Grass sprite
                    const grassIdx = getGrassTileIndex(worldX, worldY);
                    const grassSprite = new PIXI.Sprite(getTileTexture(grassTexture.baseTexture, grassIdx));
                    grassSprite.x = visualX;
                    grassSprite.y = visualY;
                    grassSprite.anchor.set(0.5);
                    grassSprite.width = TILE_SIZE;
                    grassSprite.height = TILE_SIZE;
                    container.addChild(grassSprite);
                }
            }

            worldContainer.addChild(container);
            chunkContainers.set(key, container);
            return container;
        }

        // Player
        const player = {
            x: 0,
            y: 0,
            width: 14,
            height: 14,
            speed: 150
        };

        // Camera
        const camera = {
            x: 0,
            y: 0,
            zoom: 2,
            minZoom: 1,
            maxZoom: 4,
            freelook: false,
            showGrid: false
        };

        // Input
        const keys = {};
        const mouse = {
            x: window.innerWidth / 2,
            y: window.innerHeight / 2,
            leftDown: false,
            rightDown: false
        };

        document.addEventListener('keydown', e => {
            keys[e.key.toLowerCase()] = true;
            if (e.key === 'Alt') {
                camera.freelook = !camera.freelook;
                e.preventDefault();
            }
            if (e.key.toLowerCase() === 'g') {
                camera.showGrid = !camera.showGrid;
            }
        });
        document.addEventListener('keyup', e => {
            keys[e.key.toLowerCase()] = false;
        });

        document.addEventListener('mousemove', (e) => {
            const prevX = mouse.x;
            const prevY = mouse.y;
            mouse.x = e.clientX;
            mouse.y = e.clientY;

            if (camera.freelook && mouse.leftDown) {
                const dx = (mouse.x - prevX) / camera.zoom;
                const dy = (mouse.y - prevY) / camera.zoom;
                camera.x -= dx;
                camera.y -= dy;
            }

            // Drag to place/remove blocks
            if (!camera.freelook && (mouse.leftDown || mouse.rightDown)) {
                const mouseWorldX = mouse.x / camera.zoom + camera.x;
                const mouseWorldY = mouse.y / camera.zoom + camera.y;
                const worldX = Math.floor(mouseWorldX / TILE_SIZE);
                const worldY = Math.floor(mouseWorldY / TILE_SIZE);

                const chunkX = Math.floor(worldX / CHUNK_SIZE);
                const chunkY = Math.floor(worldY / CHUNK_SIZE);
                const chunk = getChunk(chunkX, chunkY);

                const tileX = ((worldX % CHUNK_SIZE) + CHUNK_SIZE) % CHUNK_SIZE;
                const tileY = ((worldY % CHUNK_SIZE) + CHUNK_SIZE) % CHUNK_SIZE;

                if (mouse.leftDown) {
                    chunk[tileY][tileX] = 1; // Place dirt
                    renderChunk(chunkX, chunkY); // Re-render chunk
                } else if (mouse.rightDown) {
                    chunk[tileY][tileX] = 0; // Remove dirt
                    renderChunk(chunkX, chunkY); // Re-render chunk
                }
            }
        });

        document.addEventListener('mousedown', (e) => {
            if (e.button === 0) {
                mouse.leftDown = true;
                // Place block immediately
                if (!camera.freelook) {
                    const mouseWorldX = mouse.x / camera.zoom + camera.x;
                    const mouseWorldY = mouse.y / camera.zoom + camera.y;
                    const worldX = Math.floor(mouseWorldX / TILE_SIZE);
                    const worldY = Math.floor(mouseWorldY / TILE_SIZE);

                    const chunkX = Math.floor(worldX / CHUNK_SIZE);
                    const chunkY = Math.floor(worldY / CHUNK_SIZE);
                    const chunk = getChunk(chunkX, chunkY);

                    const tileX = ((worldX % CHUNK_SIZE) + CHUNK_SIZE) % CHUNK_SIZE;
                    const tileY = ((worldY % CHUNK_SIZE) + CHUNK_SIZE) % CHUNK_SIZE;

                    chunk[tileY][tileX] = 1;
                    renderChunk(chunkX, chunkY);
                }
            } else if (e.button === 2) {
                mouse.rightDown = true;
                // Remove block immediately
                if (!camera.freelook) {
                    const mouseWorldX = mouse.x / camera.zoom + camera.x;
                    const mouseWorldY = mouse.y / camera.zoom + camera.y;
                    const worldX = Math.floor(mouseWorldX / TILE_SIZE);
                    const worldY = Math.floor(mouseWorldY / TILE_SIZE);

                    const chunkX = Math.floor(worldX / CHUNK_SIZE);
                    const chunkY = Math.floor(worldY / CHUNK_SIZE);
                    const chunk = getChunk(chunkX, chunkY);

                    const tileX = ((worldX % CHUNK_SIZE) + CHUNK_SIZE) % CHUNK_SIZE;
                    const tileY = ((worldY % CHUNK_SIZE) + CHUNK_SIZE) % CHUNK_SIZE;

                    chunk[tileY][tileX] = 0;
                    renderChunk(chunkX, chunkY);
                }
            }
        });

        document.addEventListener('mouseup', (e) => {
            if (e.button === 0) mouse.leftDown = false;
            else if (e.button === 2) mouse.rightDown = false;
        });

        document.addEventListener('contextmenu', (e) => e.preventDefault());

        document.addEventListener('wheel', (e) => {
            e.preventDefault();
            const zoomDelta = e.deltaY > 0 ? 0.9 : 1.1;
            camera.zoom = Math.max(camera.minZoom, Math.min(camera.maxZoom, camera.zoom * zoomDelta));
        });

        // Game loop
        let lastTime = performance.now();
        let errorOccurred = false;
        let errorMessage = '';

        // Error handler
        window.addEventListener('error', (e) => {
            errorOccurred = true;
            errorMessage = `ERROR: ${e.message}\nFile: ${e.filename}\nLine: ${e.lineno}`;
            console.error('%c ❌ ERROR:', 'color: red; font-size: 20px; font-weight: bold', e.message);
            console.error('File:', e.filename, 'Line:', e.lineno);
            console.error(e.error);
        });

        app.ticker.add(() => {
            try {
                const time = performance.now();
                const dt = Math.min((time - lastTime) / 1000, 0.1);
                lastTime = time;

                // Movement
                let moveX = 0, moveY = 0;
                if (keys['a'] || keys['arrowleft']) moveX = -1;
                if (keys['d'] || keys['arrowright']) moveX = 1;
                if (keys['w'] || keys['arrowup']) moveY = -1;
                if (keys['s'] || keys['arrowdown']) moveY = 1;

                if (moveX !== 0 && moveY !== 0) {
                    moveX *= 0.707;
                    moveY *= 0.707;
                }

                player.x = Math.round(player.x + moveX * player.speed * dt);
                player.y = Math.round(player.y + moveY * player.speed * dt);

                // Camera follow
                if (!camera.freelook) {
                    camera.x = player.x + player.width / 2 - (app.screen.width / 2) / camera.zoom;
                    camera.y = player.y + player.height / 2 - (app.screen.height / 2) / camera.zoom;
                }

                // Update world container transform
                worldContainer.x = -camera.x * camera.zoom;
                worldContainer.y = -camera.y * camera.zoom;
                worldContainer.scale.set(camera.zoom);

                // Calculate visible chunks
                const viewWidth = app.screen.width / camera.zoom;
                const viewHeight = app.screen.height / camera.zoom;
                const startChunkX = Math.floor((camera.x - TILE_SIZE) / CHUNK_PIXEL_SIZE);
                const endChunkX = Math.ceil((camera.x + viewWidth + TILE_SIZE) / CHUNK_PIXEL_SIZE);
                const startChunkY = Math.floor((camera.y - TILE_SIZE) / CHUNK_PIXEL_SIZE);
                const endChunkY = Math.ceil((camera.y + viewHeight + TILE_SIZE) / CHUNK_PIXEL_SIZE);

                // Render visible chunks
                for (let cy = startChunkY; cy < endChunkY; cy++) {
                    for (let cx = startChunkX; cx < endChunkX; cx++) {
                        const key = `${cx},${cy}`;
                        if (!chunkContainers.has(key)) {
                            renderChunk(cx, cy);
                        }
                    }
                }

                // Update block selector
                if (!camera.freelook) {
                    const mouseWorldX = mouse.x / camera.zoom + camera.x;
                    const mouseWorldY = mouse.y / camera.zoom + camera.y;
                    const hoverWorldX = Math.floor(mouseWorldX / TILE_SIZE);
                    const hoverWorldY = Math.floor(mouseWorldY / TILE_SIZE);

                    selectorSprite.x = hoverWorldX * TILE_SIZE;
                    selectorSprite.y = hoverWorldY * TILE_SIZE;
                    selectorSprite.visible = true;

                    // Frame 0 = hover, Frame 1 = pressed
                    const frameIndex = (mouse.leftDown || mouse.rightDown) ? 1 : 0;
                    selectorSprite.texture = getTileTexture(frameTexture.baseTexture, frameIndex, 1);
                } else {
                    selectorSprite.visible = false;
                }

                // Update crosshair
                crosshairSprite.x = app.screen.width / 2;
                crosshairSprite.y = app.screen.height / 2;

                // Update cursor
                cursorSprite.x = mouse.x;
                cursorSprite.y = mouse.y;

                // UI
                document.getElementById('pos').textContent =
                    `Pos: ${Math.floor(player.x)}, ${Math.floor(player.y)} | Zoom: ${camera.zoom.toFixed(1)}x | Chunks: ${chunks.size} | FPS: ${Math.round(app.ticker.FPS)}`;
            } catch (error) {
                errorOccurred = true;
                errorMessage = `ERROR: ${error.message}\nStack: ${error.stack}`;
                console.error('%c ❌ GAME LOOP ERROR:', 'color: red; font-size: 20px; font-weight: bold', error);
                console.error(error.stack);
            }
        });

        // Initial chunk load
        renderChunk(0, 0);
    </script>
</body>

</html>